rem 
rem $Header: sql.bsq 04-may-2005.14:11:30 mvemulap Exp $ sql.bsq 
rem  MODIFIED
rem   mvemulap   05/02/05 - bug fix for 4318925 
rem   mhho       04/20/05 - change colklc column size in enc$ 
rem   tfyu       02/28/05 - Bug 4262763
rem   htran      03/11/05 - remove transportable from fgr$_tablespace_info
rem   alakshmi   02/28/05 - error recovery for maintain_ apis
rem   ddas       01/07/05 - #(4052436) add hint_string to ol$hints
rem   sourghos   01/06/05 - Fix bug 4043119
rem   ilyubash   11/05/04 - Add gen column to i_aw_prop$ index 
rem   elu        01/03/05 - streams apply spilling 
rem   htran      11/15/04 - comments for spare1 in user$ and streams$_prepare_*
rem   apadmana   10/05/04 - bug3607838: manage any queue
rem   clei       04/15/04 - add view merge permission
rem   weiwang    10/14/04 - set queue flag in base view
rem   mtakahar   09/03/04 - create mon_mods_all$
rem   clei       09/01/04 - add comments to encryption property flags
rem   xuhuali    03/31/04 - audit java 
rem   kdias      07/15/04 - revisit privs granted to OUTLN user 
rem   nmanappa   07/20/04 - bug 3690876 - clean privileges 194-199,239,240
rem   dmwong     07/21/04 - fix connect role to only contain create session 
rem   skaluska   07/09/04 - split up tsm_hist$ into tsm_src$, tsm_dest$ 
rem   araghava   07/07/04 - (3748430): make partitioning indexes unique. 
rem   clei       06/29/04 - add enc$
rem  ssvemuri    06/25/04 - change notification privilege
rem   ramkrish   06/16/04 - correct model nmspc and type 
rem   nshodhan   06/11/04 - use streams$_capture_process.spare3 
rem   liwong     06/08/04 - Add oldest_transaction_id
rem   dcassine   05/28/04 - added ua_notification_handler and ua_ruleset
rem   rvissapr   05/13/04 - bug 3282580 - restrict failed login attempts 
rem   htran      05/17/04 - change comment for apply$_source_schema.global_flag
rem   dsemler    05/14/04 - add dtp support 
rem   dsemler    04/30/04 - remove goodness goal add none 
rem   dsemler    04/13/04 - add service goal to service$ 
rem   jciminsk   04/28/04 - merge from RDBMS_MAIN_SOLARIS_040426 
rem   lchidamb   03/22/04 - add director alert_history table 
rem   skaluska   03/30/04 - instance SID in tsm_hist$ 
rem   skaluska   03/16/04 - TSM recovery 
rem   ckantarj   02/27/04 - add cardinality columns to service$ 
rem   skaluska   03/05/04 - add roundtrips 
rem   jstamos    02/25/04 - director indexes 
rem   jciminsk   12/12/03 - merge from RDBMS_MAIN_SOLARIS_031209 
rem   lchidamb   08/29/03 - add retry_count, retry_time 
rem   lchidamb   08/14/03 - add director quiesce operations table 
rem   lchidamb   08/13/03 - add node/service policy tables 
rem   lchidamb   07/29/03 - add db director escalation table
rem   elu        07/25/03 - modify dir$database_attributes
rem   jstamos    07/29/03 - add director columns 
rem   weiwang    07/17/03 - reserve a property number in 
rem                         streams$_propagation_process
rem   elu        07/08/03 - add grid db priority
rem   ckantarj   07/03/03 - add TAF characteristics to service$ 
rem   jstamos    06/30/03 - add director state
rem   sbodagal   05/13/04 - add chdlevid# to dimjoinkey$
rem   mbrey      04/08/04 - add rsid to cdc_change_sets 
rem   mbrey      03/30/04 - add CDC 10gR2 metadata 
rem   lkaplan    02/22/04 - generic lob assembly 
rem   rvissapr   04/14/04 - dblink changes 
rem   rramkiss   04/21/04 - add CREATE EXTERNAL JOB system privilege 
rem   alakshmi   04/19/04 - system privilege READ_ANY_FILE_GROUP 
rem   htran      04/14/04 - add global_name and file size info for file groups
rem   mxiao      03/25/04 - support synonym in materialized view
rem   sbodagal   04/06/04 - add a column to dimlevel$
rem   ssy        03/18/04 - tables with adt/lob must come after coltype$
rem   ssy        03/08/04 - bug3477195: objauth$ is created as soon as possible
rem   ayoaz      03/02/04 - add index on type$.hashcode
rem   clei       03/08/04 - remove SECURITY_PROFILE privileges
rem   rdecker    03/14/02 - add procedureplsql$
rem   bpwang     03/04/04 - add error_creation_time in apply$_error 
rem   alakshmi   02/24/04 - manage_file_group privilege 
rem   htran      02/18/04 - file group repository tables 
rem   avaliani   02/24/04 - bug 3326388: move inserts after objauth$ creation 
rem   sbalaram   01/26/04 - add apply$_error_txn
rem   ramkrish   12/19/03 - reserve type for mining models
rem   mtakahar   10/22/03 - add storage parameters to stats storage objects
rem   kmuthukk   10/23/03 - plsql ncomp: delete shared lib on drops 
rem   vraja      10/20/03 - bug3161569: rename FLASHBACK ANY TRANSACTION to 
rem                         SELECT ANY TRANSACTION 
rem   ksurlake   11/05/03 - Move creation of reg$ and loc$ to catqueue
rem   mtyulene   09/29/03 - change cache_stats_1$ and cache_stats_0$,
rem   zqiu       10/02/03 - new column in aw_prop$ 
rem   arithikr   10/02/03 - 3121812 - new drop_segments column to 
rem   gmulagun   09/11/03 - change type of audit PROCESS# column 
rem   sbalaram   09/02/03 - add comments for Streams tables
rem   lchidamb   08/29/03 - add retry_time, retry_count 
rem   smuthuli   08/07/03 - add inc# to seg_dollar 
rem   dsemler    08/06/03 - add system service entry 
rem   lchidamb   08/14/03 - add director quiesce operations table 
rem   lchidamb   08/13/03 - add node/service policy tables 
rem   lchidamb   07/29/03 - add db director escalation table
rem   elu        07/25/03 - modify dir$database_attributes
rem   jstamos    07/29/03 - add director columns 
rem   weiwang    07/17/03 - reserve a property number in 
rem                         streams$_propagation_process
rem   elu        07/08/03 - add grid db priority
rem   ckantarj   07/03/03 - add TAF characteristics to service$ 
rem   jstamos    06/30/03 - add director state
rem   clei       05/26/03 - add flg to obj$, syn policy not tied to base obj
rem   mramache   06/23/03 - sql profiles
rem   liwong     06/18/03 - dml_handlers for virtual objects
rem   dsemler    06/12/03 - add svc hash and date hash to service$
rem   liwong     05/30/03 - Support virtual constraints
rem   lkaplan    05/23/03 - assemble lobs
rem   krajaman   05/20/03 - make d_owner# a null column in dependency$
rem   svivian    06/13/03 - add node_name to ol$nodes
rem   mdevin     05/22/03 - smon_scn_time for RAC-global mappings
rem   sbalaram   05/21/03 - add tables to support Streams conf. detection off
rem   tfyu       06/10/03 - comment for view$.flags on MV ref
rem   krajaman   05/20/03 - make d_owner# a null column in dependency$
rem   arithikr   05/21/03 - 1486580 - create ind_online$ table
rem   rvissapr   05/20/03 - bug 2944537 - add exempt identity policy
rem   elu        05/07/03 - add start_scn to streams$_apply_milestone
rem   jstamos    04/24/03 - add temp tables for director
rem   nshodhan   04/18/03 - bug 2691492
rem   skaluska   04/15/03 - transparent session migration
rem   mramache   02/04/03 - change sql$ definition
rem   kyagoub    02/02/03 - Add sql tuning set privileges
rem   mtyulene   01/03/03 - add cache_stats$ table
rem   mtakahar   09/10/02 - add stats_target$
rem   mramache   12/17/02 - adding sql$* tables 
rem   awitkows   04/14/03 - comment for sum.spare1
rem   gmulagun   04/06/03 - bug 2822534: rename tran_id to xid
rem   zqiu       03/10/03 - more columns for aw_obj$
rem   twtong     03/14/03 - add comment to sumkey
rem   vraja      02/10/03 - add FLASHBACK ANY TRANSACTION priv
rem   akalra     02/13/02 - change smon_scn_time
rem   nshodhan   01/30/03 - bug-2773188 add flag for downstream capture
rem   alakshmi   01/20/03 - streams$_capture_process.version varchar2(30=>64)
rem   pabingha   01/17/03 - CDC subscription description length
rem   clei       01/15/03 - change rls_sc$
rem   htran      01/13/03 - unique index only on streams_name for
rem                         streams$_message_consumers
rem   ayoaz      01/03/03 - add AUTHID_CURRENT_USER bit in indtypes$.property
rem   twtong     01/10/03 - fix bug-2677089
rem   lbarton    12/31/02 - modify metascript, metascriptfilter
rem   mbrey      12/19/02 - add columns to cdc_change_tables
rem   htran      12/11/02 - increase size of some Streams columns storing
rem                         procedure names
rem   raguzman   12/19/02 - add dbid column to fga_log$ and aud$
rem   zqiu       12/02/02 - add aw_*$ table indice 
rem   rvissapr   12/15/02 -  make policy text not null
rem   zqiu       11/20/02 - modify aw_*$ tables
rem   akalra     11/26/02 - remove indexes on smon_scn_time
rem   gmulagun   11/20/02 - add lsqlbind clob column
rem   alakshmi   11/08/02 - add streams$_capture_process.version
rem   pabingha   11/11/02 - add b.c. field to cdc_subscribers
rem   gclaborn   11/08/02 - rework metaxslparam$ for new parsing
rem   ataracha   11/07/02 - Add out-of-line flag in opqtype$
rem   smuthuli   12/11/02 - Default permanent tablespace
rem   tfyu       11/22/02 - use of tab$.spare5 for summary dep table info 
rem   mvemulap   09/20/02 - add table for ncomp dlls
rem   akalra     10/31/02 - add indexes on smon_scn_time
rem   mtyulene   10/02/02 - add ind_stats$
rem   rramkiss   10/23/02 - Add job scheduler system privileges
rem   liwong     10/23/02 - Add status_change_time
rem   vmarwah    10/21/02 - lob$ flag comments.
rem   jgalanes   10/22/02 - Add expimp_tts_ct$ for export/import use
rem   apadmana   10/18/02 - Add table streams$_message_rules
rem   apadmana   10/14/02 - Sysaux: Streams
rem   masubram   10/06/02 - add new online redefinition table
rem   schakkap   10/03/02 - tab_stats$, fixed_obj$
rem   zqiu       10/09/02 - add AW_*$ tables to sysaux
rem   asundqui   10/07/02 - new Resource Manager parameters
rem   dcassine   10/03/02 - add start & end date to streams$_apply_process
rem   dcassine   10/01/02 - add start & end date to streams$_capture_process
rem   vmarwah    10/04/02 - Undrop Tables: add BASE_OBJECT to RecycleBin views
rem   gkulkarn   10/09/02 - "Use SPARE1 in ccol$ as a flag field"
rem   apadmana   09/30/02 - Add table streams$_privileged_user
rem   gkulkarn   09/28/02 - Add New supplemental logging constraint types
rem   masubram   08/28/02 - add new dictionary tables for online redefinition
rem   btao       09/20/02 - grant four new privileges to system
rem   gmulagun   09/16/02 - enhance fga_log$ and aud$ audit trails
rem   qyu        09/13/02 - add more property flag in type$ 
rem   kdias      09/13/02 - add advisor priv
rem   rxgovind   09/10/02 - update dependency$ for finer grained dependencies
rem   lbarton    09/18/02 - add metapathmap$
rem   vmarwah    09/04/02 - Undrop Tables: Record BaseObj and Object to purge.
rem   clei       09/04/02 - add ANALYZE ANY DICTIONARY privilege
rem   clei       09/04/02 - add comments on rls$
rem   twtong     09/06/02 - add markerdty to sum$
rem   elu        08/20/02 - add negative rule sets for streams
rem   liwong     08/19/02 - Add streams$_extra_attrs
rem   cku        08/12/02 - lrg 103639 - reserve bit for queues
rem   gtarora    08/23/02 - add endian flag to lob$
Rem   mxiao      07/26/02 - add columns to mlog$, cdc_change_tables$
rem   wnorcott   07/25/02 - CDC named subscriptions
rem   clei       08/12/02 - add suport on new VPD api
rem   qyu        08/12/02 - add more lob property flags in lob$ 
rem   vmarwah    08/08/02 - Undrop Tables: base obj info in RecycleBin$
rem   rpang      07/22/02 - Debug-info flag for type
rem   zqiu       07/17/02 - modify aw$, ps$ for 10i
rem   vmarwah    07/17/02 - Undrop Tables: Reserving Seg$ flag (flushed objs).
rem   tchorma    07/23/02 - Support WITH COLUMN CONTEXT clause for operators
rem   dcassine   07/09/02 - add precommit handler
rem   nshodhan   07/03/02 - streams$_capture_process : downstream capture
rem   mlfeng     07/02/02 - Adding create sysaux
rem   zqiu       07/17/02 - modify aw$, ps$ for 10i
rem   shwang     07/14/02 - bitmap index version in ind$:flags
rem   vkarra     07/19/02 - tablespace groups
rem   mxiao      06/16/02 - Change Snapshot to Materialized View
rem   pabingha   07/12/02 - CDC change source/set new columns
rem   hsbedi     07/19/02 - adding external_tab$ property.
rem   dcwang     05/23/02 - move system privileges on rules.
rem   rvissapr   06/20/02 - add changes to fga
rem   twtong     05/22/02 - add sumqb$ table
rem   twtong     07/22/02 - extend sum$ to support rw equiv
rem   yhu        07/11/02 - enable array insert with domain index
rem   twtong     06/12/02 - extend snap$ to support col alias
rem   tkeefe     05/23/02 - Add new credential type in proxy_data$
rem   tchorma    06/18/02 - Support Alter Operator Add/Drop Binding
rem   mdilman    05/06/02 - add SFT flag to TS$
rem   dcwang     05/02/02 - change property for import/export full database.
rem   twtong     05/09/02 - support MV GR with set opt
rem   asundqui   05/03/02 - consumer group mapping interface
rem   sbedarka   04/16/02 - #(2264056) add index on obj# to various part$
rem   dcwang     03/25/02 - add import/export full database
rem   vmarwah    03/11/02 - Undrop Tables: Creating RECYCLEBIN$ table.
rem   sagrawal   03/04/02 - PL/SQL warnings
rem   lbarton    02/06/02 - new metadata API tables for 10i
rem   twtong     02/11/02 - add name to dimatt$
rem   amanikut   01/29/02 - update comments
rem   araghava   01/18/02 - remove some indexes on partitioned tables
rem                         since they don't improve performance
rem   ayoaz      01/09/02 - Add WITHOUT_DML flag bit in indtypes$.property
rem   jdraaije   01/07/02 - Add dblink to index i_apply_source_obj2
rem   wesmith    11/19/01 - add additional columns to Streams tables
rem   wojeil     11/26/01 - adding global temporary table map_object.
rem   weiwang    11/13/01 - change index i_objtype to unique on two columns
rem   weiwang    11/05/01 - add rules engine system privileges
rem   masubram   11/02/01 - add timestamp column to stream$_prepare_ddl
rem   kmeiyyap   11/02/01 - add streams$_propagation_process.
rem   jingliu    11/01/01 - add timestamp column to streams$_prepare_ddl
rem   nshodhan   11/01/01 - Fix apply$_error
rem   sbalaram   11/01/01 - add columns to milestone
rem   nshodhan   11/01/01 - Fix apply$_error
rem   nshodhan   11/01/01 - Fix apply$_error
rem   masubram   11/01/01 - modify streams$_capture_object
rem   wesmith    10/31/01 - add global_flag to apply$_source_schema, 
rem                         streams$_prepare_ddl
rem   wesmith    10/31/01 - add global_flag to apply$_source_schema, 
rem                         streams$_prepare_ddl
rem   wesmith    10/30/01 - streams$_apply_process: add ruleset
rem   lkaplan    10/29/01 - Change apply$_dest_obj_ops
rem   wesmith    10/29/01 - streams$_apply_process: add more columns
rem   masubram   10/28/01 - modify stream$_prepare_ddl
rem   apadmana   10/26/01 - Move tables from catlrep.sql
rem   lvbcheng   11/05/01 - action line no offset
rem   cmlim      10/31/01 - update reftyp comment in refcon$ for unscoped pkrefs
rem   skabraha   10/24/01 - new properties flag for method$
rem   ayoaz      10/03/01 - add synobj# to subcoltype$.
rem   smuralid   10/25/01 - add "compressed" property-value to lob$
rem   vmarwah    10/18/01 - Extending LOB$ (LOB Retention compatibility).
rem   jcarey     10/18/01 - remove unnecessary aw$ columns
rem   jcarey     09/24/01 - more aw$ and ps$.
rem   esoyleme   09/10/01 - AW$ and PS$.
rem   vshukla    10/29/01 - hsc: row movement - course correction!.
rem   clei       10/02/01 - change rls_grp$ and rls_ctx$
rem   dmwong     10/08/01 - fga.sql_text varchar2->clob.
rem   wojeil     10/30/01 - modifying mapping dict tables.
rem   amanikut   09/24/01 - UDC : fix type$.properties
rem   amanikut   09/11/01 - user-defined constructors
rem   vshukla    09/26/01 - add comments to explain use of spare2 in partobj$,
rem                         tabcompart$.
rem   clei       09/15/01 - change i_rls
rem   weiwang    09/05/01 - i_objtype should not be a unique index
rem   wojeil     09/04/01 - 
rem   ayoaz      05/31/01 - Add synobj# to coltype$.
rem   twtong     09/06/01 - DDL snapsum integration phase II
rem   ayoaz      08/09/01 - add synobj# to attr$, res$, coll$, param$
rem   ayoaz      08/07/01 - Add kotadx
rem   sbasu      08/14/01 - add highboundlen, hiboundval, bhiboundval to 
rem                         [tab|ind]subpart$ for R+(L/R) part.
rem   tfyu       08/22/01 - add bit flag for sumpartlog$
rem   tfyu       08/09/01 - add rowid type for detailcolfunction
rem   akalra     08/28/01 - add FLASHBACK ANY TABLE to privilege maps.
rem   akalra     07/13/01 - use up spare6 in ind$ and tab$
rem   yuli       08/13/01 - change comments of ts$.dflogging
rem   dmwong     07/11/01 - move delete on fga_log$ .
rem   dcwang     07/12/01 - add new privilege: grant any object privilege
rem   dpotapov   08/09/01 - hsc
rem   mxiao      06/28/01 - change SUMMARY to MATERIALIZED VIEW
rem   dmwong     06/18/01 - add delete on fga_log$ to delete_catalog_role.
rem   shshanka   07/17/01 - Add defsubpart$ and defsubpartlob$ for templates.
rem   twtong     05/31/01 - add col instance# to sumdep$
rem   vmarwah    07/10/01 - add processing for LOB RETENTION storage option.
rem                         using a spare field from LOB$ to hold retention.  
rem   lbarton    06/11/01 - add index on lob$(lobj#) and lobcomppart$(partobj#)
rem   wojeil     08/10/01 -
rem   mlfeng     07/23/01 - Adding File Mapping Info
rem   narora     04/17/01 - add index on ntab$(ntab#)
rem   bpanchap   04/11/01 - Adding index on obj# in tabsubpart
rem   mjstewar   03/21/01 - Add password clause to CREATE DATABASE
rem   dpotapov   04/03/01 - hsc
rem   tkeefe     03/06/01 - Simplifying n-tier schema normalization.
rem   wnorcott   02/14/01 - add type, version fields to cdc_change_tables$.
rem   nshodhan   02/06/01 - Remove exptime$
rem   gtarora    02/01/01 - add flag to coltype
rem   masubram   01/22/01 - add timestamp column to sumpartlog$
rem   abrumm     02/06/01 - external_tab$: use LOBs for storing access params
rem   dmwong     12/19/00 - add SELECT ANY DICTIONARY to DBA.
rem   sagrawal   01/08/01 - flags for procedureinfo
rem   rmurthy    01/11/01 - remove sysauth_recurse
rem   dmwong     12/11/00 - fix audit option string.
rem   gtarora    12/14/00 - comment the flags, index for roottoid and supertoid
rem   dalpern    11/30/00 - privileges for kga debugger
rem   clei       11/29/00 - add SELECT ANY DICTIONARY privilege
rem   rwessman   11/20/00 - Fixed typo
rem   rwessman   11/17/00 - Backed out tab_ovf$ due to problems in upgrade and
rem   abgupta    12/11/00 - add flg - idx was created as part of create MV
rem   bemeng     12/11/00 - change object_stats to object_usage
rem   bpanchap   12/27/00 - Adding field to sumpartlog
rem   clei       11/13/00 - add comment for tab$.trigflag
rem   bpanchap   11/21/00 - Adding a flags column to sumpartlog\$
rem   cku        08/28/00 - PBMJI: use col$:spare2
rem   bpanchap   11/07/00 - Adding sequence# to sumdelta$.
rem   mkrishna   11/13/00 - remove not exported column from col$
rem   mkrishna   11/10/00 - change opqtype$ comments for XMLTYPE
rem   varora     11/07/00 - add SQLJ type_misc$ properties
rem   kquinn     11/17/00 - 1375879: alter operator -> alter any operator
rem   mmorsi     10/24/00 - Support for ORAData in SQLJ.
rem   pabingha   09/19/00 - add CDC oid/new timestamps
rem   mkrishna   11/03/00 - add comment
rem   skabraha   10/02/00 - Adding a new property to ind$
rem   lsheng     10/11/00 - add viewcon$ 
rem   rvissapr   09/08/00 - add session_cpu to aud$
rem   apadmana   08/15/00 - Add oldest_new to mlog$
rem   masubram   08/04/00 - modify replication metadata to use CDC
rem   esedlar    12/22/00 - Add sysrole_recurse$
rem   amganesh   09/10/00 - .
rem   smuthuli   07/19/00 - add type for SMU
rem   jklein     08/19/00 - smon scn tracking to time.
rem   mthiyaga   09/07/00 - Add dataless field to sumdetail$
rem   dmwong     08/22/00 - more info in fga_log$.
rem   wesmith    08/18/00 - Use KOTHCL
rem   bemeng     08/17/00 - add default temp tablespace name into props$
rem   mmorsi     08/07/00 - Fix compatibility problem.
rem   araghava   08/05/00 - Add charsetform to partcol$, subpartcol$.
rem   amozes     08/04/00 - add logging flag
rem   wesmith    08/01/00 - Materialized views: change version# to hashcode
rem   mtyulene   08/01/00 - add aux_stats$ table
rem   araghava   07/28/00 - Add bhiboundval to tabpart$,
rem                         tabcompart$, indpart$ and indcompart$.
rem   dmwong     07/28/00 - add type to rls$
rem   dmwong     07/28/00 - add column for client id in aud$.
rem   rwessman   06/29/00 - Added tab_ovf$ to add extra columns to tab$. Adding
rem   dmwong     06/29/00 - add fga_log for fga specific audit trail.
rem   lbarton    07/28/00 - datapump: add metastylesheet
rem   thoang     07/15/00 - Use new macro for type's hashcode 
rem   nagarwal   07/28/00 - add a property flag to ind$ 
rem   rguzman    07/24/00 - Add a flags column to sequences
rem   araghava   06/25/00 - Add charsetid, type#, segcol# to partcol$, 
rem                         subpartcol$
rem   mmorsi     06/29/00 - External java method name (sqlj)..
rem   shihliu    06/27/00 - add resumable privilege
rem   yhu        07/11/00 - add two bits to ind$ (domain idx on IOT & row-move)
rem   kosinski   06/02/00 - Persistent parameters
rem   lsheng     06/28/00 - update comment for cdef$.defer.
rem   rmurthy    06/19/00 - change objauth.option to flag bits
rem   awitkows   06/27/00 - extend sumagg with agginfo
rem   rmurthy    06/29/00 - procedureinfo: add impltype columns for
rem                         pipelined & aggr functions
rem   lbarton    06/23/00 - datapump: move dictionary inserts to catmeta.sql
rem   mkrishna   06/29/00 - add more columns to opqtype$
rem   vkarra     06/18/00 - update ts$ flags
rem   thoang     06/20/00 - Add hashcode column to type$ 
rem   esoyleme   06/20/00 - comment large key flag in ind$
rem   rmurthy    06/23/00 - add flag in col for typeid columns
rem   rherwadk   06/19/00 - change switch_group parameters
rem   vkarra     06/18/00 - update ts$ flags
rem   lbarton    06/12/00 - datapump facility name change
rem   svivian    06/12/00 - add spare field to ol$hints
rem   twtong     06/07/00 - add columns to store instance# for summary metadata
rem   sbodagal   06/06/00 - Use M_IDEN in place of 30 in outln tables
rem   mkrishna   06/06/00 - change opqtype$
rem   kosinski   06/02/00 - Persistent parameters
rem   lbarton    06/01/00 - add more rows to metaxslparam
rem   dpotapov   05/31/00 - Change pdml itl property.
rem   dmwong     05/27/00 - add new system privs into system_privs_map.
rem   rvenkate   05/26/00 - index i_snap2 added for query of snap$ for sec MVs
rem   mkrishna   05/23/00 - add and fix opqtype$
rem   rmurthy    06/06/00 - add short typeid support
rem   slawande   05/19/00 - Add extended flags for snap$.
rem   weiwang    05/16/00 - add column status to reg$
rem   lbarton    05/16/00 - changes to mdAPI tables
rem   bemeng     05/25/00 - add table object_stats
rem   mmorsi     05/15/00 - SQLJ changes for name generation and serialized one
rem   liwong     05/10/00 - Add exptime$
rem   mkrishna   05/10/00 - add opqtype$
rem   spsundar   05/09/00 - remove not null constraint from dataobj# in indpart
rem   sbodagal   05/04/00 - change the size of user_table_name in OL$HINTS
rem   tfyu       05/03/00 - use spare1 of tabsubpart for scn
rem   wixu       05/02/00 - wixu_resman_chg
rem   wesmith    05/02/00 - Revert snap$.rel_query back to a clob
rem   thoang     05/01/00 - Add kottbx$ table for types
rem   aime       05/01/00 - temporary change: rel_query datatype to varchar2
rem   twtong     04/28/00 - add column inline# to sumdep
rem   ayalaman   04/26/00 - iot overflow statistics
rem   bpanchap   04/26/00 - Removing partition object number from sumpred
rem   wesmith    04/24/00 - mlog$ comment fixes
rem   gtarora    04/21/00 - superobj - remove unique index on supertype
rem   rmurthy    04/21/00 - type, attr, method - handle local&inherited
rem   smuthuli   04/20/00 - SMU: Create default undo tablespace
rem   varora     04/19/00 - add vtable
rem   dmwong     04/17/00 - add support for fine grained auditing
rem   wnorcott   04/12/00 - Integrate sync capture with MV logs
rem   liwong     04/12/00 - Reserve 0x80 bit in trigger$.property
rem   gtarora    04/11/00 - Column substitutability
rem   dmwong     04/11/00 - update rls$, rls_ctx$ and rls_grp$ for pfgac
rem   allee      04/13/00 - update spec repository tables.
rem   dmwong     04/07/00 - add support for application role
rem   gclaborn   04/06/00 - Add schema object designator to metaview$
rem   allee      03/23/00 - dictionary enhancement for spec/implementation 
rem                         repository
rem   rguzman    03/23/00 - Comments about Log Groups.
rem   ayalaman   03/23/00 - iot with physical rowid mapping table
rem   rmurthy    03/23/00 - inheritance related changes
rem   tfyu       03/22/00 - change column name in sumkey
rem   tfyu       03/20/00 - add xpflags in sum system table
rem   bemeng     03/13/00 - create default temp ts at db creation time
rem   lbarton    03/17/00 - piots in datapump
rem   twtong     03/17/00 - add suminline table
rem   awitkows   03/15/00 - grouping sets
rem   rwessman   03/14/00 - N-tier enhancements
rem   dmwong     03/13/00 - create new index for rls$
rem   nagarwal   03/09/00 - add version# for statistics type 
rem   gclaborn   03/09/00 - Change mdAPI tables to support multiple models
rem   lbarton    03/08/00 - remove grant on metaxsl
rem   wnorcott   03/07/00 - wnorcott_cdc_metadata
rem   rvissapr   03/03/00 - add flags column to context$ table
rem   lbarton    03/01/00 - modify tables for dbms_metadata
rem   nagarwal   03/01/00 - add partobj# in ustats
rem   narora     02/23/00 - add setnum to unique constraint i_snap_refop1
rem   narora     02/18/00 - add setnum to snap_refop
rem   kmuthiah   02/16/00 - add undertext and undertextlength to typed_view$
rem   kmuthiah   02/16/00 - create indices on superobj$
rem   jingliu    02/15/00 - Add oldest_oid to mlog$ 
rem   spsundar   02/14/00 - add indpart_param$ for partn specific params
rem   ayalaman   02/09/00 - index on urowid column(s) flag
rem   evoss      02/14/00 - external tables
rem   rtoohey    02/07/00 - add comment for pdml itl property on tab$
rem   sbodagal   01/27/00 - introduce a new table outln.ol$nodes
rem                       - add columns to outln.ol$hints table
rem   wixu       01/26/00 - change_for_RES_MANGR_extensions
rem   bpanchap   02/16/00 - Adding sumpred
rem   amozes     01/27/00 - bitmap join index
rem   kmuthiah   01/25/00 - add comments to property of view$
rem   wesmith    01/25/00 - Add tables for replicated objects MV
rem   tfyu       01/17/00 - add sumpartlog table
rem   rjenkins   01/20/00 - extended unicode support
rem   gkulkarn   01/20/00 - Reserve SPARE2 column in OBJ$ for OBJV#
rem   spsundar   12/08/99 - add comment to ind$ to indicate property bit taken
rem   spsundar   12/08/99 - add comment to ind$ to indicate property bit taken
rem   jklein     11/30/99 - row seq #
rem   twtong     11/30/99 - add rewrite obj privilege
rem   gclaborn   11/19/99 - Add tables for Metadata API
rem   twtong     11/17/99 - add ON COMMIT REFRESH obj privilege
rem   weiwang    11/08/99 - add column presentation and version to reg$
rem   jklein     11/30/99 - row seq #
rem   nagarwal   10/29/99 - rename secondary_object
rem   nagarwal   09/21/99 - make changes for ext indexing enhancements
rem   amozes     09/24/99 - add col_usage$                                     
rem   vpesati    08/09/99 - change comment for col property
rem   kosinski   08/13/99 - Bug 822440: Add PLS_TYPE to *_ARGUMENT$
rem   kmuthiah   07/29/99 - add superobj$ & inheritance flags to tab$/view$
rem   vpesati    06/28/99 - modify comment for col property
rem   rshaikh    06/17/99 - sql version                                        
rem   nvishnub   04/19/99 - Add index on expdepobj$ for parent object.
rem   qyu        03/04/99 - add CACHE READS lob mode
rem   susingh    03/02/99 - Add indexes for improving performance. BUG 574099
rem   arrajara   03/01/99 - add index on sys.reg_snap$(snapshot_id)
rem   rshaikh    01/21/99 - add longdbcs to javasnm
rem   sbodagal   12/03/98 - change privileges of outln
rem   masubram   11/17/98 - code review comments                               
rem   weiwang    11/06/98 - add privilege ADMINISTER DATABASE TRIGGER
rem   masubram   10/13/98 - store filter, equijoin bitvectors in snap_reftime
rem   mziauddi   09/22/98 - change priv keyword REWRITE ==> QUERY REWRITE
rem   sbedarka   10/09/98 -  #(725220) set maxvalue cycle for ora_tq_base$ sequ
rem   avaradar   09/15/98 - modify comment for col$.property  
rem   sbasu      09/01/98 - make deftiniexts, defextsize, defminexts, 
rem                         defmaxexts and defextpct columns in PARTOBJ$ 
rem                         nullable so we can represent absence of specified 
rem                         default values by storing NULL's 
rem   kmuthiah   09/21/98 - added 0x00200000 to property flag in col$
rem   amozes     09/22/98 - reserve flag in hist_head                       
rem   akruglik   08/24/98 - modify comment for TAB$.FLAGS                      
rem   syeung     08/18/98 - make [tab|ind]compart$.dataobj# nullable and insert
rem                         NULL to them 
rem   nagarwal   08/17/98 - add 204 & 212 to SYSTEM_PRIVILEGE_MAP
rem   attran     08/11/98 - PIOT:change column dataobj# of tabpart$ to nullable
rem   amozes     07/24/98 - reserve flag for global index stats                
rem   bgoyal     08/07/98 - add disabled flag to ind$                          
rem   whuang     08/19/98 - fake index
rem   mkrishna   07/09/98 -
rem   rwessman   06/12/98  - Fixed i_audit so that multiple proxy users can exi
rem   nagarwal   07/24/98 - remove EXECUTE OPERATOR (204) system privilege
rem   atsukerm   06/03/98 -  add new property flags for trigger$.
rem   akalra     06/12/98 - inicongroup -> defschclass. add comments
rem   hasun      06/05/98  - Fix V8.1 snapshot tables                          
rem   gclaborn   06/04/98 -  Separate exp tables for actions & objects
rem   igreenbe   06/03/98  - fix code walkthrough problems                     
rem   asurpur    06/02/98 -  Add flag to SYSTEM_PRIVILEGE_MAP
rem   rguzman    05/27/98 -  Add REWRITE & GLOBAL REWRITE
rem   bgoyal     05/26/98  - make global keyword required while creating a temp
rem   akalra     05/26/98  - Change tables for resource manager                
rem   mkrishna   06/23/98 -  add attribute# to attrcol table
rem   mjungerm   05/19/98 -  modify javsnm$ to hold utf8
rem   gclaborn   05/19/98 -  Add tables exppkgs$ and expdep$
rem   sbalaram   05/14/98 -  add flavor_id column to snap$                    
rem   nagarwal   05/11/98 -  remove objtype from ustats$
rem   syeung     05/07/98 -  store unspecified [no]logging attributes in 
rem                          [tab|ind]compart$
rem   amozes     04/30/98  - add mon_mods$ for auto_gather_stats               
rem   akruglik   05/06/98 -  add tabfragobj# to lobfrag$ and 
rem                          tabpartobj# to lobcomppart$
rem   nagarwal   05/02/98 -  create indexes on operator catalogs
rem   akruglik   05/01/98 -  add defbufpool to PARTLOB$ and LOBCOMPPART$       
rem   syeung     04/27/98 -  remove type# from tabcompart$ and indcompart$ and
rem                          make deflists and defgroups nullable
rem   bgoyal     04/20/98 -  add property flags to indicate temp. table in ind$
rem   pejustus   04/17/98 -  plan stability changes
rem   rguzman    05/15/98 -  Add columns for expressions in sumkey$
rem   rshaikh    04/15/98 -  replace mlslabel columns
rem   jwlee      04/15/98 -  Transportable/Pluggable Tablespace
rem   esoyleme   04/15/98 -  normalize ruleset$
rem   qyu        04/14/98 -  add flags in coltype$
rem   rguzman    04/10/98 -  modify sum$ to match with sumdep$ changes.
rem   akruglik   04/10/98 -  make deflists and defgroups in PARTLOB$ and
rem                          LOBCOMPART$ nullable so we can represent absense
rem                          of specified default value by storing NULL there
rem   akruglik   04/09/98 -  make defts#, definiexts, defextsize, defminexts, 
rem                          defmaxexts, defextpct in PARTLOB$ and LOBCOMPART$
rem                          nullable so we can represent absense of specified
rem                          default value by storing NULL there + rename
rem                          lobcomppart$.indobj# to indpartobj#
rem   akruglik   04/08/98 -  decided not to set a bit indicating that
rem                          a table contains LOB columns in partobj$.flags
rem                          because in kkpolpd.kkpofpd the information can
rem                          be gleamed from hd
rem   clei       04/08/98 -  add table for row level security
rem   jfeenan    04/08/98 -  Add new dim$ columns and sumdep$
rem   jingliu    04/07/98 -  add temp_log column to mlog$
rem   mluong     04/03/98 -  fix missing ;
rem   bgoyal     04/02/98  - change index stats1 to index on ustat$           
rem   dmwong     04/02/98 -  add context$ and privileges for app ctx           
rem   ato        04/01/98 -  add enqueue/dequeue privileges
rem   esoyleme   04/01/98 -  add obj num to ruleset$
rem   igreenbe   03/31/98  - add scn to snap_reftime$ for null fast refresh   
rem   mkrishna   03/31/98  -                                                   
rem   mkrishna   03/28/98  - add PARENT cols to trigger$                       
rem   amozes     03/27/98 -  mark reserved flags for composite objects         
rem   weiwang    03/26/98 -  Add reg$ and loc$ 
rem   ayalaman   03/26/98 -  define a new flag for sec. index on IOT
rem   amozes     03/26/98 -  add column epvalue to histgrm$
rem   rjenkins   03/25/98 -  adding system-generated column name flag to tab$
rem   jfeenan    03/24/98 -  Create indices for summary and dimension metadata
rem   bgoyal     03/23/98  - flags in lob$
rem   esoyleme   03/23/98 -  add ruleset$
rem   mkrishna   03/19/98  - add nttrigcol to trigger                          
rem   thoang     03/18/98 -  Add tables for partitioning lobs
rem   tanguyen   03/11/98  - change EXTEND to EXTENDS                          
rem   jfeenan    03/10/98 -  add levelid# to dimjoinkey$
rem   amozes     03/09/98 -  add new columns to hist_head                      
rem   alsrivas   03/09/98 -  removing temporary columns from INDTYPES$
rem   smuralid   03/07/98 -  add more flags to coltype$                        
rem   wesmith    03/03/98 -  Modify snap_colmap$ for server-side RepAPI        
rem   hasun      03/01/98 -  Remove unecessary columns from snapshot tables
rem   najain     02/27/98 -  pub_sub support
rem   skaluska   02/27/98 -  Invoker's rights: new property in type_misc$
rem   rwessman   02/25/98 -  Added support for n-tier authentication
rem   kmuthiah   02/25/98 -  add expctoid to refcon$                           
rem   sbasu      02/21/98 -  support for Range Composite part. local indexes
rem                          add table indsubpart$ and indcompart$, rename
rem                          comppart$->tabcompart$
rem   nagarwal   02/19/98 -  Make optimizer catalog changes
rem   bhimatsi   02/19/98 -  bitmapped ts - add flags bits to ts$
rem   nagarwal   02/19/98 -  Modify oparg$
rem   amozes     02/16/98 -  add flags for user-specified stats
rem   jfeenan    02/13/98 -  Add new columns to dim$
rem   rguzman    02/12/98 -  Audit opts: SUMMARY & DIMENSION, 
rem                          remove ALTER SUMMARY
rem   bgoyal     02/10/98 -  add flags for temporary tables                    
rem   qiwang     02/10/98 -  Fix comment for dimjoinkey$
rem   vkarra     02/10/98 -  single table hash clusters
rem   kdias      02/05/98 -  add cols to snap$, snap_reftime$
rem   rguzman    02/05/98 -  Add new Summary Management system privileges.
rem   atsukerm   02/04/98 -  add corrupt flag to seg$.
rem   mramache   02/02/98 -  Add triggerjava$ tables
rem   rjenkins   01/28/98 -  mark functional index columns as NLS dependent
rem   jfeenan    01/28/98 -  Add dimension tables
rem   wesmith    01/21/98 -  Add/modify dict tables for server-side RepAPI     
rem   jfinnert   01/20/98 -  Reserve spare3 in tab$ for summary management
rem   rjenkins   01/20/98 -  remove 0x02 from icol.spare1
rem   whuang     01/16/98 -  online index build project
rem   tanguyen   01/15/98 -  change 'supertypes' to 'supertoid' column in type$
rem   nlewis     01/15/98 -  remove mlslabels
rem   hasun      01/15/98 -  Fix comments to mlog$
rem   akalra     01/13/98 -  Create tables for db scheduler
rem   hasun      01/07/98 -  Add sql_txt dize column to snap$                 
rem   syeung     12/31/97 -  code cleanups for partitioning project:
rem                          rename hybpart$ to comppart$, references to 
rem                          extensible hash -> hash
rem   nagarwal   12/30/97 -  Add statstype# in association$
rem   atsukerm   12/29/97 -  add object# to seg$.
rem   nagarwal   12/23/97 -  Add create operator to resource role
rem   jweisz     12/18/97 -  update comment for collection properties          
rem   akruglik   12/17/97 -  LOB$.PART# will not be used and can be reclaimed 
rem                          if needed
rem   jingliu    12/16/97 -  change comment on job$.field1
rem   rjenkins   12/12/97 -  descending indexes
rem   nagarwal   12/04/97 -  Adding dict tables for ext optimizer
rem   rjenkins   12/04/97 -  adding drop column and functional index flags
rem   khnguyen   11/27/97 -  use spares for lfprecision, fsprecision
rem   jsriniva   11/17/97 -  add key compression to ind$ flags
rem   jsriniva   11/15/97 -  iot: key compression
rem   mjungerm   11/07/97 -  Add Java
rem                          if needed
rem   mjungerm   11/07/97 -  Add Java
rem   jfeenan    11/07/97 -  Add update scn to tab$
rem   wesmith    11/06/97 -  sumdelta$ shape change                            
rem   syeung     11/01/97 -  modified comments in partobj.defts# since number 
rem                          of tablespaces has been moved to spare2 (bytes
rem                          4-5)
rem   thoang     10/29/97 -  Reserved spare2 and spare4 in tab$ for drop column
rem   rmurthy    10/23/97 -  merge from 8.0.4
rem   jfeenan    10/20/97 -  Add summary metadata
rem   nagarwal   10/15/97 -  Change column size in opbinding$
rem   hasun      10/09/97 -  Modify index on sumdelta
rem   nagarwal   10/07/97 -  Change signature size in opbinding$
rem   atsukerm   10/02/97 -  bitmapped tablespaces field definitions.
rem   spsundar   09/18/97 -  comment use of fields for domain idx
rem   hasun      09/16/97 -  Add new table to support snapshots and sumdelta
rem   nagarwal   08/26/97 -  Add return type to opbinding$
rem   alsrivas   08/14/97 -  changing type toid to object number
rem   hasun      08/11/97 -  Change name of sumdelta_dependency to snap_logdep
rem   mkrishna   08/05/97 -  add non-updatable flags to col$.property
rem   alsrivas   07/18/97 -  adding temporary fields for new parameters
rem   syeung     07/03/97 -  add comment for table/index subpartition types in
rem   hasun      07/01/97 -  Add sumdelta and sumdelta_dependency
rem   hasun      06/11/97 -  Add masobj#, masflag to snap_reptime
rem   akruglik   06/09/97 -  expand comment describing parttype/subparttype
rem   akruglik   06/09/97 -  describe usage of partobj$.spare2 in more detail
rem   nagarwal   06/06/97 -  Change OPBINDING.SIGNATURE format
rem   alsrivas   05/27/97 -  adding create indextype to resource role
rem   atsukerm   05/19/97 -  change storage parameters of larger tables
rem   alsrivas   05/19/97 -  makind dictionary changes for indextypes
rem   nagarwal   05/02/97 -  Adding operator to type# in obj$
rem   rjenkins   04/24/97 -  functional indexes
rem   nagarwal   04/24/97 -  Changing signature col in OPBINDING
rem   alsrivas   04/24/97 -  changing indop$
rem   alsrivas   04/21/97 -  modifying indtypes$ and adding privileges
rem   anori      04/18/97 -  fix OIDs for KOT tables
rem   nagarwal   04/16/97 -  Syntax correction
rem   nagarwal   04/15/97 -  Adding privileges for operators
rem   nagarwal   04/11/97 -  Adding tables for operators
rem   alsrivas   04/09/97 -  adding dictionary tables for extensible indexing
rem   mmonajje   04/06/97 -  Replace M_HOST with M_CNCT
rem   syeung     04/05/97 -  add tabsubpart$, tslist$
rem   mkrishna   03/31/97 -  add type component to argument$ (change made by sa
rem   nlewis     03/28/97 -  insert row into trusted_list$
rem   vkarra     03/17/97 -  reserve spare1 in partobj$
rem   hasun      03/05/97 -  Expand rgroup table for parallel propagation
rem   jbellemo   02/25/97 -  remove drops
rem   usundara   01/01/97 -  add PRP flag to properties column in type_misc$
rem   atsukerm   12/16/96 -  add index on tablespace name to ts$.
rem   smuralid   11/21/96 -  add flags to tab$.properties
rem   rshaikh    11/15/96 -  move branch_id and spare to end of pending_sub_ses
rem   abhide     11/08/96 -  change link$
rem   ato        11/04/96 -  add AQ flag to property in tab$
rem   abhide     10/30/96 -  change link$
rem   schandra   10/23/96 -  OTS: Add branch_id column to pending_sub_sessions
rem   hasun      10/24/96 -  Alter snapshot DD:
rem                            slog$ - user#
rem                            snap$ - mas_roll_seg
rem   rshaikh    10/20/96 -  swap columns added from b1->b2 to end
rem   skaluska   10/03/96 -  incomplete types and mutually-referring types
rem                          add property column to dependency$;
rem                          (usundara: add properties to type_misc$)
rem   cxcheng    09/24/96 -  rename KOTTD0$ to KOTTB$ for lint purposes
rem   hasun      09/18/96 -  Fix merge problems
rem   vkrishna   09/12/96 -  add comments
rem   adowning   09/06/96 -  fix merge problem
rem   jsriniva   08/30/96 -  use trunccnt and remove inclcol from ind
rem   smuralid   08/28/96 -  packed type tables not supported
rem   jsriniva   08/26/96 -  add inclcol to ind$ for iots
rem   hasun      08/22/96 -  Reorder column in index i_snap_colmap1
rem   asurpur    08/16/96 -  Changing FAILED_LOGINS to FAILED_LOGIN_ATTEMPTS
rem   cxcheng    08/13/96 -  add create table KOTTD0$
rem   tcheng     08/12/96 -  fix comment in view$.property
rem   hasun      08/12/96 -  Add mtime to snap$ and mlog$ for incremental exp
rem   skaluska   08/09/96 -  Fix comment in clu$
rem   rxgovind   08/02/96 -  add new directory object privs
rem   cxcheng    08/02/96 -  real changes
rem   cxcheng    08/01/96 -  remove INSERT of system type info to type$
rem   skaluska   07/31/96 -  Remove create library from resource
rem   rmurthy    07/28/96 -  add refcon$ table
rem   rshaikh    07/26/96 -  add sys_migrate$ for v7->v8 migration
rem   hasun      07/26/96 -  Add colrole column to snap_colmap$ table
rem   bhimatsi   07/25/96 -  add cols to ts$ for pitr
rem   jwijaya    07/24/96 -  comments for charsetform
rem   jpearson   07/24/96 -  simplify incremental export
rem   tcheng     06/30/96 -  fix comments in triggercol$
rem   cxcheng    06/26/96 -  fix comment for method properties for method$
rem   hasun      06/14/96 -  Normalize snap into snap_reftime
rem   tcheng     06/14/96 -  add comments for col$.property
rem   amganesh   06/13/96 -  adding a defgrp_seq to user
rem   skaluska   06/06/96 -  Add audit$ in library$
rem   amganesh   05/31/96 -  add sequence on ugroup
rem   asurpur    05/30/96 -  Adding grants to exp_full_database/imp_full_databa
rem   hasun      05/29/96 -  Add lobmaskvec column to snap
rem   jpearson   06/11/96 -  modify incexp table for objects
rem   tcheng     05/29/96 -  add flags in view$ - updatability via triggers
rem   cxcheng    05/29/96 -  add charform column to attribute$, collection$ etc
rem   asurpur    05/29/96 -  Increasing the cluster key size
rem   amganesh   05/28/96 -  make i_undo2 nonuniq
rem   jwijaya    05/23/96 -  remove bad comments
rem   asurpur    05/23/96 -  Moving user_history$ table from bootstrap to outsi
rem   hyoshiok   05/22/96 -  add charform in col$
rem   atsukerm   05/22/96 -  add future fields to space dictionary.
rem   amganesh   05/21/96 -  index for ugrp# on ugroup
rem   amganesh   05/21/96 -  creating index on undo.name and ugroup.name
rem   skaluska   05/20/96 -  Add spares, library$, and changes for system gener
rem   tanguyen   05/20/96 -  add EXECUTE ANY TYPE privilege
rem   mmonajje   05/20/96 -  Replace interval col name with interval#
rem   mmonajje   05/20/96 -  Replace timestamp col name with timestamps#
rem   bhimatsi   05/18/96 -  add/rename fields in lob$
rem   cxcheng    05/17/96 - move lob$ table before type$
rem   rjenkins   05/17/96 -  add valid flag to cdef.defer
rem   schandra   05/15/96 -  loosely-coupled branches
rem   schandra   05/15/96 -  loosely-coupled branches
rem   hasun      05/14/96 -  Add snap_colmap
rem   nlewis     05/10/96 -  remove spare1 and spare2 from user$
rem   nlewis     05/09/96 -  PrivDBLinks: add table for Trusted DB list
rem   cxcheng    05/09/96 -  add comments for nchar bit in attribute$
rem   cxcheng    05/08/96 -  remove columns in attribute$, result$, parameter$
rem   smuralid   05/07/96 -  create lob$ before kottd$, kotad$ and kotmd$
rem   amganesh   05/06/96 -  adding cols to undo$ and pending_trans$
rem   amganesh   05/06/96 -  adding cols to undo$ and pending_trans$
rem   jwijaya    05/06/96 -  add LOB namespace and type
rem   hasun      05/06/96 -  replmerge
rem   jwijaya    05/01/96 -  add built-in type bit
rem   jwijaya    04/30/96 -  populate type$ with built-in types
rem   jwijaya    04/26/96 -  fix a bad merge
rem   jwijaya    04/25/96 -  fix col# comment
rem   jwijaya    04/24/96 -  remove unsupported version#
rem   jwijaya    04/22/96 -  cluster type_misc$
rem   ksriniva   04/19/96 -  dictionary changes for database scheduling project
rem   rshaikh    04/18/96 -  add grant directory to stmt_audit_opts_map
rem   mriley     04/16/96 -  add indmethod# to ind$ for cooperative index metho
rem   tcheng     04/16/96 -  add index to typed_view$
rem   jsriniva   04/14/96 -  iot: dictionary clean-up
rem   cxcheng    04/12/96 -  change KOT data structures
rem   vkrishna   04/12/96 -  add flags to lob$, name to ntab$
rem   hasun      04/12/96 -  Normalize snap$ into snap_reftime$ for SQ snaps
rem   ixhu       04/11/96 -  AQ support: new expact$ columns, noexp$ table
rem   jwijaya    04/11/96 -  move oid$ up
rem   asurpur    04/09/96 -  Dictionary Protection Implementation
rem   rshaikh    04/08/96 -  add directory to stmt_audit_opts_map
rem   hasun      04/08/96 -  Add snapshot id sequence
rem   tcheng     04/03/96 -  add typed_view$
rem   hasun      04/01/96 -  Add masterversion columns to snap
rem   jwijaya    03/29/96 -  add intcol# to partcol$
rem   jwijaya    03/25/96 -  index for oid$ column of obj$
rem   hasun      03/25/96 -  Add filter column and equi-join mask vector
rem                          columns to snap_refop$
rem   hasun      03/21/96 -  Modify comments for snap_refop$
rem   hasun      03/20/96 -  Add TABNUM column to snap_refop$
rem   smuralid   03/20/96 -  add new property flag in col$ for columns stored
rem                       -  in lobs
rem   bhimatsi   03/19/96 -  lob$ - add tsno for segment info
rem   hasun      03/15/96 -  Add STATUS columns to snap
rem   rshaikh    03/12/96 -  add type to STMT_AUDIT_OPTION_MAP
rem   sthakur    03/10/96 -  add kopm$, remove koptds$
rem   jwijaya    03/07/96 -  global TOID support
rem   asurpur    03/05/96 -  Logon Re-organization and Password Management
rem   rxgovind   03/04/96 -  add dir$ table
rem   ssamu      02/27/96 -  move 7.3 migration flag to tab/tabpart
rem   bhimatsi   02/27/96 -  minimum feature - add minimum extent to ts$
rem   lwillis    02/07/96 -  Change histogram cluster
rem   jwijaya    02/23/96 -  continue global OID work
rem   hasun      02/20/96 -  Add snap_refop$ to store fast refresh operations
rem   hasun      02/13/96 -  Add sys.mlog_refcol$ for subquery snapshot
rem   smuralid   02/12/96 -  add field kernelcols to tab$
rem   hasun      02/09/96 -  Merge pk_snapshot -> sq_snapshot
rem   ashgupta   02/09/96 -  Merging  snapshot registration code (proj 2045)
rem   jwijaya    02/09/96 -  global OID support (obj$.oid$, oid$)
rem   cxcheng    02/08/96 -  change comment for property in tab$
rem   cxcheng    02/08/96 -  remove value_adt field in type$
rem   tcheng     02/08/96 -  rename adtcol$ to coltype$
rem   ltan       02/08/96 -  PDML: add logging attribute to ts$
rem   akruglik   02/06/96 -  update comment for partobj$.deflogging
rem   ssamu      01/25/96 -  write stats flag to disk
rem   chong      01/25/96 -  fix add type to audit option map
rem   chong      01/23/96 -  add type to audit option map
rem   hasun      01/17/96 -  Remove NOT NULL const from TRIG column of mlog$
rem   jklein     01/11/96 -  freelist space stats for pdml
rem   hyoshiok   01/10/96 -  change col$ table
rem   rjenkins   01/09/96 -  finishing deferred constraintsf
rem   atsukerm   01/03/96 -  allow NULLS for ts# in file$.
rem   cxcheng    12/26/95 -  change column type of toid in attribute$
rem   atsukerm   12/15/95 -  tablespace-relative DBAs.
rem   tcheng     12/10/95 -  change EXTENT TABLE syntax to row type table
rem   mramache   12/07/95 -  add trigflag to tab$
rem   hasun      12/01/95 -  Modify snap$ and mlog$ for primary key snapshots
rem   smuralid   11/30/95 -  add lob object number to LOB$ table
rem   vkrishna   11/20/95 -  Add flags column to ADTCOL$ table
rem   anori      11/08/95 -  fix comments for lob table
rem   anori      11/07/95 -  merge with the BIG branch
rem   tcheng     11/07/95 -  add property to trigger$
rem   aho        11/06/95 -  iot : ind$
rem                          move compressed from flags to property
rem                          add unusable (dls) to flags
rem                          add type, threshold
rem                          rename spare7 to trunccnt
rem   aho        10/30/95 -  iot : tab$
rem                          change clu# to bobj#
rem                          move iot bits from flag to property
rem   rjenkins   10/30/95 -  deferred constraints
rem   schandra   10/13/95 -  Migration - separate status & contents in ts
rem   achaudhr   10/06/95 -  Merge PQ->PTI
rem   skaluska   10/03/95 -  Move partition bit over to property
rem   achaudhr   10/02/95 -  PTI: Fixup degree and instances
rem   echen      09/29/95 -  mergetrans echen_fix_tkxb_diffs
rem   echen      09/29/95 -  Modify table priviliege.
rem   ssamu      09/28/95 -  dual object number phase 2
rem   jsriniva   09/28/95 -  dictionary changes for index only table
rem   jwijaya    09/21/95 -  add attrcol$
rem   ssamu      09/20/95 -  dual object number - cleanup
rem   ssamu      09/18/95 -  dual object numbers
rem   smuralid   09/14/95 -  LOB support - add tables lob$
rem   ssamu      09/12/95 -  dual object numbers
rem   jwijaya    08/28/95 -  add type_misc$
rem   jwijaya    08/25/95 -  remove USAGE from TABLE_PRIVILEGE_MAP
rem   skaluska   08/11/95 -  merge PTI with Objects
rem   varora     06/29/95 -  make intcols/intcol# null/not null
rem   jwijaya    06/16/95 -  add TYPE USAGE 
rem   tcheng     06/06/95 -  modify create extent table syntax 
rem   skotsovo   05/05/95 -  update according to release 1 
rem   jwijaya    04/28/95 -  fix comments 
rem   varora     04/28/95 -  rename col#,usercol#,cols,usercols 
rem   tcheng     03/21/95 -  add col# to adtcol$ and ntab$ 
rem   varora     01/27/95 -  add table for nested table support 
rem   skotsovo   01/25/95 -  bring normalized type tables up to date 
rem   skotsovo   01/23/95 -  move exceptions from method to method_body 
rem   jwijaya    01/04/95 -  add system privileges for type
rem   jwijaya    12/29/94 -  making type$ work (temporarily allow 'version'
rem                          'checks' columns nullable and mark 'checks'
rem                          and 'default$' not-supported (N/S))
rem   skrishna   12/06/94 -  create extent table of pre-defined types 
rem   varora     12/01/94 -  change toid in adtcol$ to type number 
rem   anori      11/17/94 -  ADT support tables and columns
rem
rem !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
rem Whenever new column is created to store internal, user or kernel column
rem number, be sure to update the structure adtDT in atb.c so that those 
rem columns will be updated properly during drop column.
rem !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
rem
create tablespace SYSTEM datafile "D_DBFN" 
  "D_DSTG" online
/
create rollback segment SYSTEM tablespace SYSTEM
  storage (initial 50K next 50K)
/
create cluster c_obj# (obj# number)
  pctfree 5 size 800                           /* don't waste too much space */
  /* A table of 32 cols, 2 index, 2 col per index requires about 2K.
   * A table of 10 cols, 2 index, 2 col per index requires about 750.
   */
  storage (initial 130K next 200k maxextents unlimited pctincrease 0) 
  /* avoid space management during IOR I */
/
create index i_obj# on cluster c_obj#
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table tab$                                             /* table table */
( obj#          number not null,                            /* object number */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#      number,                          /* data layer object number */
  ts#           number not null,                        /* tablespace number */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  bobj#         number,                /* base object number (cluster / iot) */
  tab#          number,    /* table number in cluster, NULL if not clustered */
  cols          number not null,                        /* number of columns */
  clucols       number,/* number of clustered columns, NULL if not clustered */
  pctfree$      number not null, /* minimum free space percentage in a block */
  pctused$      number not null, /* minimum used space percentage in a block */
  initrans      number not null,            /* initial number of transaction */
  maxtrans      number not null,            /* maximum number of transaction */
  flags         number not null, /* 0x00     = unmodified since last backup 
                                    0x01     = modified since then 
                                    0x02     = DML locks restricted to <= SX 
                                    0x04     = DML locks <= SX not acquired
                                    0x08     = CACHE  
                                    0x10     = table has been analyzed
                                    0x20     = table has no logging
                                    0x40     = 7.3 -> 8.0 data object
                                               migration required    
                                    0x0080   = current summary dependency
                                    0x0100   = user-specified stats
                                    0x0200   = global stats           
                                    0x0800   = table has security policy 
                                    0x020000 = Move Partitioned Rows 
                                   0x0400000 = table has sub tables
                                  0x00800000 = row dependencies enabled */
                /* 0x10000000 = this IOT has a  physical rowid mapping table */
                /* 0x20000000 = mapping table of an IOT(with physical rowid) */
  audit$        varchar2("S_OPFL") not null,             /* auditing options */
  rowcnt        number,                                    /* number of rows */
  blkcnt        number,                                  /* number of blocks */
  empcnt        number,                            /* number of empty blocks */
  avgspc        number,       /* average available free space/iot ovfl stats */
  chncnt        number,                            /* number of chained rows */
  avgrln        number,                                /* average row length */
  avgspc_flb    number,       /* avg avail free space of blocks on free list */
  flbcnt        number,                             /* free list block count */
  analyzetime   date,                        /* timestamp when last analyzed */
  samplesize    number,                 /* number of rows sampled by Analyze */
/* 
 * Legal values for degree, instances: 
 *     NULL (used to represent 1 on disk/dictionary and implies noparallel), or
 *     2 thru EB2MAXVAL-1 (user supplied values), or
 *     EB2MAXVAL (implies use default value) 
 */
  degree        number,      /* number of parallel query slaves per instance */
  instances     number,        /* number of OPS instances for parallel query */
/* <intcols> => the number of dictionary columns => the number of columns 
 * that have dictionary meta-data associated with them. This is a superset of 
 * <usercols> and <kernelcols>. 
 *    <intcols> = <kernelcols> + <number_of_virtual_columns>
 */
  intcols       number not null,               /* number of internal columns */
/* <kernelcols> => the number of REAL columns (ie) columns that actually
 * store data.
 */
  kernelcols    number not null,          /* number of REAL (kernel) columns */
  property      number not null,            /* table properties (bit flags): */
                              /* 0x01 = typed table, 0x02 = has ADT columns, */
                 /* 0x04 = has nested-TABLE columns, 0x08 = has REF columns, */
                      /* 0x10 = has array columns, 0x20 = partitioned table, */
               /* 0x40 = index-only table (IOT), 0x80 = IOT w/ row OVerflow, */
             /* 0x100 = IOT w/ row CLustering, 0x200 = IOT OVeRflow segment, */
               /* 0x400 = clustered table, 0x800 = has internal LOB columns, */
        /* 0x1000 = has primary key-based OID$ column, 0x2000 = nested table */
                    /* 0x4000 = View is Read Only, 0x8000 = has FILE columns */
       /* 0x10000 = obj view's OID is system-gen, 0x20000 = used as AQ table */
                                   /* 0x40000 = has user-defined lob columns */
                               /* 0x00080000 = table contains unused columns */
                            /* 0x100000 = has an on-commit materialized view */
                             /* 0x200000 = has system-generated column names */
                                      /* 0x00400000 = global temporary table */
                            /* 0x00800000 = session-specific temporary table */
                                        /* 0x08000000 = table is a sub table */
                                        /*   0x20000000 = pdml itl invariant */
                                          /* 0x80000000 = table is external  */
  trigflag      number,   /* first two bytes for trigger flags, the rest for */
                   /* general use, check tflags_kqldtvc in kqld.h for detail */
                                            /* 0x00000001 deferred RPC Queue */
                                                  /* 0x00000002 snapshot log */
                                        /* 0x00000004 updatable snapshot log */
                                             /* 0x00000008 = context trigger */
                                    /* 0x00000010 = synchronous change table */
                     /* 0x00010000 = server-held key encrypted columns exist */
                       /* 0x00020000 = user-held key encrypted columns exist */
                                       /* 0x00200000 = table had rowmovement */
                                     /* 0x00400000 = lobs use shared segment */
                                                 /* 0x00800000 = queue table */
                                   /* 0x10000000 = streams unsupported table */
                                            /* enabled at some point in past */
  spare1        number,                       /* used to store hakan_kqldtvc */
  spare2        number,         /* committed partition # used by drop column */
  spare3        number,                           /* summary sequence number */
  spare4        varchar2(1000),         /* committed RID used by drop column */
  spare5        varchar2(1000),      /* summary related information on table */
  spare6        date                                  /* flashback timestamp */
)
cluster c_obj#(obj#)
/  
create table clu$                                           /* cluster table */
( obj#          number not null,                            /* object number */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#      number,                          /* data layer object number */
  ts#           number not null,                        /* tablespace number */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  cols          number not null,                        /* number of columns */
  pctfree$      number not null, /* minimum free space percentage in a block */
  pctused$      number not null, /* minimum used space percentage in a block */
  initrans      number not null,            /* initial number of transaction */
  maxtrans      number not null,            /* maximum number of transaction */
  size$         number,
       /* if b-tree, estimated number of bytes for each cluster key and rows */
  hashfunc      varchar2("M_IDEN"),        /* if hashed, function identifier */

  /* Some of the spare columns may give the initial # bytes in the hash table
   * and the # hash keys per block.  These are user-specified parameters.
   * For extendible hash tables, two columns might include the # bits
   * currently be used in the hash function and the number of the next
   * bucket to split.
   * Some spare columns may be used for hash table statistics
   * such as # distinct keys, # distinct values of first key column, and
   * average # blocks per key.  Some spare columns  may give the number of
   * the cluster table for which the cluster key is unique or indicate
   * whether the cluster is normal or referential.
   * We can encode multiple pieces of info in a single column.
   */
  hashkeys      number,                                    /* hash key count */
  func          number, /* function: 0 (key is function), 1 (system default) */
  extind        number,             /* extent index value of fixed hash area */
  flags         number,                                      /* 0x08 = CACHE */
                                          /* 0x010000 = Single Table Cluster */
                                                /* 0x00800000 = DEPENDENCIES */
/* 
 * Legal values for degree, instances: 
 *     NULL (used to represent 1 on disk/dictionary and implies noparallel), or
 *     2 thru EB2MAXVAL-1 (user supplied values), or
 *     EB2MAXVAL (implies use default value) 
 */
  degree        number,      /* number of parallel query slaves per instance */
  instances     number,       /*  number of OPS instances for parallel query */
  avgchn        number,          /* average chain length - previously spare4 */
  spare1        number,                /* used for trigger non-trigger flags */
                                                          /* 0x1 replication */
                                                         /* 0x2 snapshot log */
                                                             /* 0x4 snapshot */
                                             /* 0x8 context internal trigger */
                                            /* 0x10 synchronous change table */
                             /* 0x00010000 One or more columns are encrypted */
                                   /*    0x00020000 All columns are encrypted*/
                                           /* 0x00040000 needs to do logging */
                                                   /* 0x00080000 MV Dataless */
                                   /* 0x00100000 IOT transient table for PMO */
                                                            /* 0x00200000 MPR*/
                                        /* 0x00400000  QUEue organized table */
  spare2        number,
  spare3        number,
  spare4        number,
  spare5        varchar2(1000),
  spare6        varchar2(1000),
  spare7        date
)
cluster c_obj#(obj#)
/
create cluster c_ts#(ts# number)           /* use entire block for each ts# */
/
create index i_ts# on cluster c_ts#
/
create cluster c_file#_block#(ts# number, segfile# number, segblock# number) 
  size 225    /* cluster key ~ 25, sizeof(seg$) ~ 50, 5 * sizeof(uet$) ~ 150 */
  storage (initial 20K)               /* avoid space management during IOR I */
/
create index i_file#_block# on cluster c_file#_block#
/
create cluster c_user#(user# number) 
  size  372 /* cluster key ~ 20, sizeof(user$) ~ 227, 5 * sizeof(tsq$) ~ 125 */
/
create index i_user# on cluster c_user#
/
create table fet$                                       /* free extent table */
( ts#           number not null,        /* tablespace containing free extent */
  file#         number not null,              /* file containing free extent */
  block#        number not null,              /* starting dba of free extent */
  length        number not null           /* length in blocks of free extent */
)
cluster c_ts#(ts#)
/
create table uet$                                       /* used extent table */
( segfile#      number not null,               /* segment header file number */
  segblock#     number not null,              /* segment header block number */
  ext#          number not null,         /* extent number within the segment */
  ts#           number not null,        /* tablespace containing this extent */
  file#         number not null,              /* file containing this extent */
  block#        number not null,              /* starting dba of this extent */
  length        number not null           /* length in blocks of this extent */
)
cluster c_file#_block#(ts#, segfile#, segblock#)
/
create table seg$                                           /* segment table */
( file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  type#         number not null,                /* segment type (see KTS.H): */
   /* 1 = UNDO, 2 = SAVE UNDO, 3 = TEMPORARY, 4 = CACHE, 5 = DATA, 6 = INDEX */
   /* 7 = SORT  8 = LOB   9 = Space Header 10 = System Managed Undo          */
  ts#           number not null,       /* tablespace containing this segment */
  blocks        number not null,       /* blocks allocated to segment so far */
                                           /* zero for bitmapped tablespaces */
  extents       number not null,      /* extents allocated to segment so far */
                                           /* zero for bitmapped tablespaces */
  iniexts       number not null,                      /* initial extent size */
  minexts       number not null,                /* minimum number of extents */
  maxexts       number not null,                /* maximum number of extents */
  extsize       number not null,                 /* current next extent size */
                                           /* zero for bitmapped tablespaces */
  extpct        number not null,                    /* percent size increase */
  user#         number not null,               /* user who owns this segment */
  lists         number,                        /* freelists for this segment */
  groups        number,                  /* freelist groups for this segment */
  bitmapranges  number not null,                 /* ranges per bit map entry */
  cachehint     number not null,                        /* hints for caching */
  scanhint      number not null,                       /* hints for scanning */
                                       /* Reuse it as inc# for ASSM segments */
  hwmincr       number not null,             /* Amount by which HWM is moved */
                                          /* Reuse it as object number/class */
                                     /* for objects in bitmapped tablespaces */
  spare1        number,                        /* Segment flags - NULL = 0x0 */
                                               /* 0x1 - bitmapped tablespace */
                                                       /* 0x2 - undo segment */
                                                   /* 0x4 - saveundo segment */
                                             /* 0x8 - segment marked corrupt */
                                   /* #define KTSSEGM_FLAG_COMPRESSED 0x0800 */
                                   /* #define KTSSEGM_FLAG_HASCPRSSED 0x1000 */
                                   /* #define KTSSEGM_FLAG_ROWMOVEMNT 0x2000 */
                                   /* #define KTSSEGM_FLAG_HASMOVEMNT 0x4000 */
                 /*0x10000 - seg flushed from cache: KTSSEGM_FLAG_RECYCLEBIN */
  spare2        number
)
cluster c_file#_block#(ts#, file#, block#)
/
create table undo$                                     /* undo segment table */
( us#           number not null,                      /* undo segment number */
  name          varchar2("M_IDEN") not null,    /* name of this undo segment */
  user#         number not null,      /* owner: 0 = SYS(PRIVATE), 1 = PUBLIC */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  scnbas        number,           /* highest commit time in rollback segment */
  scnwrp        number,              /* scnbas - scn base, scnwrp - scn wrap */
  xactsqn       number,               /* highest transaction sequence number */
  undosqn       number,                /* highest undo block sequence number */
  inst#         number,    /* parallel server instance that owns the segment */
  status$       number not null,              /* segment status (see KTS.H): */
  /* 1 = INVALID, 2 = AVAILABLE, 3 = IN USE, 4 = OFFLINE, 5 = NEED RECOVERY, 
   * 6 = PARTLY AVAILABLE (contains in-doubt txs) 
   */
  ts#           number,                                 /* tablespace number */
  ugrp#         number,                      /* The undo group it belongs to */
  keep          number,
  optimal       number,
  flags         number,
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)

/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table ts$                                         /* tablespace table */
( ts#           number not null,             /* tablespace identifier number */
  name          varchar2("M_IDEN") not null,           /* name of tablespace */
  owner#        number not null,                      /* owner of tablespace */
  online$       number not null,                      /* status (see KTT.H): */
                                     /* 1 = ONLINE, 2 = OFFLINE, 3 = INVALID */
  contents$     number not null,     /* TEMPORARY/PERMANENT                  */
  undofile#     number,  /* undo_off segment file number (status is OFFLINE) */
  undoblock#    number,               /* undo_off segment header file number */
  blocksize     number not null,                   /* size of block in bytes */
  inc#          number not null,             /* incarnation number of extent */
  scnwrp        number,     /* clean offline scn - zero if not offline clean */
  scnbas        number,              /* scnbas - scn base, scnwrp - scn wrap */
  dflminext     number not null,       /*  default minimum number of extents */
  dflmaxext     number not null,        /* default maximum number of extents */
  dflinit       number not null,              /* default initial extent size */
  dflincr       number not null,                 /* default next extent size */
  dflminlen     number not null,              /* default minimum extent size */
  dflextpct     number not null,     /* default percent extent size increase */
  dflogging     number not null,
      /* lowest bit: default logging attribute: clear=NOLOGGING, set=LOGGING */
                                    /* second lowest bit: force logging mode */
  affstrength   number not null,                        /* Affinity strength */
  bitmapped     number not null,       /* If not bitmapped, 0 else unit size */
                                                                /* in blocks */
  plugged       number not null,                               /* If plugged */
  directallowed number not null,   /* Operation which invalidate standby are */
                                                                  /* allowed */
  flags         number not null,                            /* various flags */
                                         /* 0x01 = system managed allocation */
                                         /* 0x02 = uniform allocation        */
                                /* if above 2 bits not set then user managed */
                                         /* 0x04 = migrated tablespace       */
                                         /* 0x08 = tablespace being migrated */
                                         /* 0x10 = undo tablespace           */
                                     /* 0x20 = auto segment space management */
                       /* if above bit not set then freelist segment managed */
                                                          /* 0x40 = COMPRESS */
                                                      /* 0x80 = ROW MOVEMENT */
                                                              /* 0x100 = SFT */
                                         /* 0x200 = undo retention guarantee */
                                    /* 0x400 = tablespace belongs to a group */
                                  /* 0x800 = this actually describes a group */
  pitrscnwrp    number,                      /* scn wrap when ts was created */
  pitrscnbas    number,                      /* scn base when ts was created */
  ownerinstance varchar("M_IDEN"),                    /* Owner instance name */
  backupowner   varchar("M_IDEN"),             /* Backup owner instance name */
  groupname     varchar("M_IDEN"),                             /* Group name */
  spare1        number,                                  /* plug-in SCN wrap */
  spare2        number,                                  /* plug-in SCN base */
  spare3        varchar2(1000),
  spare4        date
)
cluster c_ts#(ts#)
/
create table file$                                             /* file table */
( file#         number not null,                   /* file identifier number */
  status$       number not null,                      /* status (see KTS.H): */
                                               /* 1 = INVALID, 2 = AVAILABLE */
  blocks        number not null,                   /* size of file in blocks */
                                           /* zero for bitmapped tablespaces */
  ts#           number,                         /* tablespace that owns file */
  relfile#      number,                              /* relative file number */
  maxextend     number,                                 /* maximum file size */
  inc           number,                                  /* increment amount */
  crscnwrp      number,                                 /* creation SCN wrap */
  crscnbas      number,                                 /* creation SCN base */
  ownerinstance varchar("M_IDEN"),                    /* Owner instance name */
  spare1        number,      /* tablespace-relative DBA of space file header */
                                   /* NULL for dictionary-mapped tablespaces */
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table obj$                                            /* object table */
( obj#          number not null,                            /* object number */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */ 
  dataobj#      number,                          /* data layer object number */
  owner#        number not null,                        /* owner user number */
  name          varchar2("M_IDEN") not null,                  /* object name */
  namespace     number not null,         /* namespace of object (see KQD.H): */
 /* 1 = TABLE/PROCEDURE/TYPE, 2 = BODY, 3 = TRIGGER, 4 = INDEX, 5 = CLUSTER, */
                                                  /* 8 = LOB, 9 = DIRECTORY, */
  /* 10 = QUEUE, 11 = REPLICATION OBJECT GROUP, 12 = REPLICATION PROPAGATOR, */
                                     /* 13 = JAVA SOURCE, 14 = JAVA RESOURCE */
                                                 /* 58 = (Data Mining) MODEL */
  subname       varchar2("M_IDEN"),               /* subordinate to the name */
  type#         number not null,                 /* object type (see KQD.H): */
  /* 1 = INDEX, 2 = TABLE, 3 = CLUSTER, 4 = VIEW, 5 = SYNONYM, 6 = SEQUENCE, */
             /* 7 = PROCEDURE, 8 = FUNCTION, 9 = PACKAGE, 10 = NON-EXISTENT, */
              /* 11 = PACKAGE BODY, 12 = TRIGGER, 13 = TYPE, 14 = TYPE BODY, */
      /* 19 = TABLE PARTITION, 20 = INDEX PARTITION, 21 = LOB, 22 = LIBRARY, */
                                             /* 23 = DIRECTORY , 24 = QUEUE, */
    /* 25 = IOT, 26 = REPLICATION OBJECT GROUP, 27 = REPLICATION PROPAGATOR, */
    /* 28 = JAVA SOURCE, 29 = JAVA CLASS, 30 = JAVA RESOURCE, 31 = JAVA JAR, */
                 /* 32 = INDEXTYPE, 33 = OPERATOR , 34 = TABLE SUBPARTITION, */
                                                  /* 35 = INDEX SUBPARTITION */
                                                 /* 82 = (Data Mining) MODEL */
  ctime         date not null,                       /* object creation time */
  mtime         date not null,                      /* DDL modification time */
  stime         date not null,          /* specification timestamp (version) */
  status        number not null,            /* status of object (see KQD.H): */
                                     /* 1 = VALID/AUTHORIZED WITHOUT ERRORS, */
                          /* 2 = VALID/AUTHORIZED WITH AUTHORIZATION ERRORS, */
                            /* 3 = VALID/AUTHORIZED WITH COMPILATION ERRORS, */
                         /* 4 = VALID/UNAUTHORIZED, 5 = INVALID/UNAUTHORIZED */
  remoteowner   varchar2("M_IDEN"),     /* remote owner name (remote object) */
  linkname      varchar2("M_XDBI"),             /* link name (remote object) */
  flags         number,               /* 0x01 = extent map checking required */
                                      /* 0x02 = temporary object             */
                                      /* 0x04 = system generated object      */
                                      /* 0x08 = unbound (invoker's rights)   */
                                      /* 0x10 = secondary object             */
                                      /* 0x20 = in-memory temp table         */
                                      /* 0x80 = dropped table (RecycleBin)   */
                                      /* 0x100 = synonym VPD policies        */
                                      /* 0x200 = synonym VPD groups          */
                                      /* 0x400 = synonym VPD context         */
  oid$          raw(16),        /* OID for typed table, typed view, and type */
  spare1        number,                      /* sql version flag: see kpul.h */
  spare2        number,                             /* object version number */
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table ind$                                             /* index table */
( obj#          number not null,                            /* object number */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#      number,                          /* data layer object number */
  ts#           number not null,                        /* tablespace number */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  bo#           number not null,              /* object number of base table */
  indmethod#    number not null,    /* object # for cooperative index method */
  cols          number not null,                        /* number of columns */
  pctfree$      number not null, /* minimum free space percentage in a block */
  initrans      number not null,            /* initial number of transaction */
  maxtrans      number not null,            /* maximum number of transaction */
  pctthres$     number,           /* iot overflow threshold, null if not iot */
  type#         number not null,              /* what kind of index is this? */
                                                               /* normal : 1 */
                                                               /* bitmap : 2 */
                                                              /* cluster : 3 */
                                                            /* iot - top : 4 */
                                                         /* iot - nested : 5 */
                                                            /* secondary : 6 */
                                                                 /* ansi : 7 */
                                                                  /* lob : 8 */
                                             /* cooperative index method : 9 */
  flags         number not null,      
                /* mutable flags: anything permanent should go into property */
                                                    /* unusable (dls) : 0x01 */
                                                    /* analyzed       : 0x02 */
                                                    /* no logging     : 0x04 */
                                    /* index is currently being built : 0x08 */
                                     /* index creation was incomplete : 0x10 */
                                           /* key compression enabled : 0x20 */
                                              /* user-specified stats : 0x40 */
                                            /* secondary index on IOT : 0x80 */
                                      /* index is being online built : 0x100 */
                                    /* index is being online rebuilt : 0x200 */
                                                /* index is disabled : 0x400 */
                                                     /* global stats : 0x800 */
                                            /* fake index(internal) : 0x1000 */
                                       /* index on UROWID column(s) : 0x2000 */
                                            /* index with large key : 0x4000 */
                             /* move partitioned rows in base table : 0x8000 */
                                 /* index usage monitoring enabled : 0x10000 */
                      /* 4 bits reserved for bitmap index version : 0x1E0000 */
  property      number not null,    /* immutable flags for life of the index */
                                                            /* unique : 0x01 */
                                                       /* partitioned : 0x02 */
                                                           /* reverse : 0x04 */
                                                        /* compressed : 0x08 */
                                                        /* functional : 0x10 */
                                              /* temporary table index: 0x20 */
                             /* session-specific temporary table index: 0x40 */
                                              /* index on embedded adt: 0x80 */
                         /* user said to check max length at runtime: 0x0100 */
                                              /* domain index on IOT: 0x0200 */
                                                      /* join index : 0x0400 */
                /* functional index expr contains a PL/SQL function : 0x0800 */
                           /* The index was created by a constraint : 0x1000 */
                              /* The index was created by create MV : 0x2000 */
  /* The following columns are used for index statistics such
   * as # btree levels, # btree leaf blocks, # distinct keys, 
   * # distinct values of first key column, average # leaf blocks per key,
   * clustering info, and # blocks in index segment.
   */
  blevel        number,                                       /* btree level */
  leafcnt       number,                                  /* # of leaf blocks */
  distkey       number,                                   /* # distinct keys */
  lblkkey       number,                          /* avg # of leaf blocks/key */
  dblkkey       number,                          /* avg # of data blocks/key */
  clufac        number,                                 /* clustering factor */
  analyzetime   date,                        /* timestamp when last analyzed */
  samplesize    number,                 /* number of rows sampled by Analyze */
  rowcnt        number,                       /* number of rows in the index */
  intcols       number not null,               /* number of internal columns */
         /* The following two columns are only valid for partitioned indexes */
/* 
 * Legal values for degree, instances: 
 *     NULL (used to represent 1 on disk/dictionary and implies noparallel), or
 *     2 thru EB2MAXVAL-1 (user supplied values), or
 *     EB2MAXVAL (implies use default value) 
 */
  degree        number,      /* number of parallel query slaves per instance */
  instances     number,       /*  number of OPS instances for parallel query */

  trunccnt      number,                        /* re-used for iots 'inclcol' */
  spare1        number,         /* number of columns depended on, >= intcols */
  spare2        number,        /* number of key columns in compressed prefix */
  spare3        number,
  spare4        varchar2(1000),     /* used for parameter str for domain idx */
  spare5        varchar2(1000),
  spare6        date                                  /* flashback timestamp */
)
cluster c_obj#(bo#)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table icol$                                     /* index column table */
( obj#          number not null,                      /* index object number */
  bo#           number not null,                       /* base object number */
  col#          number not null,                            /* column number */
  pos#          number not null,        /* column position number as created */
  segcol#       number not null,                 /* column number in segment */
  segcollength  number not null,             /* length of the segment column */
  offset        number not null,                         /* offset of column */
  intcol#       number not null,                   /* internal column number */
  spare1        number,                                              /* flag */
                                              /* 0x01: this is an expression */
  spare2        number,            /* dimension table internal column number */
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
cluster c_obj#(bo#)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table col$                                            /* column table */
( obj#          number not null,             /* object number of base object */
  col#          number not null,                 /* column number as created */
  segcol#       number not null,                 /* column number in segment */
  segcollength  number not null,             /* length of the segment column */
  offset        number not null,                         /* offset of column */
  name          varchar2("M_IDEN") not null,               /* name of column */
  type#         number  not null,                     /* data type of column */
                                           /* for ADT column, type# = DTYADT */
  length        number  not null,               /* length of column in bytes */
  fixedstorage  number  not null,   /* flags: 0x01 = fixed, 0x02 = read-only */
  precision#    number,                                         /* precision */
  scale         number,                                             /* scale */
  null$         number not null,                     /* 0 = NULLs permitted, */
                                                /* > 0 = no NULLs permitted  */
  deflength     number,              /* default value expression text length */
  default$      long,                       /* default value expression text */

  /*
   * If a table T(c1, addr, c2) contains an ADT column addr which is stored 
   * exploded, the table will be internally stored as 
   *              T(c1, addr, C0003$, C0004$, C0005$, c2)
   * Of these, only c1, addr and c2 are user visible columns. Thus, the 
   * user visible column numbers for (c1, addr, C0003$, C0004$, C0005$, c2) 
   * will be 1,2,0,0,0,3. And the corresponding internal column numbers will 
   * be 1,2,3,4,5,6. 
   *
   * Some dictionary tables like icol$, ccol$ need to contain intcol# so 
   * that we can have indexes and constraints on ADT attributes. Also, these
   * tables also need to contain col# to maintain backward compatibility.
   * Most of these tables will need to be accessed by col#, intcol# so 
   * indexes are created on them based on (obj#, col#) and (obj#, intcol#).
   * Indexes based on col# have to be non-unique if ADT attributes might
   * appear in the table. Indexes based on intcol# can be unique.
   */
  intcol#       number not null,                   /* internal column number */
  property      number not null,           /* column properties (bit flags): */
                /* 0x0001 =       1 = ADT attribute column                   */
                /* 0x0002 =       2 = OID column                             */
                /* 0x0004 =       4 = nested table column                    */
                /* 0x0008 =       8 = virtual column                         */
                /* 0x0010 =      16 = nested table's SETID$ column           */
                /* 0x0020 =      32 = hidden column                          */
                /* 0x0040 =      64 = primary-key based OID column           */
                /* 0x0080 =     128 = column is stored in a lob              */
                /* 0x0100 =     256 = system-generated column                */
                /* 0x0200 =     512 = rowinfo column of typed table/view     */
                /* 0x0400 =    1024 = nested table columns setid             */
                /* 0x0800 =    2048 = column not insertable                  */
                /* 0x1000 =    4096 = column not updatable                   */
                /* 0x2000 =    8192 = column not deletable                   */
                /* 0x4000 =   16384 = dropped column                         */
                /* 0x8000 =   32768 = unused column - data still in row      */
            /* 0x00010000 =   65536 = virtual column                         */
            /* 0x00020000 =  131072 = place DESCEND operator on top          */
            /* 0x00040000 =  262144 = virtual column is NLS dependent        */
            /* 0x00080000 =  524288 = ref column (present as oid col)        */
            /* 0x00100000 = 1048576 = hidden snapshot base table column      */
            /* 0x00200000 = 2097152 = attribute column of a user-defined ref */
            /* 0x00400000 = 4194304 = export hidden column,RLS on hidden col */
            /* 0x00800000 = 8388608 = string column measured in characters   */
           /* 0x01000000 = 16777216 = virtual column expression specified    */
           /* 0x02000000 = 33554432 = typeid column                          */
           /* 0x04000000 = 67108864 = Column is encrypted                    */
          /* 0x20000000 = 536870912 = Column is encrypted without salt       */

  /* The spares may be used as the column's NLS character set, 
   * the number of distinct column values, and the column's domain.
   */
  /* the universal character set id maintained by NLS group */
  charsetid     number,                              /* NLS character set id */
  /*
   * charsetform
   */
  charsetform   number,
  /* 1 = implicit: for CHAR, VARCHAR2, CLOB w/o a specified set */
  /* 2 = nchar: for NCHAR, NCHAR VARYING, NCLOB */
  /* 3 = explicit: for CHAR, etc. with "CHARACTER SET ..." clause */
  /* 4 = flexible: for PL/SQL "flexible" parameters */
  spare1        number,                      /* fractional seconds precision */
  spare2        number,                  /* interval leading field precision */
  spare3        number,            /* maximum number of characters in string */
  spare4        varchar2(1000),          /* NLS settings for this expression */
  spare5        varchar2(1000),
  spare6        date
)
cluster c_obj#(obj#)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table user$                                             /* user table */
( user#         number not null,                   /* user identifier number */
  name          varchar2("M_IDEN") not null,                 /* name of user */
  type#         number not null,                       /* 0 = role, 1 = user */
  password      varchar2("M_IDEN"),                    /* encrypted password */
  datats#       number not null, /* default tablespace for permanent objects */
  tempts#       number not null,  /* default tablespace for temporary tables */
  ctime         date not null,                 /* user account creation time */
  ptime         date,                                /* password change time */
  exptime       date,                     /* actual password expiration time */
  ltime         date,                         /* time when account is locked */
  resource$     number not null,                        /* resource profile# */
  audit$        varchar2("S_OPFL"),                    /* user audit options */
  defrole       number not null,                  /* default role indicator: */
               /* 0 = no roles, 1 = all roles granted, 2 = roles in defrole$ */
  defgrp#       number,                                /* default undo group */
  defgrp_seq#   number,               /* global sequence number for  the grp *
  spare         varchar2("M_IDEN"),                   /* reserved for future */
  astatus       number default 0 not null,          /* status of the account */
                /* 1 = Locked, 2 = Expired, 3 = Locked and Expired, 0 - open */
  lcount        number default 0 not null, /* count of failed login attempts */
  defschclass   varchar2("M_IDEN"),                /* initial consumer group */
  ext_username  varchar2("M_VCSZ"),                     /* external username */
  spare1        number, /* used for schema level supp. logging: see ktscts.h */
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
cluster c_user#(user#)
/
create table proxy_data$
( client#            NUMBER NOT NULL,                      /* client user ID */
  proxy#             NUMBER NOT NULL,                       /* proxy user ID */
  credential_type#   NUMBER NOT NULL,  /* Type of credential passed by proxy */
                   /*
                    * Values
                    * 0 = No credential
                    * 1 = Certificate
                    * 2 = Distinguished Name
                    * 4 = Oracle password
                    */
  credential_version# NUMBER NOT NULL,   /* Version number of the credential */
                   /*
                    * Values
                    * 0 = no version
                    * If certificate:
                    * 1 = X.509 V3
                    */
  credential_minor# NUMBER NOT NULL,      /* Minor credential version number */
                   /*
                    * Values
                    * 0 = no version
                    * If certificate:
                    * 1 = V3
                    */
  flags               NUMBER NOT NULL /* Mask flags of associated with entry */
             /* Flags values:
              * 1 = proxy can activate all client roles
              * 2 = proxy can activate no client roles
              * 4 = role can be activated by proxy,
              * 8 = role cannot be activated by proxy
              */
)
/
create unique index i_proxy_data$ on proxy_data$(client#, proxy#)
/
create table proxy_role_data$
( client#       NUMBER NOT NULL,                           /* client user ID */
  proxy#        NUMBER NOT NULL,                            /* proxy user ID */
  role#         NUMBER NOT NULL                                   /* role ID */
)
/
create index i_proxy_role_data$_1 on 
  proxy_role_data$(client#, proxy#)
/
create unique index i_proxy_role_data$_2 on 
  proxy_role_data$(client#, proxy#, role#)
/
create table con$                                        /* constraint table */
( owner#        number not null,                        /* owner user number */
  name          varchar2("M_IDEN") not null,              /* constraint name */
  con#          number not null,                        /* constraint number */
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
/
create cluster c_cobj# (obj# number)
  pctfree 0 pctused 50
  /* space for: update cdef$ set condition = 'col IS NOT NULL' at // */
  size 300
  storage (initial 50K)               /* avoid space management during IOR I */
/
create index i_cobj# on cluster c_cobj#
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table cdef$                            /* constraint definition table */
( con#          number not null,                        /* constraint number */
  obj#          number not null,         /* object number of base table/view */
  cols          number,                   /* number of columns in constraint */
  type#         number not null,                         /* constraint type: */
                            /* 1 = table check, 2 = primary key, 3 = unique, */
                             /* 4 = referential, 5 = view with CHECK OPTION, */
                                                 /* 6 = view READ ONLY check */
               /* 7 - table check constraint associated with column NOT NULL */
                                   /* 8 - hash expressions for hash clusters */
                                         /* 9 - Scoped REF column constraint */
                                    /* 10 - REF column WITH ROWID constraint */
                                  /* 11 - REF/ADT column with NOT NULL const */
                                 /* 12 - Log Groups for supplemental logging */
                                    /* 14 - Primary key supplemental logging */
                                     /* 15 - Unique key supplemental logging */
                                    /* 16 - Foreign key supplemental logging */
                                     /* 17 - All column supplemental logging */
  robj#         number,                 /* object number of referenced table */
  rcon#         number,           /* constraint number of referenced columns */
  rrules        varchar2(3),         /* future: use this columns for pendant */
  match#        number,                /* referential constraint match type: */
                                                 /* null = FULL, 1 = PARTIAL */
        /* this column can also store information for other constraint types */
  refact        number,                               /* referential action: */
              /* null = RESTRICT, 1 = CASCADE, 2 = SET NULL, 3 = SET DEFAULT */
  enabled        number,          /* is constraint enabled? NULL if disabled */
  condlength    number,                 /* table check condition text length */
  condition     long,                          /* table check condition text */
  intcols       number,          /* number of internal columns in constraint */
  mtime         date,      /* date this constraint was last enabled-disabled */
  defer         number,                     /* 0x01 constraint is deferrable */
                                              /* 0x02 constraint is deferred */
                                /* 0x04 constraint has been system validated */
                                 /* 0x08 constraint name is system generated */
                       /* 0x10 constraint is BAD, depends on current century */
                           /* 0x20, optimizer should RELY on this constraint */
                                             /* 0x40 Log Group ALWAYS option */
                                /* 0x80 (view related) constraint is invalid */
                                       /* 0x100 constraint depends on a view */

  spare1        number,                      /* sql version flag: see kpul.h */
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
cluster c_cobj#(obj#)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table ccol$                                /* constraint column table */
( con#          number not null,                        /* constraint number */
  obj#          number not null,                       /* base object number */
  col#          number not null,                            /* column number */
  pos#          number,                 /* column position number as created */
  intcol#       number not null,                   /* internal column number */
  spare1        number,                 /* Constarint specific column flags  */
                                          /* 0x1  NO LOG Supplemental column */
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
cluster c_cobj#(obj#)
/
create index i_tab1 on tab$(bobj#)
/
create unique index i_undo1 on undo$(us#)
/
create index i_undo2 on undo$(name)
/
create unique index i_obj1 on obj$(obj#)
/
create unique index i_obj2 on obj$(owner#, name, namespace,
remoteowner, linkname, subname)
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create index i_obj3 on obj$(oid$)
/
create unique index i_ind1 on ind$(obj#)
/
create index i_icol1 on icol$(obj#)
/
create unique index i_file1 on file$(file#)
/
create unique index i_file2 on file$(ts#, relfile#)
/
create unique index i_ts1 on ts$(name)
/
create unique index i_user1 on user$(name)
/
create unique index i_col1 on col$(obj#, name)
  storage (initial 30k next 100k maxextents unlimited pctincrease 0)
/
create index i_col2 on col$(obj#, col#)
  storage (initial 30k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_col3 on col$(obj#, intcol#)
  storage (initial 30k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_con1 on con$(owner#, name)
/
create unique index i_con2 on con$(con#)
/
create unique index i_cdef1 on cdef$(con#)
/
create index i_cdef2 on cdef$(obj#)
/
create index i_cdef3 on cdef$(robj#)
/
create index i_cdef4 on cdef$(enabled)
/
create index i_ccol1 on ccol$(con#, col#)
/
create unique index i_ccol2 on ccol$(con#, intcol#)
/
create table bootstrap$
( line#         number not null,                       /* statement order id */
  obj#          number not null,                            /* object number */
  sql_text      varchar2("M_VCSZ") not null)                    /* statement */
  storage (initial 50K)            /* to avoid space management during IOR I */
//                                            /* "//" required for bootstrap */
create table objauth$                           /* table authorization table */
( obj#          number not null,                            /* object number */
  grantor#      number not null,                      /* grantor user number */
  grantee#      number not null,                      /* grantee user number */
  privilege#    number not null,                   /* table privilege number */
  sequence#     number not null,                    /* unique grant sequence */
  parent        rowid,                                             /* parent */
  option$       number,                                 /* null = no options */
                                                      /* 0x01 = grant option */
                                                  /* 0x02 = hierarchy option */
  col#          number)     /* null = table level, column id if column grant */
/
create table ugroup$                         /* rollback segment group table */
( ugrp#         number not null,                        /* undo group number */
  name          varchar2("M_IDEN") not null,              /* undo group name */
  seq#          number,
  spare1        number,
  spare2        varchar2("M_IDEN"),
  spare3        number
)
/
create index i_ugroup1 on ugroup$(name)
/
create index i_ugroup2 on ugroup$(ugrp#)
/
create table tsq$                                  /* tablespace quota table */
( ts#           number not null,                        /* tablespace number */
  user#         number not null,                              /* user number */
  grantor#      number not null,                               /* grantor id */
  blocks        number not null,         /* number of blocks charged to user */
  maxblocks     number,     /* user's maximum number of blocks, NULL if none */
  priv1         number not null,            /* reserved for future privilege */
  priv2         number not null,            /* reserved for future privilege */
  priv3         number not null)            /* reserved for future privilege */
cluster c_user# (user#)
/
create table syn$                                           /* synonym table */
( obj#          number not null,                            /* object number */
  node          varchar2("M_XDBI"),                        /* node of object */
  owner         varchar2("M_IDEN"),                          /* object owner */
  name          varchar2("M_IDEN") not null)                  /* object name */
/
create table view$                                             /* view table */
( obj#          number not null,                            /* object number */
  audit$        varchar2("S_OPFL") not null,             /* auditing options */
  cols          number not null,                        /* number of columns */
  intcols       number not null,               /* number of internal columns */
  property      number not null,             /* view properties (bit flags): */
                /* 0x0001 =       1 = this is typed view                     */
                /* 0x0002 =       2 = view has ADT column(s)                 */
                /* 0x0004 =       4 = view has nested table column(s)        */
                /* 0x0008 =       8 = view has REF column(s)                 */
                /* 0x0010 =      16 = view has array column(s)               */
                /* 0x1000 =    4096 = view has primary key-based oid         */
                /* 0x4000 =   16384 = view is read-only                      */
               /* 0x10000 =   65536 = OID is sytem generated                 */
               /* 0x20000 =         = view is used by AQ                     */
            /* 0x08000000 =         = view is a sub view                     */
            /* 0x10000000 =         = view is packed object view             */
  flags         number not null,                  /* view flags (bit flags): */
                /* 0x0800 =    2048 = view/table has security policy         */
                /* 0x1000 =    4096 = view is insertable via trigger         */
                /* 0x2000 =    8192 = view is updatable via trigger          */
                /* 0x4000 =   16384 = view is deletable via trigger          */
             /* 0x0080000 =  524288 = view is referenced by MV (Summary)     */
             /* 0x0100000 = 1048576 = view is referenced by query rewrite MV */
             /* 0x0400000 = 4194304 = view has sub views defined under it    */
  textlength    number,                               /* length of view text */
  text          long)                                           /* view text */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create table typed_view$                   /* additional info for typed view */
( obj#            number not null,                          /* object number */
  typeowner       varchar2("M_IDEN"),                   /* owner of row type */
  typename        varchar2("M_IDEN"),                    /* name of row type */
  typetextlength  number,                         /* length of row type text */
  typetext        varchar2("M_VCSZ"),                           /* type text */
  oidtextlength   number,                              /* length of oid text */
  oidtext         varchar2("M_VCSZ"),                            /* oid text */
  transtextlength number,                 /* length of transformed view text */
  transtext       long,                             /* transformed view text */
  undertextlength number,       /* length of under clause text for sub-views */
  undertext       varchar2("M_VCSZ"))     /* under clause text for sub-views */
/
create table superobj$        /* stores info about table/view hierarchies */
( subobj#         number not null,            /* object number of sub object */
  superobj#       number not null)          /* object number of super object */
/
create unique index i_superobj1 on superobj$(subobj#)
/
create index i_superobj2 on superobj$(superobj#)
/
create table seq$
( obj#          number not null,                            /* object number */
  increment$    number not null,            /* the sequence number increment */
  minvalue      number,                         /* minimum value of sequence */
  maxvalue      number,                         /* maximum value of sequence */
  cycle#        number not null,                      /* 0 = FALSE, 1 = TRUE */
  order$        number not null,                      /* 0 = FALSE, 1 = TRUE */
  cache         number not null,                 /* how many to cache in sga */
  highwater     number not null,                     /* disk high water mark */
  audit$        varchar2("S_OPFL") not null,             /* auditing options */
  flags         number)                              /* 0x08 LOGICAL STANDBY */
/
rem
rem procedure$ contains information about packages and standalone 
rem    procedures, functions. There is one row for a top-level object.
rem procedureinfo$ holds information about procedures/functions defined
rem    standalone or in packages or types. There is one row per procedure
rem    or function. 
rem method$ holds information about each procedure/function (method) defined
rem    in a type. In particular, it holds information specific to methods 
rem    for example, is this a map/order method.
rem
create table procedure$                                   /* procedure table */
( obj#          number not null,                            /* object number */
  audit$        varchar2("S_OPFL") not null,             /* auditing options */
  storagesize   number,                         /* storage size of procedure */
  options       number                                    /* compile options */
)
/
create table procedureinfo$               /* function/procedure/method table */
( obj#          number not null,                            /* object number */
                     /* for types, packages - object number of specification */
  procedure#    number not null,               /* procedure or method number */
                     /* 0 = standalone proc/func, n = unique id of procedure */
  overload#      number not null,
                /* 0 - not overloaded, n - unique id of overloaded procedure */
  procedurename varchar2("M_IDEN"),                        /* procedure name */
  properties    number not null,                     /* procedure properties */
                /* 0x00001 =     1 = HIDDEN (internally generated) procedure */
                /* 0x00002 =     2 = C implementation (in spec)              */
                /* 0x00004 =     4 = Java implementation (in spec)           */
                /* 0x00008 =     8 = Aggregate function                      */
                /* 0x00010 =    16 = Pipelined function                      */
                /* 0x00020 =    32 = Parallel enabled                        */
                /* 0x00040 =    64 = Retrun Self as result (SQLJ)            */
                /* 0x00080 =   128 = Constructor function (SQLJ)             */
                /* 0x00100 =   256 = deterministic                           */
                /* 0x00200 =   512 = Pipelined func; interface impl          */
                /* 0x00400 =  1024 = Function with invokers rights           */
                /* 0x00800 =  2048 = Func with partitioned argument(s)       */
                /* 0x01000 =  4096 = Func with clustered argument(s)         */
                /* 0x02000 =  8192 = Func with ordered i/p argument(s)       */
                /* 0x04000 =  16384 = Partitioned arg: Hash partitioning     */
                /* 0x08000 = 32768 = Partitioned arg: Range partitioning     */
                /* 0x10000 = 65536 = Partitioned using any partitioning      */
  /* The following field is relevant only for aggregate and pipelined        */
  /*  functions that are implemented using an implementation type            */
  itypeobj#     number,                 /* implementation type object number */
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        number
)
/
create table argument$                     /* procedure argument description */
( obj#           number not null,                           /* object number */
  procedure$     varchar2("M_IDEN"), /* procedure name (if within a package) */
  overload#      number not null,
                /* 0 - not overloaded, n - unique id of overloaded procedure */
  procedure#     number,                       /* procedure or method number */
  position#      number not null,  /* argument position (0 for return value) */
  sequence#      number not null,
  level#         number not null,
  argument       varchar2("M_IDEN"),/* argument name (null for return value) */
  type#          number not null,                           /* argument type */
  charsetid      number,                                 /* character set id */
  charsetform    number,                               /* character set form */
  /* 1 = implicit: for CHAR, VARCHAR2, CLOB w/o a specified set */
  /* 2 = nchar: for NCHAR, NCHAR VARYING, NCLOB */
  /* 3 = explicit: for CHAR, etc. with "CHARACTER SET ..." clause */
  /* 4 = flexible: for PL/SQL "flexible" parameters */
  default#       number,   /* null - no default value, 1 - has default value */
  in_out         number,                   /* null - IN, 1 - OUT, 2 - IN/OUT */
  properties     number,                           /* argument's properties: */
  /* 0x0100 =     256 = IN parameter (pass by value, default) */
  /* 0x0200 =     512 = OUT parameter */
  /* 0x0400 =    1024 = pass by reference parameter */
  /* 0x0800 =    2048 = required parameter (no default) */
  /* 0x4000 =   16384 = is a PONTER parameter */
  /* 0x8000 =   32768 = is a REF parameter */
  length         number,                                      /* data length */
  precision#     number,                                /* numeric precision */
  scale          number,                                    /* numeric scale */
  radix          number,                                    /* numeric radix */
  deflength      number,             /* default value expression text length */
  default$       long,                      /* default value expression text */
  type_owner     varchar2("M_IDEN"),    /* owner name component of type name */
  type_name      varchar2("M_IDEN"),                            /* type name */
  type_subname   varchar2("M_IDEN"),       /* subname component of type name */
  type_linkname  varchar2("M_XDBI"),       /* db link component of type name */
  pls_type       varchar2("M_IDEN"))                     /* pl/sql type name */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create table source$                                         /* source table */
( obj#          number not null,                            /* object number */
  line          number not null,                              /* line number */
  source        varchar2("M_VCSZ"))                           /* source line */
  storage (initial 10k next 200k maxextents unlimited pctincrease 0)
/
create table idl_ub1$                            /* idl table for ub1 pieces */
( obj#          number not null,                            /* object number */
  part          number not null,
         /* part: 0 = diana, 1 = portable pcode, 2 = machine-dependent pcode */
  version       number,                                    /* version number */
  piece#        number not null,                             /* piece number */
  length        number not null,                             /* piece length */
  piece         long raw not null)                              /* ub1 piece */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create table idl_char$                          /* idl table for char pieces */
( obj#          number not null,                            /* object number */
  part          number not null,
         /* part: 0 = diana, 1 = portable pcode, 2 = machine-dependent pcode */
  version       number,                                    /* version number */
  piece#        number not null,                             /* piece number */
  length        number not null,                             /* piece length */
  piece         long not null)                                 /* char piece */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create table idl_ub2$                            /* idl table for ub2 pieces */
( obj#          number not null,                            /* object number */
  part          number not null,
         /* part: 0 = diana, 1 = portable pcode, 2 = machine-dependent pcode */
  version       number,                                    /* version number */
  piece#        number not null,                             /* piece number */
  length        number not null,                             /* piece length */
  piece         long ub2 not null)                              /* ub2 piece */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create table idl_sb4$                            /* idl table for sb4 pieces */
( obj#          number not null,                            /* object number */
  part          number not null,
         /* part: 0 = diana, 1 = portable pcode, 2 = machine-dependent pcode */
  version       number,                                    /* version number */
  piece#        number not null,                             /* piece number */
  length        number not null,                             /* piece length */
  piece         long sb4 not null)                              /* sb4 piece */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create table dir$                                  /* directory object table */
( obj#          number not null,                            /* object number */
  audit$        varchar2("S_OPFL") not null,             /* auditing options */
  os_path       varchar2("M_VCSZ"))                        /* OS path string */
/
rem
rem javaobj$ contains information about java objects (java class, java source 
rem java resource, java data and etc). 
rem
create table javaobj$                                   /* java object table */
( obj#          number not null,                            /* object number */
  audit$        varchar2("S_OPFL") not null              /* auditing options */
)
/
create table error$                                           /* error table */
( obj#          number not null,                            /* object number */
  sequence#     number default 0 not null,
                                  /* sequence number (for ordering purposes) */
  line          number not null,                       /* source line number */
  position#     number not null,                  /* position in source line */
  textlength    number not null,                 /* length of the error text */
  text          varchar2("M_VCSZ") not null,                   /* error text */
  property      number,                                  /* error or warning */
  error#         number)                                     /* error number */
/
create table settings$ (
  obj#          number not null,                            /* object number */
  param         varchar2("M_IDEN") not null,               /* parameter name */
  value         varchar2("M_VCSZ"))                       /* parameter value */
/
create table trigger$                                       /* trigger table */
( obj#          number not null,                            /* object number */
  type#         number not null,                            /* trigger type: */
        /*  0 = BEFORE TABLE, 1 = BEFORE ROW, 2 = AFTER TABLE, 3 = AFTER ROW */
                                                   /* 4 = INSTEAD OF TRIGGER */
  update$       number not null,                           /* fire on update */
  insert$       number not null,                           /* fire on insert */
  delete$       number not null,                           /* fire on delete */
  baseobject    number not null,                        /* triggering object */
  refoldname    varchar2("M_IDEN"),                  /* old referencing name */
  refnewname    varchar2("M_IDEN"),                  /* new referencing name */
  definition    varchar2("M_VCSZ"),                    /* trigger definition */
  whenclause    varchar2("M_VCSZ"),                   /* text of when clause */
  action#       long,                                      /* action to fire */
  actionsize    number,                               /* size of action text */
  enabled       number,                         /* 0 = DISABLED, 1 = ENABLED */
  property      number not null,          /* trigger properties (bit flags): */
                                                /* 0x01 = baseobject is view */
                                                /* 0x02 = Call style trigger */
                                                /* 0x04 = Java Trigger       */
                                            /* 0x08 = baseobject is database */
                                              /* 0x10 = baseobject is schema */
                                              /* 0x20 = Nested table trigger */
                                                 /* 0x40 = baseobject is IOT */
                              /* 0x80 = fire-once-only (fire one place only) */
  sys_evts      number,                                     /* system events */
  nttrigcol     number,               /* intcol# on which trigger is defined */
  nttrigatt     number,                    /* attribute number within column */
  refprtname    varchar2("M_IDEN"),              /* PARENT referencing name */ 
  actionlineno  number                          /* action line number offset */
)
/
create table triggercol$
( obj#          number not null,                            /* object number */
  col#          number not null,                            /* column number */
  type#         number not null,                /* type of column reference: */
     /* 6 = OLD IN-ARG, 5 = NEW IN-ARG, 9 = NEW OUT-VAR, 13 = NEW IN/OUT-VAR */
                                                  /* 0x14 = 20 PARENT IN-ARG */
  position#     number,                               /* position in trigger */
  intcol#       number not null)                   /* internal column number */
/

REM  The following four tables for 8.1 SDK2 specific.
REM  They should be removed before 8.1 beta, assuming we use ILMS
REM services for JAVA trigger invocation. 
create table triggerjavaf$
( obj#          number not null,                            /* object number */
  flags         long raw,                                  /* ub1 flag array */
  flaglength    number)                          /* length of ub1 flag array */
/
create table triggerjavas$
( obj#          number not null,                            /* object number */
  signature     long not null,                           /* method signature */
  siglength     number not null)               /* length of method signature */
/
create table triggerjavac$
( obj#          number not null,                            /* object number */
  ownername     varchar2("M_IDEN") not null,             /* class owner name */
  ownerlength   number not null,               /* length of class owner name */
  classname     long not null,                          /* method class name */
  classlength   number not null)              /* length of method class name */
/
create table triggerjavam$
( obj#          number not null,                            /* object number */
  methodname    long not null,                                /* method name */
  methodlength  number not null,                 /* length of ub1 flag array */
  cookiesize    number not null)                              /* cookie size */
/
create table sysauth$                          /* system authorization table */
( grantee#      number not null,          /* grantee number (user# or role#) */
  privilege#    number not null,                      /* role or privilege # */
  sequence#     number not null,                    /* unique grant sequence */
  option$       number)                     /* null = none, 1 = admin option */
/
create table objpriv$                       /* privileges granted to objects */
( obj#          number not null,                            /* object number */
  privilege#    number not null)                         /* privilege number */
/
create table defrole$                                  /* default role table */
( user#         number not null,                                  /* user id */
  role#         number not null)                          /* default role id */
/
create table profile$                                    /* resource profile */
( profile#      number not null,   /* user$.resource$ and profname$.profile# */
  resource#     number not null,                          /* resource number */
  type#         number not null,  /* 0 = kernel resource, else tool resource */
  limit#        number not null)                           /* resource limit */
/
create table profname$                /* mapping of profile# to profile name */
( profile#      number not null,
  name          varchar2("M_IDEN") not null)
/
create table dependency$                                 /* dependency table */
( d_obj#        number not null,                  /* dependent object number */
  d_timestamp   date not null,   /* dependent object specification timestamp */
  order#        number not null,                             /* order number */
  p_obj#        number not null,                     /* parent object number */
  p_timestamp   date not null,      /* parent object specification timestamp */
  d_owner#      number,                           /*  dependent owner number */
  property      number not null,                   /* 0x01 = HARD dependency */
                                                   /* 0x02 = REF  dependency */
                                          /* 0x04 = FINER GRAINED dependency */
  d_attrs       raw("M_CSIZ"), /* Finer grain attr. numbers if finer grained */
  d_reason      raw("M_CSIZ"))  /* Reason mask of attrs causing invalidation */
storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create table access$                                         /* access table */
( d_obj#        number not null,                  /* dependent object number */
  order#        number not null,                  /* dependency order number */
  columns       raw("M_BVCO"),                /* list of cols for this entry */
  types         number not null)                             /* access types */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/

create table link$                             /* remote database link table */
( owner#        number not null,                        /* owner user number */
  name          varchar2("M_XDBI") not null,                    /* link name */
  ctime         date not null,                              /* creation time */
  host          varchar2("M_CNCT"),    /* optional driver string for connect */
  userid        varchar2("M_IDEN"),             /* optional user to logon as */
  password      varchar2("M_IDEN"),                    /* password for logon */
  flag          number,                        /* to identify type of dblink */
  authusr      varchar2("M_IDEN"),             /* optional user to logon as */
  authpwd      varchar2("M_IDEN"),                    /* password for logon */
  passwordx     raw(128),                                       /* password  */
  authpwdx      raw(128))                                   /*auth  pasword  */
/
create table trusted_list$            /* trusted list for privileged dblinks */
( dbname        varchar2("M_XDBI") not null,                /* database name */
  username      varchar2("M_VCSZ") not null)                    /* user name */
/
insert into trusted_list$ values ('+*','*')     /* default value - allow all */
/
create table props$
( name          varchar2("M_IDEN") not null,                /* property name */
  value$        varchar2("M_VCSZ"),                        /* property value */
  comment$      varchar2("M_VCSZ"))               /* description of property */
/
create table com$                                           /* comment table */
( obj#          number not null,                            /* object number */
  col#          number,                /* column number (NULL if for object) */
  comment$      varchar2("M_VCSZ"))            /* user-specified description */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create table resource_cost$
( resource#     number not null,                         /* 2, 4, 6, 7, 8, 9 */
  cost          number not null)                                     /* >= 0 */
/
insert into resource_cost$ values (0, 0)                         /* not used */
/
insert into resource_cost$ values (1, 0)                /* sessions_per_user */
/
insert into resource_cost$ values (2, 0)                  /* cpu_per_session */
/
insert into resource_cost$ values (3, 0)                         /* not used */
/
insert into resource_cost$ values (4, 0)        /* logical_reads_per_session */
/
insert into resource_cost$ values (5, 0)                         /* not used */
/
insert into resource_cost$ values (6, 0)                         /* not used */
/
insert into resource_cost$ values (7, 0)                     /* connect_time */
/
insert into resource_cost$ values (8, 0)                      /* private_sga */
/
insert into resource_cost$ values (9, 0)                         /* not used */
/
insert into props$ 
values('DICT.BASE', '2', 'dictionary base tables version #')
/
insert into props$
values('DEFAULT_TEMP_TABLESPACE', 'SYSTEM',
       'Name of default temporary tablespace')
/
insert into props$
values('DEFAULT_PERMANENT_TABLESPACE', 'SYSTEM',
       'Name of default permanent tablespace')
/
create unique index i_view1 on view$(obj#)
/
create unique index i_typed_view1 on typed_view$(obj#)
/
create unique index i_syn1 on syn$(obj#)
/
create unique index i_seq1 on seq$(obj#)
/
create unique index i_objauth1 on 
  objauth$(obj#, grantor#, grantee#, privilege#, col#)
/
create index i_objauth2 on objauth$(grantee#, obj#, col#)
/
create unique index i_sysauth1 on sysauth$(grantee#, privilege#)
/
create unique index i_defrole1 on defrole$(user#, role#)
/
create index i_link1 on link$(owner#, name)
/
create unique index i_com1 on com$(obj#, col#)
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_procedure1 on procedure$(obj#)
/
create unique index i_procedureinfo1 on 
  procedureinfo$(obj#, procedurename, overload#)
/
create unique index i_argument1 on 
  argument$(obj#, procedure$, overload#, sequence#)
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create index i_argument2 on 
  argument$(obj#, procedure#, sequence#)
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_source1 on source$(obj#, line)
  storage (initial 10k next 200k maxextents unlimited pctincrease 0)
/
create unique index i_idl_ub11 on
  idl_ub1$(obj#, part, version, piece#)
/
create unique index i_idl_char1 on
  idl_char$(obj#, part, version, piece#)
/
create unique index i_idl_ub21 on
  idl_ub2$(obj#, part, version, piece#)
/
create unique index i_idl_sb41 on
  idl_sb4$(obj#, part, version, piece#)
/
create unique index i_dir1 on dir$(obj#)
/
create unique index i_javaobj1 on javaobj$(obj#)
/
create index i_error1 on error$(obj#, sequence#)
/
create index i_settings1 on settings$(obj#)
/
create unique index i_dependency1 on
  dependency$(d_obj#, d_timestamp, order#) 
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create index i_dependency2 on
  dependency$(p_obj#, p_timestamp)
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create index i_access1 on
  access$(d_obj#, order#) 
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create index i_trigger1 on trigger$(baseobject)
/                                             
create unique index i_trigger2 on trigger$(obj#)
/
create index i_triggercol1 on triggercol$(obj#, col#, type#, position#)
/
create index i_triggercol2 on triggercol$(obj#, intcol#, type#, position#)
/
create unique index i_triggerjavaf on triggerjavaf$(obj#)
/
create unique index i_triggerjavas on triggerjavas$(obj#)
/
create unique index i_triggerjavac on triggerjavac$(obj#)
/
create unique index i_triggerjavam on triggerjavam$(obj#)
/
create unique index i_profname on profname$(name)
/
create index i_profile on profile$(profile#)
/
create sequence ugroup_sequence   /* sequence for undo group    cache (lab$) */
  increment by 1
  start with 1
  minvalue 0
  nomaxvalue
  cache 10
  order
  nocycle
/
create sequence object_grant                 /* object grant sequence number */
  start with 1
  increment by 1
  minvalue 1
  nomaxvalue
  cache 20
  order
  nocycle
/
create sequence system_grant                 /* system grant sequence number */
  start with 1
  increment by 1
  minvalue 1
  nomaxvalue
  cache 20
  order
  nocycle
/
create sequence profnum$                   /* profile number sequence number */
  increment by 1
  start with 0                              /* profile# for DEFAULT always 0 */
  minvalue 0
  nocache                                           /* don't want to reuse 0 */
/
create profile "DEFAULT" limit            /* default value, always present */
  composite_limit               unlimited                   /* service units */
  sessions_per_user             unlimited              /* logins per user id */
  cpu_per_session               unlimited            /* cpu usage in minutes */
  cpu_per_call                  unlimited        /* max cpu minutes per call */
  logical_reads_per_session     unlimited
  logical_reads_per_call        unlimited
  idle_time                     unlimited
  connect_time                  unlimited
  private_sga                   unlimited      /* valid only with TP-monitor */
  failed_login_attempts         10
  password_life_time            unlimited
  password_reuse_time           unlimited
  password_reuse_max            unlimited
  password_verify_function      null
  password_lock_time            unlimited
  password_grace_time           unlimited
/
create table incexp                      /* incremental export support table */
( owner#        number not null,                                 /* owner id */
  name          varchar2("M_IDEN") not null,                  /* object name */
  type#         number not null,                              /* object type */
  ctime         date,                      /* time of last cumulative export */
  itime         date not null,            /* time of last incremental export */
  expid         number(3) not null)                             /* export id */
/
create unique index i_incexp on incexp(owner#, name, type#)
/
create user sys identified by "D_SYSPW" 
/
create role public
/
create role connect
/
grant create session to connect
/
create role resource
/
grant create table,create cluster,create sequence,create trigger,
 create procedure, create type, create indextype, create operator
 to resource
/
create role dba
/
grant all privileges, select any dictionary, analyze any dictionary
  to dba with admin option
/
create user system identified by "D_SYSTPW" 
/
grant dba to system with admin option
/
grant all on incexp to system
/
create table incvid                    /* incremental valid identifier table */
( expid         number(3) not null)               /* id of last valid export */
/
insert into incvid(expid) values (0)
/
grant all on incvid to system
/
create table incfil                         /* incremental file export table */
( expid         number(3) not null,                             /* export id */
  exptype       varchar2(1) not null,                        /* export type: */
                            /* X - complete, I - incremental, C - cumulative */
  expfile       varchar2(100) not null,                  /* export file name */
  expdate       date not null,                                /* export date */
  expuser       varchar2("M_IDEN") not null)            /* user doing export */
/
grant all on incfil to system
/
create table "_default_auditing_options_"   /* default auditing option table */
( a             varchar2(1))                              /* auditing option */
/
create sequence audses$                               /* auditing session id */
  start with 1
  increment by 1
  minvalue 1
  maxvalue 2E9                                     /* maxvalue fits in a ub4 */
  cycle
  cache 20
  noorder
/
create table audit$                                 /* auditing option table */
( user#         number not null,                   /* user identifier number */
  proxy#        number, /* UID of the proxy user.
                        ** Special values:
                        ** NULL = no proxy authentication
                        ** 0 = all proxies may authenticate the user
                        */
  option#       number not null,                   /* auditing option number */
  success       number,                                 /* audit on success? */
  failure       number)                                 /* audit on failure? */
               /* null = no audit, 1 = audit by session, 2 = audit by access */
/
create unique index i_audit on audit$(user#, proxy#, option#)
                       /* this index is more for uniqueness than performance */
/
create table pending_trans$             /* pending or "indoubt" transactions */
( local_tran_id   varchar2("M_LTID") not null, /* print form of kxid (local) */
  global_tran_fmt integer not null,               /* global tran format code */
  global_oracle_id  varchar2("M_GTID"),                      /* Oracle k2gti */
  global_foreign_id raw("M_GTID"),                       /* non-Oracle k2gti */
  tran_comment    varchar2("M_XCMT"),             /* commit/rollback comment */
  state           varchar2(16) not null,       /* see k2.h: k2sta (tx state) */
  status          varchar2(1) not null,                   /* Pending, Damage */
  heuristic_dflt  varchar2(1),                  /* advice: Commit/Rollback/? */
  session_vector  raw(4) not null,              /* bit map of pending sess's */
  reco_vector     raw(4) not null,             /* map of sess's rdy for reco */
  type#           number,  /* loosely-coupled or tightly-coupled transaction */
  fail_time       date not null,                            /* time inserted */
  heuristic_time  date,                        /* time of heuristic decision */
  reco_time       date not null,               /* last time tried (exp.b.o.) */
  top_db_user     varchar2("M_IDEN"),        /* top level DB session created */
  top_os_user     varchar2("M_UNML"),              /* top level OS user name */
  top_os_host     varchar2("M_HOST"),         /* top level user OS host name */
  top_os_terminal varchar2("M_TERM"),            /* top level OS terminal id */
  global_commit#  varchar2(16),               /* global system commit number */
  spare1          number,
  spare2          varchar2("M_IDEN"),
  spare3          number,
  spare4          varchar2("M_IDEN")
)
/
create unique index i_pending_trans1 on pending_trans$(local_tran_id)
  /* this index is not for performance, but rather to ensure uniqueness */
/
create table pending_sessions$                    /* child of pending_trans$ */
( local_tran_id   varchar2("M_LTID") not null,              /* 1:n w/ parent */
  session_id      smallint not null,
  branch_id       raw("M_GBID") not null,                        /* of local */
  interface       varchar2(1) not null,          /* C=commit/confirm, P=prep */
  type#           number,       /* loosely-coupled or tightly-coupled branch */
  parent_dbid     varchar2("M_IDBI"),              /* null string->top level */
  parent_db       varchar2("M_XDBI"),      /* global name of parent database */
  db_userid       integer not null)                 /* creator of DB session */
/
create table pending_sub_sessions$             /* child of pending_sessions$ */
( local_tran_id   varchar2("M_LTID") not null,  /* w/session_id,1:n w/parent */
  session_id      smallint not null,                             /* of local */
  sub_session_id  smallint not null, /* session,sub_session is remote branch */
  interface       varchar2(1) not null,          /* C=hold commit, N=no hold */
  dbid            varchar2("M_IDBI") not null,                  /* of remote */
  link_owner      integer not null,                       /* owner of dblink */
  dblink          varchar2("M_XDBI") not null,
  branch_id       raw("M_GBID"),                 /* branch id of sub session */
  spare           raw("M_GBID"))               /* spare field for future use */
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table lob$                                   /* LOB information table */
( obj#          number not null,          /* object number of the base table */
  col#          number not null,                            /* column number */
  intcol#       number not null,                   /* internal column number */
  lobj#         number not null,                /* object number for the LOB */
  part#         number not null,                  /* this column is not used */
  ind#          number not null,                  /* LOB index object number */
  ts#           number not null,         /* segment header tablespace number */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  chunk         number not null,           /* oracle blocks in one lob chunk */
  pctversion$   number not null,                             /* version pool */
  flags         number not null,                           /* 0x0000 = CACHE */
                                                 /* 0x0001 = NOCACHE LOGGING */
                                               /* 0x0002 = NOCACHE NOLOGGING */
                                             /* 0x0008 = CACHE READS LOGGING */
                                           /* 0x0010 = CACHE READS NOLOGGING */
                                          /* 0x0020 = retention is specified */
                                       /* 0x0040 = Index key holds timestamp */
                                      /* 0x0080 = need to drop the freelists */
  property      number not null,           /* 0x00 = user defined lob column */
                                    /* 0x01 = kernel column(s) stored as lob */
                                     /* 0x02 = user lob column with row data */
                                            /* 0x04 = partitioned LOB column */
                                   /* 0x0008 = LOB In Global Temporary Table */
                                          /* 0x0010 = Session-specific table */
                                      /* 0x0020 = lob with compressed header */ 
                                        /* 0x0040 = lob using shared segment */
                                  /* 0x0080 = first lob using shared segment */
                                   /* 0x0100 = klob and inline image coexist */
                                /* 0x0200 = LOB data in little endian format */
  retention     number not null,         /* retention value = UNDO_RETENTION */
  freepools     number not null,      /* number of freepools for LOB segment */
  spare1        number,
  spare2        number,
  spare3        varchar2(255)
)
cluster c_obj#(obj#)
/
create index i_lob1 on lob$(obj#, intcol#)
/
create unique index i_lob2 on lob$(lobj#)
/
rem
rem  sumpartlog$ table
rem  This table has one row per table partition being dropped or its dataobj# 
rem  changed
rem  obj# is a key; and so is (bo#, part#)
rem  There is a non-unique index on bo#, obj#
rem
create table sumpartlog$ (
  obj#        number not null,                 /* object number of partition */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#    number,                            /* data layer object number */
  bo#         number not null,                /* object number of base table */
  newobj#     number,               /* new object number of partition if any */
  newdataobj#    number,              /* new data layer object number if any */
  pobj#       number,               /* partition object number; populated when 
                                           TRUNCATE/COALESCE of subpartition */
  hiboundlen  number not null,      /* length of high bound value expression */
  loboundlen  number not null,       /* length of low bound value expression */
  boundvals   long,               /* concatenated text of low-and high-bound */
                                                         /* value expression */
  parttype    number,                                      /* partition type */
                                               /* 1=RANGE,2=COMPOSITE,3=LIST */
  pmoptype    number,                                  /* recorded PMOP type */
  scn         number,                             /* summary sequence number */
  timestamp   date not null,                 /* Time when the PMOP occurred. */
  flags       number,                        /* 0x01 It is a table operation */
                               /* 0x02 logged because DL/DML happened before */
  /* These spare columns are for future needs, e.g. values for the 
   * PARALLEL(degree, instances) parameters.  */
  spare1      number,           
  spare2      number,
  spare3      number)
/
create index i_sumpartlog$ on sumpartlog$(bo#, obj#)
/
create index i_sumpartlog$_bopart$ on sumpartlog$(bo#, dataobj#)
/
create table sumdelta$           /* sumdelta table */
( tableobj#     number not null, /* detail table obj# loaded */
  partitionobj# number not null, /* partition obj# that was loaded */
  dmloperation  char(1),         /* I=insert, D=delete */
  scn           number not null, /* SCN when the bulk DML occurred. */
  timestamp     date not null,   /* Time when the bulk DML occurred. */
  lowrowid      rowid not null,  /* low rowid modified in this partition. */
  highrowid     rowid not null,  /* high rowid modified in this partition. */
  sequence      number,          /* sequence # */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create unique index i_sumdelta$ on 
  sumdelta$(tableobj#, partitionobj#, timestamp, lowrowid, highrowid) 
/ 
CREATE TABLE snap_logdep$ (                           /* slog$ for sumdelta$ */
  tableobj#  number,                             /* obj# of the master table */
  snapid     integer,           /* internal id of the snapshot using the log */
  snaptime   date)                  /* time of last refresh for the snapshot */
/ 
create unique index i_snap_logdep1 on snap_logdep$(tableobj#, snapid)
/
CREATE TABLE snap_loadertime$ (                       /* mlog$ for sumdelta$ */
  tableobj#  number,                             /* obj# of the master table */
  oldest     date,                /* oldest information for the master table */
  youngest   date,                 /* most recent refresh timestamp assigned */
  flag       number)                            /* (reserved for future use) */
/
create unique index i_snap_loadertime1 on snap_loadertime$(tableobj#)
/
create cluster c_mlog# (master varchar2("M_IDEN"),
                        mowner varchar2("M_IDEN"))
/
create index i_mlog# on cluster c_mlog#
/
create table mlog$          /* list of local master tables used by snapshots */
( mowner          varchar2("M_IDEN") not null,            /* owner of master */
  master          varchar2("M_IDEN") not null,             /* name of master */
  oldest          date,       /* maximum age of rowid information in the log */
  oldest_pk       date,          /* maximum age of PK information in the log */
  oldest_seq      date,    /* maximum age of sequence information in the log */
  oscn            number,                                   /* scn of oldest */
  youngest        date,                     /* most recent snaptime assigned */
  yscn            number,                   /* set-up scn;  identifies group */
                                          /* of rows set up at time youngest */
  log             varchar2("M_IDEN") not null,                /* name of log */
  trig            varchar2("M_IDEN"),           /* trigger on master for log */
  flag            number,       /* 0x0001, log contains rowid values         */
                                /* 0x0002, log contains primary key values   */
                                /* 0x0004, log contains filter column values */
                                /* 0x0008, log is imported                   */
                                /* 0x0010, log is created with temp table    */
  mtime           date not null,                    /* DDL modification time */
  temp_log        varchar2("M_IDEN"),/* temp table as updatable snapshot log */
  oldest_oid      date,         /* maximum age of OID information in the log */
  oldest_new      date )             /* maximum age of new values in the log */
cluster c_mlog# (master, mowner)
/
create table slog$                     /* list of snapshots on local masters */
( mowner          varchar2("M_IDEN") not null,            /* owner of master */
  master          varchar2("M_IDEN") not null,             /* name of master */
  snapshot        date,                 /* identifies V7 snapshots: obsolete */
  snapid          integer,                        /* identifies V8 snapshots */
  sscn            number,                                 /* scn of snapshot */
  snaptime        date               not null,        /* when last refreshed */
  tscn            number,                                 /* scn of snaptime */
  user#           number)                  /* userid for security validation */
cluster c_mlog# (master, mowner)
/
create index i_slog1 on slog$(snaptime)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table coltype$                        /* additional column info table */
( obj#          number not null,             /* object number of base object */
  col#          number not null,                            /* column number */
  intcol#       number not null,                   /* internal column number */
  toid          raw(16) not null,                   /* column's ADT type OID */
  version#      number not null,             /* internal type version number */
  packed        number not null,                 /* 0 = unpacked, 1 = packed */
  intcols       number,                        /* number of internal columns */
                                          /* storing the exploded ADT column */
  intcol#s      raw("M_CSIZ"),        /* list of intcol#s of columns storing */
                          /* the unpacked ADT column; stored in packed form; */
                                          /* each intcol# is stored as a ub2 */
  flags         number,
                     /* flags to indicate whether column type is ADT, Array, */
                                                      /* REF or Nested table */
                           /* 0x02 - adt column                              */
                           /* 0x04 - nested table column                     */
                           /* 0x08 - varray column                           */
                           /* 0x10 - ref column                              */
                           /* 0x20 - retrieve collection out-of-line         */
                           /* 0x20 - don't strip the null image              */
                           /* 0x40 - don't chop null image                   */
                           /* 0x40 - collection storage specified            */
                           /* 0x80 - column stores an old (8.0) format image */
                          /* 0x100 - data for this column not yet upgraded   */
                          /* 0x200 - ADT column is substitutable             */
                          /* 0x400 - NOT SUBSTITUTABLE specified explicitly  */
                          /* 0x800 - SUBSTITUTABLE specified explicitly      */
                         /* 0x1000 - implicitly not substitutable            */
                         /* 0x2000 - The typeid column stores the toid       */
                         /* 0x4000 - The column is an opaque type column     */ 
                         /* 0x8000 - nested table name is system generated   */
  typidcol#     number,           /* intcol# of the type discriminant column */
  synobj#       number)              /* obj# of type synonym of the col type */
cluster c_obj#(obj#)
/
create index i_coltype1 on coltype$(obj#, col#)
/
create unique index i_coltype2 on coltype$(obj#, intcol#)
/
create table subcoltype$
( obj#          number not null,             /* object number of base object */
  intcol#       number not null,                   /* internal column number */
  toid          raw(16) not null,                   /* column's ADT type OID */
  version#      number not null,             /* internal type version number */
        
  intcols       number,                        /* number of internal columns */
                                          /* storing the exploded ADT column */
  intcol#s      raw("M_CSIZ"),        /* list of intcol#s of columns storing */
                          /* the unpacked ADT column; stored in packed form; */
                                          /* each intcol# is stored as a ub2 */
  flags         number,
                          /* 0x01 - This type was stated in the IS OF clause */
                          /* 0x02 - This type has ONLY in the IS OF clause   */
  synobj#       number)  /* obj# of synonym specified for substitutable type */
cluster c_obj#(obj#)
/
create index i_subcoltype1 on subcoltype$(obj#, intcol#)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table attrcol$                          /* ADT attribute column table */
( obj#          number not null,             /* object number of base object */
  intcol#       number not null,                   /* internal column number */
  name          varchar2("M_VCSZ") not null)         /* fully-qualified name */
cluster c_obj#(obj#)
/
create unique index i_attrcol1 on attrcol$(obj#, intcol#)
/
create table viewtrcol$                      /* triggering view column table */
( obj#          number not null,             /* object number of base object */
  intcol#       number not null,                   /* internal column number */
  attribute#    number not null,          /* attribute# inside col for views */
  name          varchar2("M_VCSZ") not null)         /* fully-qualified name */
cluster c_obj#(obj#)
/
create unique index i_viewtrcol1 on viewtrcol$(obj#, intcol#,attribute#)
/
create table id_gens$                                 /* ID generators table */
( total         number not null)            /* total number of ID generators */
/
create table oid$                    /* OID mapping table for schema objects */
(
  user#         number not null,   /* user this mapping is for (user$.user#) */
  oid$          raw(16) not null,        /* OID for typed table/view or type */
  obj#          number not null)         /* target object number (obj$.obj#) */
                                                       /* key: (user#, oid$) */
/
create unique index i_oid1 on oid$(user#, oid$)
/
create table type_misc$              /* type miscellaneous information table */
( obj#          number not null,                       /* type object number */
  audit$        varchar2("S_OPFL") not null,             /* auditing options */
  properties    number not null)                               /* properties */
                        /* 0x01 = (flag PRP) potential REF-dependency parent */
                        /* 0x02 = invoker's rights                           */
                        /* 0x04 = Repeeatable                                */
                        /* 0x08 = TO8 Trusted                                */
                        /* 0x10 = SQLJ type                                  */
                        /* 0x20 = SQLJ type with helper class                */
                        /* 0x40 = Natively compiled                          */
                        /* 0x80 = Shrink-wrapped type                        */
                        /* 0x100 = Compiled with debug info                  */
cluster c_obj#(obj#)
/
create cluster c_toid_version#
( toid          raw(16),                                             /* TOID */
  version#      number)                           /* internal version number */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create index i_toid_version# on cluster c_toid_version#
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table type$                                             /* type table */
( toid          raw(16) not null,                                    /* TOID */
  version#      number not null,                  /* internal version number */
  version       varchar2("M_IDEN") not null,   /* user-supplied version name */
  tvoid         raw(16) not null,                      /* type version's OID */
  typecode      number not null,                                 /* typecode */
  properties    number not null,                       /* type's properties: */
  /* 0x00000001 =       1 = contains at least one (embedded) ADT attribute */
  /* 0x00000002 =       2 = contains at least one REF attribute */
  /* 0x00000004 =       4 = contains at least one "complex" attribute:
                        multiset, table, array, LOB, file, etc. */
  /* 0x00000008 =       8 = is NOT FINAL type */
  /* 0x00000010 =      16 = is a predefined system/builtin type(unalterable) */
  /* 0x00000080 =     128 = contains at least one multiset attribute */
  /* 0x00000100 =     256 = is incomplete */
  /* 0x00000200 =     512 = contains at least one LOB attribute */
  /* 0x00000400 =    1024 = contains at least one file attribute */
  /* 0x00000800 =    2048 = is a system-generated type */
  /* 0x00001000 =    4096 = contains opaque types */
  /* 0x00002000 =    8192 = is a SUBTYPE */
  /* 0x00004000 =   16384 = is invoker rights type */
  /* 0x00008000 =   32768 = contains varray attribute */
  /* 0x00010000 =   65536 = is not instantiable */
  /* 0x00020000 =  131072 = is java type */
  /* 0x00040000 =  262144 = old type version */
  /* 0x00080000 =  524288 = contain TSLTZ attr/element */
  /* 0x00100000 = 1048576 = has embedded non final type */
  /* 0x00200000 = 2097152 = has embedded subtype */
  /* 0x00400000 = 4194304 = has user-defined constructor */
  /* 0x00800000 = 8388608 = type is cursor duration */

  attributes    number,                              /* number of attributes */
  methods       number,                                 /* number of methods */
  hiddenMethods number,                                 /* number of methods */
  supertypes    number,                                          /* reserved */
  subtypes      number,                                          /* reserved */
  externtype    number,                                     /* external type */
                                                    /* 1 = SQLData SQLJ type */
                                                /* 2 = CustomDatum SQLJ type */
                                               /* 3 = serializable SQLJ type */
                                      /* 4 = internal serializable SQLJ type */
                                                    /* 5 = ORAData SQLJ type */
  externname      varchar2("M_VCSZ"),    /* java class implementing the type */
  helperclassname varchar2("M_VCSZ"),       /* Generated helper class (SQLJ) */
  local_attrs   number,                        /* Number of local attributes */
  local_methods number,                           /* Number of local methods */
  typeid        raw(16), /* short typeid value (for non final and sub types) */
  roottoid      raw(16),          /* TOID of root type (null if not subtype) */
  spare1        number,                                          /* reserved */
  spare2        number,                                          /* reserved */
  spare3        number,                                          /* reserved */
  supertoid     raw(16),                                    /* supertype OID */
  hashcode      raw("KOTHCL"))                                  /* hashcode */
cluster c_toid_version#(toid, version#)
                           /* keys: (toid, version# or version) or (tdo_oid) */
/
create unique index i_type1 on type$(toid, version)
/
create unique index i_type2 on type$(tvoid)
/
create index i_type3 on type$(roottoid)
/
create index i_type4 on type$(supertoid)
/
create index i_type5 on type$(hashcode)
/
create table typehierarchy$
( toid         raw(16) not null,                    /* TOID of the root type */
  next_typeid  raw(16) not null,                    /* next available typeid */
  spare1       number,                                           /* reserved */
  spare2       number)                                           /* reserved */
/
create unique index i_typehierarchy1 on typehierarchy$(toid)
/
create table collection$                            /* collection type table */
( toid          raw(16) not null,                                    /* TOID */
  version#      number not null,             /* internal type version number */
  coll_toid     raw(16) not null,   /* collection TOID (TABLE, VARRAY, etc.) */
  coll_version# number not null,/* collection type's internal version number */
  elem_toid     raw(16) not null,                          /* element's TOID */
  elem_version# number not null, /* element's type's internal version number */
  synobj#       number,                              /* obj# of type synonym */
  properties    number not null,                    /* element's properties: */
  /* 0x4000 =   16384 = is a PONTER element */
  /* 0x8000 =   32768 = is a REF element */
  /* 0x10000 =  65536  = no NULL is stored with each element */
  /* 0x20000 =  131072 = number/float elements stored in min. fixed size */
  /* 0x40000 =  262144 = number/float elements stored in varying size    */
  charsetid     number,                                  /* character set id */
  charsetform   number,                                /* character set form */
  /* 1 = implicit: for CHAR, VARCHAR2, CLOB w/o a specified set */
  /* 2 = nchar: for NCHAR, NCHAR VARYING, NCLOB */
  /* 3 = explicit: for CHAR, etc. with "CHARACTER SET ..." clause */
  /* 4 = flexible: for PL/SQL "flexible" parameters */
  length        number,                  /* fixed character string length or */
                                  /* maximum varying character string length */
  precision     number,        /* fixed- or floating-point numeric precision */
  scale         number,                         /* fixed-point numeric scale */
  upper_bound   number,     /* fixed array size or varying array upper bound */
  spare1        number,                      /* fractional seconds precision */
  spare2        number,                  /* interval leading field precision */
  spare3        number)
cluster c_toid_version#(toid, version#)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table attribute$                                   /* attribute table */
( toid          raw(16) not null,                                    /* TOID */
  version#      number not null,             /* internal type version number */
  name          varchar2("M_IDEN") not null,               /* attribute name */
  attribute#    number not null,              /* attribute identifier number */
  attr_toid     raw(16) not null,                        /* attribute's TOID */
  attr_version# number not null,
                               /* attribute's type's internal version number */
  synobj#       number,                              /* obj# of type synonym */
  properties    number not null,                  /* attribute's properties: */
  /* 0x4000 =   16384 = is a PONTER attribute */
  /* 0x8000 =   32768 = is a REF attribute */
  charsetid     number,                                  /* character set id */
  charsetform   number,                                /* character set form */
  /* 1 = implicit: for CHAR, VARCHAR2, CLOB w/o a specified set */
  /* 2 = nchar: for NCHAR, NCHAR VARYING, NCLOB */
  /* 3 = explicit: for CHAR, etc. with "CHARACTER SET ..." clause */
  /* 4 = flexible: for PL/SQL "flexible" parameters */
  length        number,                  /* fixed character string length or */
                                  /* maximum varying character string length */
  precision#    number,        /* fixed- or floating-point numeric precision */
  scale         number,                         /* fixed-point numeric scale */
  externname    varchar2("M_VCSZ"),    /* field in java class for SQLJ types */
  xflags         number,                          /* flags not stored in TDO */
  /* 0x01 - inherited attribute */
  spare1        number,                      /* fractional seconds precision */
  spare2        number,                  /* interval leading field precision */
  spare3        number,                                          /* reserved */
  spare4        number,                                          /* reserved */
  spare5        number,                                          /* reserved */
  setter        number,                        /* Setter function no. (SQLJ) */
  getter        number                         /* Getter function no. (SQLJ) */
)
cluster c_toid_version#(toid, version#)
                               /* keys: (toid, version#, name or attribute#) */
/
create unique index i_attribute1 on attribute$(toid, version#, name)
/
create unique index i_attribute2 on attribute$(toid, version#, attribute#)
/
create table method$                               /* method signature table */
( toid          raw(16) not null,                                    /* TOID */
  version#      number not null,             /* internal type version number */
  method#       number not null,                /* method number or position */
  name          varchar2("M_IDEN") not null,                  /* method name */
  properties    number not null,                     /* method's properties: */
  /* 0x00001 =      1 = PRIVATE method */
  /* 0x00002 =      2 = PUBLIC method (default) */
  /* 0x00004 =      4 = INLINE method */
  /* 0x00008 =      8 = VIRTUAL method => NOT FINAL */
  /* 0x00010 =     16 = CONSTANT method */
  /* 0x00020 =     32 = contructor method */
  /* 0x00040 =     64 = destructor method */
  /* 0x00080 =    128 = operator method */
  /* 0x00100 =    256 = selfish method */
  /* 0x00200 =    512 = MAP method */
  /* 0x00800 =   2048 = ORDER method */
  /* 0x01000 =   4096 = Read No Data State method (default) */
  /* 0x02000 =   8192 = Write No Data State method */
  /* 0x04000 =  16384 = Read No Process State method */
  /* 0x08000 =  32768 = Write No Process State method */
  /* 0x10000 =  65536 = Not Instantiable method */
  /* 0x20000 = 131072 = Overriding method */
  /* 0x40000 = 262144 = Returns SELF as result */
  parameters#   number not null,                     /* number of parameters */
  results       number not null,                        /* number of results */
  xflags        number,                           /* Flags not stored in TDO */
  /* 0x01 - Inherited method */
  spare1        number,                                          /* reserved */
  spare2        number,                                          /* reserved */
  spare3        number,                                          /* reserved */
  externVarName varchar2("M_VCSZ")        /* external variable name for SQLJ */
  ) 
cluster c_toid_version#(toid, version#)
                                          /* keys: (toid, version#, method#) */
/
create unique index i_method1 on method$(toid, version#, method#)
/
REM 
REM !!! parameter$ is now obsolete. Use argument$ !!!
REM 
create table parameter$                            /* method parameter table */
( toid          raw(16) not null,                                    /* TOID */
  version#      number not null,             /* internal type version number */
  method#       number not null,                /* method number or position */
  name          varchar2("M_IDEN") not null,               /* parameter name */
  parameter#    number not null,             /* parameter number or position */
  param_toid    raw(16) not null,                 /* parameter's type's TOID */
  param_version# number not null,
                               /* parameter's type's internal version number */
  synobj#       number,                              /* obj# of type synonym */
  properties    number not null,                  /* parameter's properties: */
  /* 0x0100 =     256 = IN parameter (pass by value, default) */
  /* 0x0200 =     512 = OUT parameter */
  /* 0x0400 =    1024 = pass by reference parameter */
  /* 0x0800 =    2048 = required parameter (default) */
  /* 0x4000 =   16384 = is a PONTER parameter */
  /* 0x8000 =   32768 = is a REF parameter */
  charsetid     number,                                  /* character set id */
  charsetform   number,                                /* character set form */
  /* 1 = implicit: for CHAR, VARCHAR2, CLOB w/o a specified set */
  /* 2 = nchar: for NCHAR, NCHAR VARYING, NCLOB */
  /* 3 = explicit: for CHAR, etc. with "CHARACTER SET ..." clause */
  /* 4 = flexible: for PL/SQL "flexible" parameters */
  default$      varchar2("M_VCSZ"),                         /* default value */
  spare1        number,
  spare2        number,
  spare3        number)
cluster c_toid_version#(toid, version#)
                      /* keys: (toid, version#, method#, name or parameter#) */
/
create table ntab$                         /* nested table information table */
( obj#          number not null,             /* object number of base object */
  col#          number not null,                            /* column number */
  intcol#       number not null,                   /* internal column number */
  ntab#         number not null,     /* object number of nested table object */
  name          varchar2("M_VCSZ") default 'NT$' not null 
                                    /* qualified name of the nested table col*/
)
cluster c_obj#(obj#)
/
create index i_ntab1 on ntab$(obj#, col#)
/
create unique index i_ntab2 on ntab$(obj#, intcol#)
/
create index i_ntab3 on ntab$(ntab#)
/
create table refcon$                                /* REF CONstraints table */
( obj#          number not null,             /* object number of base object */
  col#          number not null,                            /* column number */
  intcol#       number not null,                   /* internal column number */
  reftyp        number not null,                            /* REF type flag */
                                                     /* 0x01 = REF is scoped */
                                             /* 0x02 = REF stored with rowid */
                                             /* 0x04 = Primary key based ref */
           /* 0x08 = Primary key based ref allowed in an unscoped ref column */
  stabid        raw(16),                   /* OID of scope table (if scoped) */
  expctoid      raw(16) /* TOID of exploded columns when ref is user-defined */
)
cluster c_obj#(obj#)
/
create index i_refcon1 on refcon$(obj#, col#)
/
create unique index i_refcon2 on refcon$(obj#, intcol#)
/
/* The opqtype$ stores extra information for the xmltype */
create table opqtype$                         /* extra info for opaque types */
(
  obj#        number not null,                /* object number of base table */
  intcol#     number not null,                     /* internal column number */
  type        number,                              /* The opaque type - type */
                                                       /* 0x01 - XMLType */
  flags       number,                          /* flags for the opaque type */
                              /* -------------- XMLType flags ---------
                               * 0x0001 (1) -- XMLType stored as object
                               * 0x0002 (2) -- XMLType schema is specified
                               * 0x0004 (4) -- XMLType stored as lob 
                               * 0x0008 (8) -- XMLType stores extra column
                               * 
                               * 0x0020 (20)-- XMLType table is out-of-line 
                               */
  /* Flags for XMLType (type == 0x01). Override them when necessary  */
  lobcol      number,                                          /* lob column */
  objcol      number,                                      /* obj rel column */
  extracol    number,                                      /* extra info col */
  schemaoid   raw(16),                                     /* schema oid col */
  elemnum     number,                                      /* element number */
  schemaurl   varchar2(4000)                       /* The name of the schema */
)
cluster c_obj#(obj#)
/
create unique index i_opqtype1 on opqtype$(obj#, intcol#)
/
REM
REM viewcon$ stores the view constraint text: one row per constraint and 
REM   the text is stored for the revalidation of view constraints in future
REM   release (stored but never used in 8.2). 
REM
create table viewcon$                            /* constraint text for view */
( obj#            number not null,                     /* view object number */
  con#            number,                               /* constraint number */
  conname         varchar2("M_IDEN"),                     /* constraint name */
  type#           number,                                 /* constraint type */
                              /* 2 = primary key, 3 = unique, 4= referential */
  con_text        clob,                                   /* constraint text */
  robj#           number,                        /* referenced object number */
  property        number                         /* view constraint property */
                                                   /* 0x00040000 set RELY on */
                                                 /* 0x00080000 /* Reset RELY */
)
/
create index i_viewcon1 on viewcon$(obj#)
/
create index i_viewcon2 on viewcon$(robj#)
/
REM
REM IMPORTANT NOTE:
REM   Due to the clob column, snap$ must appear after the creation of lob$
REM
create table snap$                                /* list of local snapshots */
( sowner          varchar2("M_IDEN") not null,          /* owner of snapshot */
  vname           varchar2("M_IDEN") not null,      /* name of snapshot view */
  tname           varchar2("M_IDEN") not null,     /* name of snapshot table */
  mview           varchar2("M_IDEN"),          /* view snapshot is made from */
  mowner          varchar2("M_IDEN"),                     /* owner of master */
  master          varchar2("M_IDEN"),                      /* name of master */
  mlink           varchar2("M_XDBI"),        /* database link to master site */
  can_use_log     varchar2(1),                                     /* unused */
  snapshot        date,       /* used by V7 masters to identify the snapshot */
  snapid          integer,    /* used by V8 masters to identify the snapshot */
  sscn            number,                                 /* scn of snapshot */
  snaptime        date,   /* when this snapshot was last refreshed: OBSOLETE */
  tscn            number,                                 /* scn of snaptime */
  error#          number,          /* last error caused by automatic refresh */
  auto_fast       varchar2(1),        /* date function for automatic refresh */
  auto_fun        varchar2("M_DATF"),             /* obsolete, 7.1 and above */
  auto_date       date,                           /* obsolete, 7.1 and above */
  refgroup        number,                                          /* unused */
  ustrg           varchar2("M_IDEN"),     /* trigger for updatable snapshots */
  uslog           varchar2("M_IDEN"),         /* log for updatable snapshots */
  status          integer,  /* 0x0000, Need to regenerate refresh operations */
                            /* 0x0001, fast refresh operations generated     */
                            /* 0x0002, complete refresh operations generated */
  master_version  integer,              /* Oracle version of the master site */
                                                              /* (1) -> V7.x */
                                                              /* (2) -> V8.0 */
  tables          integer,  /* number of tables in snapshot definition query */
  field1          number,                                  /* for future use */
  field2          varchar2("M_IDEN"),                      /* for future use */
  flag            number,                   /* 0x0001, can use master log    */
                                            /* 0x0002, snapshot is updatable */
                                            /* 0X0010, ROWID snapshot        */
                                            /* 0x0020, PRIMARY KEY snapshot  */
  flag2           number,                           /* extended snapshot flg */
  query_txt       long,                /* query which this view instantiates */
  lobmaskvec      raw(255),                       /* lob columns mask vector */
  mtime           date not null,                    /* DDL modification time */
  mas_roll_seg    varchar2("M_IDEN"),        /* master-side rollback segment */
  rscn            number,                                /* last refresh scn */
  refhnt          number,                                    /* refresh hint */
  query_len       integer,            /* length of snapshot definition query */
  instsite        integer default 0,                   /* instantiating site */
  flavor_id       number,                                       /* flavor id */
  objflag         number,                   /* object properties of snapshot */
  sna_type_oid    raw(16),                             /* object MV type OID */
  sna_type_hashcode raw("KOTHCL"),                /* object MV type hashcode */
  sna_type_owner  varchar2("M_IDEN"),                /* object MV type owner */
  sna_type_name   varchar2("M_IDEN"),                 /* object MV type name */
  mas_type_oid    raw(16),                   /* master object table type OID */
  mas_type_hashcode raw("KOTHCL"),      /* master object table type hashcode */
  mas_type_owner  varchar2("M_IDEN"),      /* master object table type owner */
  mas_type_name   varchar2("M_IDEN"),       /* master object table type name */
  parent_sowner   varchar2("M_IDEN"),               /* parent snapshot owner */
  parent_vname    varchar2("M_IDEN"),                /* parent snapshot name */
  rel_query       clob,                /* relational transformation of query */
  alias_txt       clob,                             /* text for column alias */
  syn_count       integer            /* number of synonyms for master tables */
)
/
create unique index i_snap1 on snap$(vname, sowner, instsite)
/
create index i_snap2 on snap$(parent_vname, parent_sowner, instsite)
/
create sequence snapshot_id$                         /* Snapshot ID sequence */
  increment by 1
  start with 1
  minvalue 1
  maxvalue 2147483647     /* max value that is guaranteed to fit into an SB4 */
  nocycle
/
create table snap_reftime$
( sowner          varchar2("M_IDEN") not null,          /* owner of snapshot */
  vname           varchar2("M_IDEN") not null,      /* name of snapshot view */
  tablenum        integer not null,   /* order of master table in snap query */
  snaptime        date,                    /* time of last refresh for table */
  mowner          varchar2("M_IDEN"),                     /* owner of master */
  master          varchar2("M_IDEN"),                      /* name of master */
  masflag         number,                  /* additional master information: */
                                    /* (0x0001) is a fact table              */
                                    /* (0x0002) can be foreign key optimized */
  masobj#         number,                        /* obj# of the master table */
  loadertime      date,       /* last refresh with respect to SQL*Loader log */
  refscn          number,   /* scn of latest info used to refresh this table */
  instsite        integer default 0,                   /* instantiating site */
  lastsuccess     date,             /* time of last known successful refresh */
  fcmaskvec       raw(255),                    /* filter columns mask vector */
  ejmaskvec       raw(255),                 /* equi-join columns mask vector */
  sub_handle      number,              /* subscription handle (if using CDC) */
  change_view     varchar2("M_IDEN")      /* change view name (if using CDC) */
)
/
create unique index i_snap_reftime1 on 
  snap_reftime$(vname, sowner, instsite, tablenum)
/
create table mlog_refcol$             /* list of snapshot log filter columns */
( mowner          varchar2("M_IDEN") not null,            /* owner of master */
  master          varchar2("M_IDEN") not null,             /* name of master */
  colname         varchar2("M_IDEN") not null,   /* master table column name */
  oldest          date,          /* maximum age of information in the column */
  flag            integer)                       /* column meta information: */
/
create unique index i_mlog_refcol1 on mlog_refcol$(mowner, master, colname)
/
create table snap_refop$            /* fast refresh operations for snapshots */
( sowner          varchar2("M_IDEN") not null,          /* owner of snapshot */
  vname           varchar2("M_IDEN") not null,      /* name of snapshot view */
  tabnum          integer not null,   /* order of table in subquery chain    */
                                      /* the master table is indicated by 1  */
  setnum          integer default 0,  /* the set of queries for a given      */
                                      /* table number, used for many-many    */
                                      /* subqueries or UNIONS                */
  operation#      integer not null,   /* operation type (see kkzrff, kkzrei) */
                                      /* FAST REFRESH OPERATIONS (outer tab) */
                                      /* 0 -> SELECT for delete phase        */
                                      /* 1 -> DELETE statement               */
                                      /* 2 -> SELECT for upd/ins phase       */
                                      /* 3 -> UPDATE statement               */
                                      /* 4 -> INSERT statement               */
                                      /* 5 -> DELETE local inserts (if upd)  */
                                      /* FAST REFRESH OPERATIONS (inner tab) */
                                      /* 0 -> SELECT for delete phase        */
                                      /* 1 -> DELETE statement               */
                                      /* 2 -> SELECT for insert phase        */
                                      /* 3 -> INSERT statement               */
                                      /* COMPLETE REFRESH OPERATIONS         */
                                      /* 6 -> Insert as Select               */
  cols            number,             /* bind columns in the query           */
                                      /* 0 -> no bind columns                */
                                      /* 1 -> snaptime                       */
                                      /* 2 -> snaptime, ejmaskvec            */
                                      /* 3 -> snaptime, ejmaskvec, fcmaskvec */
  fcmaskvec       raw(255),        /* obsolete -  filter columns mask vector */
                                      /* used for many-many subquery or UNION*/
  ejmaskvec       raw(255),       /* obsolete -equi-join columns mask vector */
                                      /* used for many-many subquery or UNION*/
  sql_txt         long,                /* query which this view instantiates */
  instsite        integer default 0)                   /* instantiating site */
/
create unique index i_snap_refop1 on 
  snap_refop$(sowner, vname, instsite, operation#, tabnum, setnum)
/
create table snap_colmap$            /* snapshot column aliasing information */
( sowner          varchar2("M_IDEN") not null,          /* owner of snapshot */
  vname           varchar2("M_IDEN") not null,      /* name of snapshot view */
  snacol          varchar2("M_IDEN") not null,    /* name of snapshot column */
  tabnum          integer not null,   /* order of master table in snap query */
  mascol          varchar2("M_IDEN"),                  /* master column name */
  maspos          integer,             /* position of master column (intcol) */
  colrole         number,                         /* how is this column used */
  instsite        integer default 0,                   /* instantiating site */
  snapos          integer default 0     /* position of col in snapshot table */
)
/
create unique index i_snap_colmap1 on 
  snap_colmap$(sowner, vname, instsite, tabnum, snacol)
/
create table snap_objcol$              /* snapshot object column information */
( sowner            varchar2("M_IDEN") not null,      /* snapshot view owner */
  vname             varchar2("M_IDEN") not null,       /* snapshot view name */
  instsite          integer default 0,                 /* instantiating site */
  tabnum            integer not null, /* master table this column belongs to */
  snacol            varchar2("M_IDEN") not null,     /* snapshot column name */
  mascol            varchar2("M_IDEN"),     /* associated master column name */
  flag              number,                             /* column properties */
  storage_tab_owner varchar2("M_IDEN"),  /* non-image coll/substitutable col */
  storage_tab_name  varchar2("M_IDEN"),  /* non-image coll/substitutable col */
  sna_type_oid      raw(16),                 /* type OID for snapshot column */
  sna_type_hashcode raw("KOTHCL"),      /* type hashcode for snapshot column */
  sna_type_owner    varchar2("M_IDEN"),    /* type owner for snapshot column */
  sna_type_name     varchar2("M_IDEN"),     /* type name for snapshot column */
  mas_type_oid      raw(16),                   /* type OID for master column */
  mas_type_hashcode raw("KOTHCL"),        /* type hashcode for master column */
  mas_type_owner    varchar2("M_IDEN"),      /* type owner for master column */
  mas_type_name     varchar2("M_IDEN")        /* type name for master column */
)
/
create unique index i_snap_objcol1 on 
  snap_objcol$(sowner, vname, instsite, tabnum, snacol);
/
create table reg_snap$            /* snapshots that use masters on this site */
( sowner          varchar2("M_IDEN") not null,          /* owner of snapshot */
  snapname        varchar2("M_IDEN") not null,           /* name of snapshot */
  snapsite        varchar2("M_XDBI") not null,       /* location of snapshot */
  snapshot_id     integer,                        /* identifies the snapshot */
  flag            number,                            /* updatable, PK, rowid */
  rep_type        number,                        /* type of replicating site */
  comment$        varchar2("M_VCSZ"),                 /* comment on snapshot */
  query_txt       long)                 /* query that this view instantiates */
/
create unique index i_reg_snap1 on reg_snap$(sowner, snapname, snapsite)
/
create index i_reg_snap2 on reg_snap$(snapshot_id)
/
create table snap_site$                      /* mapping of site names to IDs */
( site_name  varchar2("M_XDBI") not null,                       /* site name */
  site_id    integer                                              /* site ID */
)
/
create unique index i_snap_site1 on snap_site$(site_name)
/
create sequence snapsite_id$                    /* snapshot Site ID sequence */
  increment by 1
  start with 1
  minvalue 1
  maxvalue 4294967295                           /* max portable value of UB4 */
  nocycle
/
rem 
rem  Job Queue
rem
create sequence jobseq
  start with 1
  increment by 1
  minvalue 1
  maxvalue 999999999                        /* should be less than MAXSB4VAL */
  cache 20
  noorder
  cycle
/
create table job$
( job             number not null,                  /* identifier of the job */
  lowner          varchar2("M_IDEN") not null,             /* logged in user */
  powner          varchar2("M_IDEN") not null,                   /* security */
  cowner          varchar2("M_IDEN") not null,                    /* parsing */
  last_date       date,                      /* when this job last succeeded */
  this_date       date,    /* when the current execute started, usually null */
  next_date       date not null,             /* when to execute the job next */
  total           number default 0 not null, /* total time spent on this job */
  interval#       varchar2("M_DATF") not null,/* function for next next_date */
  failures        number,           /* number of failures since last success */
  flag            number default 0 not null,     /* 0x01, this job is broken */
  what            varchar2("M_VCSZ"),        /* PL/SQL text, what is the job */
  nlsenv          varchar2("M_VCSZ"),                      /* nls parameters */
  env             raw(32),                    /* other environment variables */
  cur_ses_label   mlslabel,                       /* OBSOLETE: 8.0 and above */
  clearance_hi    mlslabel,                       /* OBSOLETE: 8.0 and above */
  clearance_lo    mlslabel,                       /* OBSOLETE: 8.0 and above */
  charenv         varchar2("M_VCSZ"),         /* Reserved for Trusted Oracle */
  field1          number default 0) /* instance number restricted to run  job*/
/
create unique index i_job_job on job$ (job)
/
create index i_job_next on job$ (next_date)
/
rem
rem  Refresh Groups
rem
create sequence rgroupseq
  start with 1
  increment by 1
  minvalue 1
  maxvalue 999999999                        /* should be less than MAXSB4VAL */
  cache 20
  noorder
  cycle
/
create cluster c_rg#
( refgroup        number)                            /* refresh group number */
/
create index i_rg# on cluster c_rg#
/
create table rgroup$
( refgroup         number,                        /* number of refresh group */
  owner            varchar2("M_IDEN") not null,    /* owner of refresh group */
  name             varchar2("M_IDEN") not null,     /* name of refresh group */
  flag             number default 0,       /* 0x01, destroy group when empty */
                                                 /* 0x02, do not push queues */
                                               /* 0x04, refresh after errors */
                                               /* 0x08, RepAPI refresh group */
  rollback_seg     varchar2("M_IDEN"),            /* rollback segment to use */
  field1           number default 0,
  job              number not null,  /* job in job$ for refreshing this group */
  purge_opt#       integer,      /* purge_opt#, parallelism#, and heap_size# */
  parallelism#     integer,      /* are parameters for parallel propagation  */
  heap_size#       integer,      /* in V8                                    */
  instsite         integer default 0,                    /* snapshot site id */
  refresh_sequence number                     /* refresh sequence for RepAPI */
)
cluster c_rg# (refgroup)
/
create unique index i_rgroup on rgroup$ (owner, name, instsite)
/
create unique index i_rgref on rgroup$ (refgroup)
/
create index i_rgjob on rgroup$ (job)
/
create table rgchild$
( owner           varchar2("M_IDEN") not null,             /* owner of child */
  name            varchar2("M_IDEN") not null,              /* name of child */
  type#           varchar2("M_IDEN") default 'SNAPSHOT',   /* type of object */
  field1          number default 0,
  refgroup        number,                   /* refresh group the child is in */
  instsite        integer default 0                      /* snapshot site id */
)
cluster c_rg# (refgroup)
/
create unique index i_rgchild on rgchild$ (owner, name, instsite, type#)
/
rem
rem  Drop User Cascade
rem
create table duc$
( owner           varchar2("M_IDEN") not null,            /* procedure owner */
  pack            varchar2("M_IDEN") not null,          /* procedure package */
  proc            varchar2("M_IDEN") not null,             /* procedure name */
  field1          number default 0,
  operation#      number not null,                    /* 1=drop user cascade */
  seq             number not null,            /* for ordering the procedures */
  com             varchar2(80))       /* comment on what this routine is for */
/
create unique index i_duc on duc$ (owner,pack,proc,operation#)
/
rem
rem  Histograms
rem
create cluster c_obj#_intcol#
( obj#            number,                                   /* object number */
  intcol#         number)                          /* internal column number */
  pctfree 5
  storage (initial 2m next 200k maxextents unlimited pctincrease 0)
/
create index i_obj#_intcol# on cluster c_obj#_intcol#
  storage (maxextents unlimited)
/
create table histgrm$                                     /* histogram table */
( obj#            number not null,                          /* object number */
  col#            number not null,                          /* column number */
  row#            number,                       /* row number (in row cache) */
  bucket          number not null,                          /* bucket number */
  endpoint        number not null,                  /* endpoint hashed value */
  intcol#         number not null,                 /* internal column number */
  epvalue         varchar2(1000),              /* endpoint value information */
  spare1          number,
  spare2          number)
cluster c_obj#_intcol#(obj#, intcol#)
/
create index i_h_obj#_col# on histgrm$(obj#, col#)
  storage (maxextents unlimited)
/

create table hist_head$                            /* histogram header table */
 (obj#            number not null,                          /* object number */
  col#            number not null,                          /* column number */
  bucket_cnt      number not null,                      /* number of buckets */
  row_cnt         number not null,             /* number of rows in histgrm$ */
  cache_cnt       number,                     /* number of rows in row cache */
  null_cnt        number,                  /* number of nulls in this column */
  timestamp#      date,                   /* date of histogram's last update */
  sample_size     number,             /* for estimated stats, size of sample */
  minimum         number,           /* minimum value (if 1-bucket histogram) */
  maximum         number,           /* minimum value (if 1-bucket histogram) */
  distcnt         number,                            /* # of distinct values */
  lowval          raw(32),
                        /* lowest value of column (second lowest if default) */
  hival           raw(32),
                      /* highest value of column (second highest if default) */
  density         number,                                   /* density value */
  intcol#         number not null,                 /* internal column number */
  spare1          number,                /* sample number of distinct values */
  spare2          number,                                           /* flags */
                    /* 0x01 = user-specified stats                           */
                    /* 0x02 = global stats                                   */
                    /* 0x04 = endpoint actual values in histogram            */
  avgcln          number,                           /* average column length */
  spare3          number,                                           /* spare */
  spare4          number                                            /* spare */
  )
  storage (initial 350k next 100k maxextents unlimited pctincrease 0)
/
create index i_hh_obj#_col# on hist_head$(obj#, col#)
  storage (maxextents unlimited)
/
create index i_hh_obj#_intcol# on hist_head$(obj#, intcol#)
  storage (maxextents unlimited)
/

create table dual                   /* pl/sql's standard pckg requires dual. */
  (dummy varchar2(1))    /* note, the optimizer knows sys.dual is single row */
  storage (initial 1)
/
insert into dual values('X')
/
create public synonym dual for dual
/
grant select on dual to public with grant option
/
rem Dual and this sequence are required by the parallel query option.
create sequence ora_tq_base$
  start with 1
  increment by 1
  nominvalue
  maxvalue 4294967  /* Ceiling as anything higher causes overflow internally */
  nocache
  noorder
  cycle                        /* Needed to complement the ceiling specified */
/

rem
rem  Partitioned Objects
rem

rem partition name sequence
rem This sequence is used to generate names for new partitions 
rem and subpartitions
create sequence partition_name$
  start with 1
  increment by 1
  minvalue 1
  nomaxvalue
  nocycle
  noorder
  cache 20
/
rem
rem partobj$ table
rem This table has a row per partitioned object
rem obj# is the key
rem There is a unique index on obj#
rem
create table partobj$ (
  obj#        number not null,/* object number of partitioned table or index */
  parttype    number not null,                          /* partitioning type */
             /* 1 = range, 2 = hash, 3 = system; if range, */
             /* subparttype may be non-zero to indicate type of */
             /* Range Composite partitioning method */
             /* see subparttype for form of Range Composite partitioning 
             /* used */
  partcnt     number not null,                       /* number of partitions */
  partkeycols number not null,      /* number of columns in partitioning key */
  flags       number,               /* 1 = local index, 2 = prefixed index   */
  defts#      number,                           /* default tablespace number */
  defpctfree  number not null,                            /* default PCTFREE */
  defpctused  number not null,          /* default PCTUSED (N/A for indexes) */
  defpctthres number,               /* default PCTTHRESHOLD (N/A for tables) */
  definitrans number not null,                           /* default INITRANS */
  defmaxtrans number not null,                           /* default MAXTRANS */
  deftiniexts number,                         /* default INITIAL extent size */
  defextsize  number,                            /* default NEXT extent size */
  defminexts  number,                                  /* default MINEXTENTS */
  defmaxexts  number,                                  /* default MAXEXTENTS */
  defextpct   number,                                 /* default PCTINCREASE */
  deflists    number not null,                    /* default FREELISTS value */
  defgroups   number not null,  /* default FREELIST GROUPS (N/A for indexes) */
  deflogging  number not null,   /* default logging attribute of the object: */
                              /* 0 - unspecified; 1 - LOGGING; 2 - NOLOGGING */
  spare1      number,                           /* default BUFFER_POOL value */

  /* 5 bytes of spare2 are currently spoken for */
  /* byte 0   : subparttype - non-zero implies Composite partitioning */
  /*            (1 - Range, 2 - Hash, 3 - System, 4 - List); */
  /* byte 1   : subpartkeycols; */
  /* bytes 2-3: defsubpartcnt */
  /* byte 4   : compression attribute */
  /*            (0-NONE, 1-COMPRESSION ENABLED, 2-COMPRESSION DISABLED) */
  spare2      number,                       

  spare3      number,                                       /* spare column  */
  definclcol  number,       /* default iot include column # (N/A for tables) */
  parameters  varchar2(1000))  /* default parameter string for domain index  */
/
create unique index i_partobj$ on partobj$(obj#)
/
rem
rem  partcol$ table
rem  This table has a row per partitioning key column
rem  obj#, intcol# is a key
rem  There is a non-unique index on obj#
create table partcol$ (
  obj#   number not null,     /* object number of partitioned table or index */
  intcol# number not null,                         /* internal column number */
  col#   number not null,                                   /* column number */
  pos#   number not null,    /* position of column in key (1 = first column) */
  spare1 number,                                     /* NLS character set id */
  segcol#       number not null,                 /* column number in segment */
  type#         number  not null,                     /* data type of column */
  charsetform   number)                            /* NLS character set form */
/
create index i_partcol$ on partcol$(obj#)
/
rem
rem  tabpart$ table
rem  This table has one row per table partition
rem  obj# is a key; and so is (bo#, part#)
rem  There is a non-unique index on bo#, obj#
rem
rem  NOTE 
rem  Logminer/Streams uses contents of this table. 
rem  Please do not reuse any flags without verifying the impact of your 
rem  changes on inter-op.  
create table tabpart$ (
  obj#        number not null,                 /* object number of partition */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#    number,                            /* data layer object number */
  bo#         number not null,                /* object number of base table */
  part#       number not null,    /* partition number (see discussion below) */
  hiboundlen  number not null,      /* length of high bound value expression */
  hiboundval  long,                   /* text of high-bound value expression */
  ts#         number,           /* tablespace number where partition resides */
  file#       number,                          /* segment header file number */
  block#      number,                         /* segment header block number */
  pctfree$    number not null,   /* minimum free space percentage in a block */
  pctused$    number not null,   /* minimum used space percentage in a block */
  initrans    number not null,             /* initial number of transactions */
  maxtrans    number not null,             /* maximum number of transactions */
  flags       number not null,                              /* for any flags */
                                  /* 0x01 = 7.3 -> 8.0 data object migration */
                                  /* 0x02 = partition has been analyzed      */
                                  /* 0x04 = NO LOGGING for partition         */
                                  /* 0x08 = user-specified stats             */
                                  /* 0x10 = global stats                     */
  analyzetime date,                          /* timestamp when last analyzed */
  samplesize  number,                            /* samplesize for histogram */
  rowcnt      number,                                      /* number of rows */
  blkcnt      number,                                    /* number of blocks */
  empcnt      number,                              /* number of empty blocks */
  avgspc      number,        /* average available free space /iot ovfl stats */
  chncnt      number,                              /* number of chained rows */
  avgrln      number,                                  /* average row length */
  /* These spare columns are for future needs, e.g. values for the 
   * PARALLEL(degree, instances) parameters.
   */

  spare1      number,                             /* summary sequence number */
  spare2      number,
  spare3      number,
  bhiboundval blob)             /* binary linear key form of partition bound */
/
create unique index i_tabpart_bopart$ on tabpart$(bo#, part#)
/
create unique index i_tabpart_obj$ on tabpart$(obj#)
/
rem  indpart$ table
rem  This table has one row per index partition
rem  obj# is a key, and so is (bo#, part#)
rem  There is a non-unique index on bo#, obj#
rem
rem  NOTE 
rem  Logminer/Streams uses contents of this table. 
rem  Please do not reuse any flags without verifying the impact of your 
rem  changes on inter-op.  
create table indpart$ (
  obj#        number not null,                 /* object number of partition */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#             number,                   /* data layer object number */
  bo#         number not null,                /* object number of base index */
  part#       number not null,
                         /* partition number (see discussion under TABPART$) */
  hiboundlen  number not null,      /* length of high bound value expression */
  hiboundval  long ,                  /* text of high bound value expression */
  flags   number not null,
                    /* 0x01 = Unusable (this field replaces the V7 DLS flag) */
                    /* 0x02 = partition has been analyzed                    */ 
                    /* 0x04 = NO LOGGING for partition                       */
                    /* 0x08 = user-specified stats                           */
                    /* 0x10 = global stats                                   */
                    /* 0x100 = index partition is being online built         */
                    /* 0x200= index partition is being online rebuilt        */
                    /* 0x400 = index partition operation in progress         */
                    /* 0x800 = index partition operation has failed          */
  ts#         number not null,  /* tablespace number where partition resides */
  file#       number not null,                 /* segment header file number */
  block#      number not null,                /* segment header block number */
  pctfree$    number not null,   /* minimum free space percentage in a block */
  pctthres$     number,           /* iot overflow threshold, null if not iot */
  initrans    number not null,             /* initial number of transactions */
  maxtrans    number not null,             /* maximum number of transactions */
  analyzetime date,                          /* timestamp when last analyzed */
  samplesize  number,                            /* samplesize for histogram */
  rowcnt      number,                                      /* number of rows */
  blevel      number,                                        /* B-tree level */
  leafcnt     number,                               /* number of leaf blocks */
  distkey     number,                             /* number of distinct keys */
  lblkkey     number,               /* average number of leaf blocks per key */
  dblkkey     number,               /* average number of data blocks per key */
  clufac      number,                                   /* clustering factor */
  spare1      number,
  /* These spare columns are for future needs, e.g. values for the
   * PARALLEL(degree, instances) parameters.
   */
  spare2   number,
  spare3   number,
  inclcol      number,        /* iot include column number, null if not iot */
  bhiboundval blob)            /* binary linear key form of partition bound */
/
create unique index i_indpart_bopart$ on indpart$(bo#, part#)
/
create unique index i_indpart_obj$ on indpart$(obj#)
/
rem
rem  subpartcol$ table
rem  This table has a row per subpartitioning key column for (R+H)
rem  obj#, intcol# is a key
rem  There is a non-unique index on obj#
create table subpartcol$ (
  obj#   number not null,     /* object number of partitioned table or index */
  intcol# number not null,                         /* internal column number */
  col#   number not null,                                   /* column number */
  pos#   number not null,    /* position of column in key (1 = first column) */
  spare1 number,                                     /* NLS character set id */
  segcol#       number not null,                 /* column number in segment */
  type#         number  not null,                     /* data type of column */
  charsetform   number)                            /* NLS character set form */
/
create index i_subpartcol$ on subpartcol$(obj#)
/
rem
rem  tabsubpart$ table
rem  This table has one row per table subpartition
rem  obj# is a key; and so is (pobj#, subpart#)
rem  There is a non-unique index on pobj#, obj#
rem
rem  NOTE 
rem  Logminer/Streams uses contents of this table. 
rem  Please do not reuse any flags without verifying the impact of your 
rem  changes on inter-op.  
create table tabsubpart$ (
  obj#        number not null,              /* object number of subpartition */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#    number,                            /* data layer object number */
  pobj#       number not null,
                       /* object number of partition containing subpartition */
  subpart#    number not null,  
                     /* subpartition number within parent partition (base 1) */
  flags   number not null,
                                  /* 0x02 = partition has been analyzed      */
                                  /* 0x04 = NO LOGGING for partition         */
                                  /* 0x08 = user-specified stats             */
                                  /* 0x10 = global stats                     */
  ts#         number not null,
                             /* tablespace number where subpartition resides */
  file#       number not null,        /* segment header relative file number */
  block#      number not null,                /* segment header block number */
  pctfree$    number not null,   /* minimum free space percentage in a block */
  pctused$    number not null,   /* minimum used spare precentage in a block */
  initrans    number not null,             /* initial number of transactions */
  maxtrans    number not null,             /* maximum number of transactions */
  analyzetime date,                          /* timestamp when last analyzed */
  samplesize  number,                   /* number of rows sampled by analyze */
  rowcnt      number,                                      /* number of rows */
  blkcnt      number,                                    /* number of blocks */
  empcnt      number,                              /* number of empty blocks */
  avgspc      number,                        /* average available free space */
  chncnt      number,                              /* number of chained rows */
  avgrln      number,                                  /* average row length */
  /* These spare columns are for future needs, e.g. values for the 
   * PARALLEL(degree, instances) parameters.
   */
  spare1      number,                             /* summary sequence number */
  spare2      number,
  spare3      number,
  hiboundlen  number not null,      /* length of high bound value expression */
  hiboundval  long,                   /* text of high-bound value expression */
  bhiboundval blob)             /* binary linear key form of partition bound */
/
create unique index i_tabsubpart_pobjsubpart$ on tabsubpart$(pobj#, subpart#)
/
create unique index i_tabsubpart$_obj$ on tabsubpart$(obj#)
/
rem
rem  indsubpart$ table
rem  This table has one row per index subpartition
rem  obj# is a key; and so is (pobj#, subpart#)
rem  There is a non-unique index on pobj#, obj#
rem
rem  NOTE 
rem  Logminer/Streams uses contents of this table. 
rem  Please do not reuse any flags without verifying the impact of your 
rem  changes on inter-op.  
create table indsubpart$ (
  obj#          number not null,            /* object number of subpartition */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE          
   * TRANSACTION DURING TRUNCATE */
  dataobj#               number,                 /* data layer object number */
  pobj#         number not null,               /* object number of partition */
  subpart#      number not null, /* subpartitn # w/in parent partitn(base 1) */
  flags         number not null,    /* 0x01 = Unusable                       */
                                    /* 0x02 = subpartition has been analyzed */
                                    /* 0x04 = NO LOGGING for subpartition    */
                                    /* 0x08 = user-specified stats           */
                                    /* 0x10 = global stats                   */
  ts#           number not null,  /* tablespace # where subpartition resides */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  pctfree$      number not null, /* minimum free space percentage in a block */
  initrans      number not null,           /* initial number of transactions */
  maxtrans      number not null,           /* maximum number of transactions */
  analyzetime   date,                        /* timestamp when last analyzed */
  samplesize    number,                          /* samplesize for histogram */
  rowcnt        number,                                    /* number of rows */
  blevel        number,                                      /* B-tree level */
  leafcnt       number,                             /* number of leaf blocks */
  distkey       number,                           /* number of distinct keys */
  lblkkey       number,             /* average number of leaf blocks per key */
  dblkkey       number,             /* average number of data blocks per key */
  clufac        number,                                 /* clustering factor */
  spare1        number,
         /* These spare columns are for future needs, e.g. values for the
          * PARALLEL(degree, instances) parameters.
          */
  spare2        number,
  spare3        number,
  hiboundlen    number not null,  /* length of high bound value expression */
  hiboundval    long ,              /* text of high bound value expression */
  bhiboundval   blob)         /* binary linear key form of partition bound */
/
create unique index i_indsubpart_pobjsubpart$ on indsubpart$(pobj#, subpart#)
/
create unique index i_indsubpart_obj$ on indsubpart$(obj#)
/
rem
rem tabcompart$ table
rem This table has a row per table composite partition
rem obj# is the key; and so is (bo#, part#)
rem There is a unique index on obj#
rem
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table tabcompart$ (
  obj#        number not null,                 /* object number of partition */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#    number,                                          /* not in use */
  bo#         number not null,                /* object number of base table */
  part#       number not null,    /* partition number (see discussion below) */
  hiboundlen  number not null,      /* length of high bound value expression */
  hiboundval  long,                   /* text of high-bound value expression */
  subpartcnt  number not null,                    /* number of subpartitions */
  flags       number not null,                              /* for any flags */
                                  /* 0x01 = 7.3 -> 8.0 data object migration */
                                  /* 0x02 = partition has been analyzed      */
                                  /* 0x04 - not used                         */
                                  /* 0x08 = user-specified stats             */
                                  /* 0x10 = global stats                     */
  defts#      number,                                  /* default TABLESPACE */
  defpctfree  number not null,                            /* default PCTFREE */
  defpctused  number not null,                            /* default PCTUSED */
  definitrans number not null,                           /* default INITRANS */
  defmaxtrans number not null,                           /* default MAXTRANS */
  definiexts  number,    /* default INITIAL extent size; NULL if unspecified */
  defextsize  number,       /* default NEXT extent size; NULL if unspecified */
  defminexts  number,             /* default MINEXTENTS; NULL if unspecified */
  defmaxexts  number,             /* default MAXEXTENTS; NULL if unspecified */
  defextpct   number,            /* default PCTINCREASE; NULL if unspecified */
  deflists    number,        /* default FREELISTS value; NULL if unspecified */
  defgroups   number,        /* default FREELIST GROUPS; NULL if unspecified */
  deflogging  number,                          /* default LOGGING attribute: */
                              /* 0 - unspecified; 1 - LOGGING; 2 - NOLOGGING */
  defbufpool  number,                           /* default BUFFER_POOL value */
  analyzetime date,                          /* timestamp when last analyzed */
  samplesize  number,                            /* samplesize for histogram */
  rowcnt      number,                                      /* number of rows */
  blkcnt      number,                                    /* number of blocks */
  empcnt      number,                              /* number of empty blocks */
  avgspc      number,                        /* average available free space */
  chncnt      number,                              /* number of chained rows */
  avgrln      number,                                  /* average row length */
  /* These spare columns are for future needs, e.g. values for the 
   * PARALLEL(degree, instances) parameters.
   */
  spare1      number,

  /* Only 1 byte of spare2 is currently spoken for */
  /* byte 0   : compression attribute of the partition */
  /*            0-NONE(UNSPECIFIED), 1-COMPRESS  2-NOCOMPRESS*/
  spare2      number,                       
  spare3      number,
  bhiboundval blob)             /* binary linear key form of partition bound */
/
create unique index i_tabcompart_bopart$ on tabcompart$(bo#, part#)
/
create unique index i_tabcompart$ on tabcompart$(obj#)
/
rem
rem indcompart$ table
rem This table has a row per index composite partition
rem obj# is the key; and so is (bo#, part#)
rem There is a unique index on obj#
rem
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table indcompart$ (
  obj#        number not null,                 /* object number of partition */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#    number,                                          /* not in use */
  bo#         number not null,                /* object number of base index */
  part#       number not null,                           /* partition number */
  hiboundlen  number not null,      /* length of high bound value expression */
  hiboundval  long,                   /* text of high-bound value expression */
  subpartcnt  number not null,                    /* number of subpartitions */
  flags       number not null,                              /* for any flags */
                                  /* 0x01 - not used                         */
                                  /* 0x02 = partition has been analyzed      */
                                  /* 0x04 - not used                         */
                                  /* 0x08 = user-specified stats             */
                                  /* 0x10 = global stats                     */
  defts#      number,             /* default TABLESPACE; NULL if unspecified */
  defpctfree  number not null,                            /* default PCTFREE */
  definitrans number not null,                           /* default INITRANS */
  defmaxtrans number not null,                           /* default MAXTRANS */
  definiexts  number,    /* default INITIAL extent size; NULL if unspecified */
  defextsize  number,       /* default NEXT extent size; NULL if unspecified */
  defminexts  number,             /* default MINEXTENTS; NULL if unspecified */
  defmaxexts  number,             /* default MAXEXTENTS; NULL if unspecified */
  defextpct   number,            /* default PCTINCREASE; NULL if unspecified */
  deflists    number,        /* default FREELISTS value; NULL if unspecified */
  defgroups   number,           /* default FREELIST GROUPS (N/A for indexes) */
  deflogging  number,                          /* default LOGGING attribute: */
                              /* 0 - unspecified; 1 - LOGGING; 2 - NOLOGGING */
  defbufpool  number,                           /* default BUFFER_POOL value */
  analyzetime date,                          /* timestamp when last analyzed */
  samplesize  number,                            /* samplesize for histogram */
  rowcnt      number,                                      /* number of rows */
  blevel      number,                                        /* B-tree level */
  leafcnt     number,                               /* number of leaf blocks */
  distkey     number,                             /* number of distinct keys */
  lblkkey     number,               /* average number of leaf blocks per key */
  dblkkey     number,               /* average number of data blocks per key */
  clufac      number,                                   /* clustering factor */
  spare1      number,
  /* These spare columns are for future needs, e.g. values for the
   * PARALLEL(degree, instances) parameters.
   */
  spare2   number,
  spare3   number,
  bhiboundval blob)             /* binary linear key form of partition bound */
/
create unique index i_indcompart_bopart$ on indcompart$(bo#, part#)
/
create unique index i_indcompart$ on indcompart$(obj#)
/
rem
rem partlob$ table
rem This table will be used to store table-level default attributes for LOB
rem columns in partitioned tables.
rem
create table partlob$ (
  lobj#       number not null,                 /* object number of partition */
  tabobj#     number not null,    /* obj# of the table containing lob column */
  intcol#     number not null,       /* internal column id of the lob column */
  defts#      number,             /* default TABLESPACE; NULL if unspecified */
  defchunk    number not null,     /* default oracle blocks in one lob chunk */
  defpctver$  number not null,                       /* default version pool */
  defflags    number not null,              /* default CACHE & LOGGING attrs */
                                                           /* 0x0000 = CACHE */
                                                 /* 0x0001 = NOCACHE LOGGING */
                                               /* 0x0002 = NOCACHE NOLOGGING */
                                             /* 0x0008 = CACHE READS LOGGING */
                                           /* 0x0010 = CACHE READS NOLOGGING */ 
  defpro      number not null,                 /* default partition property */
                                             /* 0x02 = enable storage in row */
  definiexts  number,    /* default INITIAL extent size; NULL if unspecified */
  defextsize  number,       /* default NEXT extent size; NULL if unspecified */
  defminexts  number,             /* default MINEXTENTS; NULL if unspecified */
  defmaxexts  number,             /* default MAXEXTENTS; NULL if unspecified */
  defextpct   number,            /* default PCTINCREASE; NULL if unspecified */
  deflists    number,        /* default FREELISTS value; NULL if unspecified */
  defgroups   number,        /* default FREELIST GROUPS; NULL if unspecified */
  defbufpool  number,            /* default BUFFER_POOL; NULL if unspecified */
  spare1      number,
  spare2      number,
  spare3      number       
)
/
rem
rem lobfrag$ table
rem This table will be used to store attributes of partitions (for tables
rem partitioned using Range, Hash, and System methods) and subpartitions 
rem (for tables partitioned using Composite methods) of LOB columns.
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table lobfrag$ (
  fragobj#     number not null,           /* object number of a LOB fragment */
  parentobj#   number not null,               /* object number of the parent */
                                        /* (LOB column for partitions or LOB */ 
                                             /* partition for subpartitions) */
  tabfragobj#  number not null,  /* object number of corresponding LOB table */
                                                                 /* fragment */
  indfragobj#  number not null,  /* object number of corresponding LOB index */
                                                                 /* fragment */
  frag#        number not null,       /* fragment # (partn w/in a LOB column */
                                  /* or subpartition w/in the LOB partition) */
  fragtype$    char(1),                                /* LOB fragment type: */
                                     /* 'P' - partition;  'S' - subpartition */
  ts#         number not null,          /* tablespace number of LOB fragment */
  file#       number not null,                 /* segment header file number */
  block#      number not null,                /* segment header block number */
  chunk       number not null,             /* oracle blocks in one lob chunk */
  pctversion$ number not null,                               /* version pool */
  fragflags   number not null,                 /* CACHE & LOGGING attributes */
                                                           /* 0x0000 = CACHE */
                                                 /* 0x0001 = NOCACHE LOGGING */
                                               /* 0x0002 = NOCACHE NOLOGGING */
                                             /* 0x0008 = CACHE READS LOGGING */
                                           /* 0x0010 = CACHE READS NOLOGGING */ 
  fragpro     number not null,                          /* fragment property */
                                             /* 0x02 = enable storage in row */
  spare1      number,
  spare2      number,
  spare3      number       
)
/
create unique index i_lobfrag_parentobjfrag$ on lobfrag$(parentobj#, frag#)
/
create unique index i_lobfrag$_fragobj$ on lobfrag$(fragobj#)
/
rem
rem lobcomppart$ table
rem This table will contain partition-level default attributes for partitioned
rem of LOB columns of table partitioned using Composite methods.         
rem
create table lobcomppart$ (
  partobj#     number not null,          /* object number of a LOB partition */
  lobj#        number not null,  /* object number of the LOB column to which */
                                                    /* the partition belongs */
  tabpartobj#  number not null,      /* object number of the table partition */
                                      /* to which this partition corresponds */
  indpartobj#  number not null,      /* object number of the index partition */
                                      /* to which this partition corresponds */
  part#        number not null,        /* partition number w/in a LOB column */
  defts#       number,            /* default TABLESPACE; NULL if unspecified */
  defchunk     number not null,    /* default oracle blocks in one lob chunk */
  defpctver$   number not null,                      /* default version pool */
  defflags     number not null,             /* default CACHE & LOGGING attrs */
                                                           /* 0x0000 = CACHE */
                                                 /* 0x0001 = NOCACHE LOGGING */
                                               /* 0x0002 = NOCACHE NOLOGGING */
                                             /* 0x0008 = CACHE READS LOGGING */
                                           /* 0x0010 = CACHE READS NOLOGGING */  
  defpro       number not null,                /* default partition property */
                                             /* 0x02 = enable storage in row */
  definiexts   number,   /* default INITIAL extent size; NULL if unspecified */
  defextsize   number,      /* default NEXT extent size; NULL if unspecified */
  defminexts   number,            /* default MINEXTENTS; NULL if unspecified */
  defmaxexts   number,            /* default MAXEXTENTS; NULL if unspecified */
  defextpct    number,           /* default PCTINCREASE; NULL if unspecified */
  deflists     number,       /* default FREELISTS value; NULL if unspecified */
  defgroups    number,       /* default FREELIST GROUPS; NULL if unspecified */
  defbufpool   number,           /* default BUFFER_POOL; NULL if unspecified */
  spare1       number,
  spare2       number,
  spare3       number       
)
/
create index i_lobcomppart_lobjpart$ on lobcomppart$(lobj#, part#)
/
create unique index i_lobcomppart$_partobj$ on lobcomppart$(partobj#)
/
rem
rem  FAMILY "TEMPLATE TABLES"
rem  Tables used to store information on tempaltes for composite partitioned 
rem  tables
rem
rem  defsubpart$ stores information on subpartition templates
create table defsubpart$ (
bo#            number not null,       /* Object number of table */
spart_position number,                /* subpartition position */
spart_name     varchar2(34) not null, /* name assigned by user */
ts#            number,                /* Default tablespace NULL if none */
flags          number,                
hiboundlen     number not null,      /* high bound text of this subpartition */
hiboundval     long,                 /* length of the text */  
bhiboundval    blob)                 /* binary form of high bound */
/
create unique index i_defsubpart$ on defsubpart$(bo#, spart_position)
/
rem
rem defsubpartlob$ stores information on lob subpartition templates
rem
create table defsubpartlob$ (
bo#            number not null,      /* object number of table */
intcol#        number not null,      /* column number of lob column */
spart_position number not null,      /* subpartition position */
flags          number,               /* Type of lob column */
                                     /* 0x01 varray */
                                     /* 0x02 opaque */
lob_spart_name varchar2(34) not null, /* segment name for lob subpartition */
lob_spart_ts#  number)                /* tablespace (if any) assigned */
/
create unique index i_defsubpartlob$ on defsubpartlob$ 
(bo#, intcol#, spart_position)
/
rem
rem  FAMILY "PRIVILEGE MAP"
rem  Tables for mapping privilege numbers to privilege names.
rem
rem  SYSTEM_PRIVILEGE_MAP maps a system privilege  number
rem  to the name.
rem
create table SYSTEM_PRIVILEGE_MAP (
        PRIVILEGE     number not null,
        NAME          varchar2(40) not null,
        PROPERTY      number not null /* 0x01 = do not export this privilege */
                                      /* using sql statements */
        )
/
comment on table SYSTEM_PRIVILEGE_MAP is
'Description table for privilege type codes.  Maps privilege  type numbers to type names'
/
comment on column SYSTEM_PRIVILEGE_MAP.PRIVILEGE is
'Numeric privilege type code'
/
comment on column SYSTEM_PRIVILEGE_MAP.NAME is
'Name of the type of privilege'
/
comment on column SYSTEM_PRIVILEGE_MAP.PROPERTY is
'Property flag of privilege like not export this privilege, etc'
/
insert into SYSTEM_PRIVILEGE_MAP values (-3, 'ALTER SYSTEM', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-4, 'AUDIT SYSTEM', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-5, 'CREATE SESSION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-6, 'ALTER SESSION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-7, 'RESTRICTED SESSION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-10, 'CREATE TABLESPACE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-11, 'ALTER TABLESPACE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-12, 'MANAGE TABLESPACE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-13, 'DROP TABLESPACE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-15, 'UNLIMITED TABLESPACE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-20, 'CREATE USER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-21, 'BECOME USER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-22, 'ALTER USER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-23, 'DROP USER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-30, 'CREATE ROLLBACK SEGMENT', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-31, 'ALTER ROLLBACK SEGMENT', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-32, 'DROP ROLLBACK SEGMENT', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-40, 'CREATE TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-41, 'CREATE ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-42, 'ALTER ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-43, 'BACKUP ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-44, 'DROP ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-45, 'LOCK ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-46, 'COMMENT ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-47, 'SELECT ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-48, 'INSERT ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-49, 'UPDATE ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-50, 'DELETE ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-60, 'CREATE CLUSTER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-61, 'CREATE ANY CLUSTER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-62, 'ALTER ANY CLUSTER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-63, 'DROP ANY CLUSTER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-71, 'CREATE ANY INDEX', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-72, 'ALTER ANY INDEX', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-73, 'DROP ANY INDEX', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-80, 'CREATE SYNONYM', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-81, 'CREATE ANY SYNONYM', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-82, 'DROP ANY SYNONYM', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-83, 'SYSDBA', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-84, 'SYSOPER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-85, 'CREATE PUBLIC SYNONYM', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-86, 'DROP PUBLIC SYNONYM', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-90, 'CREATE VIEW', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-91, 'CREATE ANY VIEW', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-92, 'DROP ANY VIEW', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-105, 'CREATE SEQUENCE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-106, 'CREATE ANY SEQUENCE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-107, 'ALTER ANY SEQUENCE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-108, 'DROP ANY SEQUENCE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-109, 'SELECT ANY SEQUENCE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-115, 'CREATE DATABASE LINK', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-120, 'CREATE PUBLIC DATABASE LINK', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-121, 'DROP PUBLIC DATABASE LINK', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-125, 'CREATE ROLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-126, 'DROP ANY ROLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-127, 'GRANT ANY ROLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-128, 'ALTER ANY ROLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-130, 'AUDIT ANY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-135, 'ALTER DATABASE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-138, 'FORCE TRANSACTION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-139, 'FORCE ANY TRANSACTION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-140, 'CREATE PROCEDURE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-141, 'CREATE ANY PROCEDURE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-142, 'ALTER ANY PROCEDURE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-143, 'DROP ANY PROCEDURE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-144, 'EXECUTE ANY PROCEDURE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-151, 'CREATE TRIGGER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-152, 'CREATE ANY TRIGGER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-153, 'ALTER ANY TRIGGER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-154, 'DROP ANY TRIGGER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-160, 'CREATE PROFILE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-161, 'ALTER PROFILE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-162, 'DROP PROFILE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-163, 'ALTER RESOURCE COST', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-165, 'ANALYZE ANY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-167, 'GRANT ANY PRIVILEGE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-172, 'CREATE MATERIALIZED VIEW', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-173, 'CREATE ANY MATERIALIZED VIEW', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-174, 'ALTER ANY MATERIALIZED VIEW', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-175, 'DROP ANY MATERIALIZED VIEW', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-177, 'CREATE ANY DIRECTORY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-178, 'DROP ANY DIRECTORY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-180, 'CREATE TYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-181, 'CREATE ANY TYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-182, 'ALTER ANY TYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-183, 'DROP ANY TYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-184, 'EXECUTE ANY TYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-186, 'UNDER ANY TYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-188, 'CREATE LIBRARY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-189, 'CREATE ANY LIBRARY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-190, 'ALTER ANY LIBRARY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-191, 'DROP ANY LIBRARY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-192, 'EXECUTE ANY LIBRARY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-200, 'CREATE OPERATOR', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-201, 'CREATE ANY OPERATOR', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-202, 'ALTER ANY OPERATOR', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-203, 'DROP ANY OPERATOR', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-204, 'EXECUTE ANY OPERATOR', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-205, 'CREATE INDEXTYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-206, 'CREATE ANY INDEXTYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-207, 'ALTER ANY INDEXTYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-208, 'DROP ANY INDEXTYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-209, 'UNDER ANY VIEW', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-210, 'QUERY REWRITE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-211, 'GLOBAL QUERY REWRITE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-212, 'EXECUTE ANY INDEXTYPE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-213, 'UNDER ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-214, 'CREATE DIMENSION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-215, 'CREATE ANY DIMENSION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-216, 'ALTER ANY DIMENSION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-217, 'DROP ANY DIMENSION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-218, 'MANAGE ANY QUEUE', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-219, 'ENQUEUE ANY QUEUE', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-220, 'DEQUEUE ANY QUEUE', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-222, 'CREATE ANY CONTEXT', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-223, 'DROP ANY CONTEXT', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-224, 'CREATE ANY OUTLINE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-225, 'ALTER ANY OUTLINE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-226, 'DROP ANY OUTLINE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-227, 'ADMINISTER RESOURCE MANAGER', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-228, 'ADMINISTER DATABASE TRIGGER',0);
insert into SYSTEM_PRIVILEGE_MAP values (-233, 'MERGE ANY VIEW', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-234, 'ON COMMIT REFRESH', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-235, 'EXEMPT ACCESS POLICY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-236, 'RESUMABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-237, 'SELECT ANY DICTIONARY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-238, 'DEBUG CONNECT SESSION', 0);
rem insert into SYSTEM_PRIVILEGE_MAP values (-239, 'DEBUG CONNECT USER', 0);
rem insert into SYSTEM_PRIVILEGE_MAP values (-240, 'DEBUG CONNECT ANY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-241, 'DEBUG ANY PROCEDURE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-243, 'FLASHBACK ANY TABLE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-244, 'GRANT ANY OBJECT PRIVILEGE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-245, 'CREATE EVALUATION CONTEXT', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-246, 'CREATE ANY EVALUATION CONTEXT',
                                         1);
insert into SYSTEM_PRIVILEGE_MAP values (-247, 'ALTER ANY EVALUATION CONTEXT',
                                         1);
insert into SYSTEM_PRIVILEGE_MAP values (-248, 'DROP ANY EVALUATION CONTEXT',
                                         1);
insert into SYSTEM_PRIVILEGE_MAP values (-249, 
                                         'EXECUTE ANY EVALUATION CONTEXT', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-250, 'CREATE RULE SET', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-251, 'CREATE ANY RULE SET', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-252, 'ALTER ANY RULE SET', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-253, 'DROP ANY RULE SET', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-254, 'EXECUTE ANY RULE SET', 1);

insert into SYSTEM_PRIVILEGE_MAP values (-255, 'EXPORT FULL DATABASE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-256, 'IMPORT FULL DATABASE', 0);

insert into SYSTEM_PRIVILEGE_MAP values (-257, 'CREATE RULE', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-258, 'CREATE ANY RULE', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-259, 'ALTER ANY RULE', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-260, 'DROP ANY RULE', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-261, 'EXECUTE ANY RULE', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-262, 'ANALYZE ANY DICTIONARY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-263, 'ADVISOR', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-264, 'CREATE JOB', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-265, 'CREATE ANY JOB', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-266, 'EXECUTE ANY PROGRAM', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-267, 'EXECUTE ANY CLASS', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-268, 'MANAGE SCHEDULER', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-269, 'SELECT ANY TRANSACTION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-270, 'DROP ANY SQL PROFILE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-271, 'ALTER ANY SQL PROFILE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-272, 'ADMINISTER SQL TUNING SET', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-273,
                                         'ADMINISTER ANY SQL TUNING SET', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-274, 'CREATE ANY SQL PROFILE', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-275, 'EXEMPT IDENTITY POLICY', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-276, 'MANAGE FILE GROUP', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-277, 'MANAGE ANY FILE GROUP', 1);
insert into SYSTEM_PRIVILEGE_MAP values (-278, 'READ ANY FILE GROUP', 1);
insert into  SYSTEM_PRIVILEGE_MAP values (-279, 'CHANGE NOTIFICATION', 0);
insert into SYSTEM_PRIVILEGE_MAP values (-280, 'CREATE EXTERNAL JOB',0);

create unique index I_SYSTEM_PRIVILEGE_MAP
        on SYSTEM_PRIVILEGE_MAP (PRIVILEGE, NAME)
/
create public synonym SYSTEM_PRIVILEGE_MAP for SYSTEM_PRIVILEGE_MAP
/
grant select on SYSTEM_PRIVILEGE_MAP to public with grant option
/
rem
rem  TABLE_PRIVILEGE_MAP maps a table privilege (auditing option) number
rem  to the name.
rem
create table TABLE_PRIVILEGE_MAP (
        PRIVILEGE       number not null,
        NAME            varchar2(40) not null)
/
comment on table TABLE_PRIVILEGE_MAP is
'Description table for privilege (auditing option) type codes.  Maps privilege (auditing option) type numbers to type names'
/
comment on column TABLE_PRIVILEGE_MAP.PRIVILEGE is
'Numeric privilege (auditing option) type code'
/
comment on column TABLE_PRIVILEGE_MAP.NAME is
'Name of the type of privilege (auditing option)'
/
insert into TABLE_PRIVILEGE_MAP values (0, 'ALTER');
insert into TABLE_PRIVILEGE_MAP values (1, 'AUDIT');
insert into TABLE_PRIVILEGE_MAP values (2, 'COMMENT');
insert into TABLE_PRIVILEGE_MAP values (3, 'DELETE');
insert into TABLE_PRIVILEGE_MAP values (4, 'GRANT');
insert into TABLE_PRIVILEGE_MAP values (5, 'INDEX');
insert into TABLE_PRIVILEGE_MAP values (6, 'INSERT');
insert into TABLE_PRIVILEGE_MAP values (7, 'LOCK');
insert into TABLE_PRIVILEGE_MAP values (8, 'RENAME');
insert into TABLE_PRIVILEGE_MAP values (9, 'SELECT');
insert into TABLE_PRIVILEGE_MAP values (10, 'UPDATE');
insert into TABLE_PRIVILEGE_MAP values (11, 'REFERENCES');
insert into TABLE_PRIVILEGE_MAP values (12, 'EXECUTE');
insert into TABLE_PRIVILEGE_MAP values (16, 'CREATE');
insert into TABLE_PRIVILEGE_MAP values (17, 'READ');
insert into TABLE_PRIVILEGE_MAP values (18, 'WRITE');
insert into TABLE_PRIVILEGE_MAP values (20, 'ENQUEUE');
insert into TABLE_PRIVILEGE_MAP values (21, 'DEQUEUE');
insert into TABLE_PRIVILEGE_MAP values (22, 'UNDER');
insert into TABLE_PRIVILEGE_MAP values (23, 'ON COMMIT REFRESH');
insert into TABLE_PRIVILEGE_MAP values (24, 'QUERY REWRITE');
rem ?? UPSERT missing?
insert into TABLE_PRIVILEGE_MAP values (26, 'DEBUG');
insert into TABLE_PRIVILEGE_MAP values (27, 'FLASHBACK');
insert into TABLE_PRIVILEGE_MAP values (28, 'MERGE VIEW');

create unique index I_TABLE_PRIVILEGE_MAP
        on TABLE_PRIVILEGE_MAP (PRIVILEGE, NAME)
/
create public synonym TABLE_PRIVILEGE_MAP for TABLE_PRIVILEGE_MAP
/
grant select on TABLE_PRIVILEGE_MAP to public with grant option
/
rem
rem  FAMILY "OPTION MAP"
rem     Tables for mapping auditing option numbers to auditing 
rem  the name.
rem
rem  STMT_AUDIT_OPTION_MAP maps a auditing option number to the name.
rem
create table STMT_AUDIT_OPTION_MAP (
        OPTION#         number not null,
        NAME            varchar2(40) not null,
        PROPERTY        number not null  /* 0x01 = do not export this audit */
                                         /* option using sql statements */
)
/
comment on table STMT_AUDIT_OPTION_MAP is
'Description table for auditing option type codes.  Maps auditing option type numbers to type names'
/
comment on column STMT_AUDIT_OPTION_MAP.OPTION# is
'Numeric auditing option type code'
/
comment on column STMT_AUDIT_OPTION_MAP.NAME is
'Name of the type of auditing option'
/
comment on column STMT_AUDIT_OPTION_MAP.PROPERTY is
'Property flag of auditing option'
/
insert into STMT_AUDIT_OPTION_MAP values (  3, 'ALTER SYSTEM', 0);
insert into STMT_AUDIT_OPTION_MAP values (  4, 'SYSTEM AUDIT', 0);
insert into STMT_AUDIT_OPTION_MAP values (  5, 'CREATE SESSION', 0);
insert into STMT_AUDIT_OPTION_MAP values (  6, 'ALTER SESSION', 0);
insert into STMT_AUDIT_OPTION_MAP values (  7, 'RESTRICTED SESSION', 0);
insert into STMT_AUDIT_OPTION_MAP values (  8, 'TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values (  9, 'CLUSTER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 10, 'CREATE TABLESPACE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 11, 'ALTER TABLESPACE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 12, 'MANAGE TABLESPACE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 13, 'DROP TABLESPACE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 14, 'TABLESPACE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 15, 'UNLIMITED TABLESPACE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 16, 'USER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 17, 'ROLLBACK SEGMENT', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 18, 'TYPE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 19, 'INDEX', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 20, 'CREATE USER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 21, 'BECOME USER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 22, 'ALTER USER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 23, 'DROP USER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 24, 'SYNONYM', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 25, 'PUBLIC SYNONYM', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 26, 'VIEW', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 27, 'SEQUENCE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 28, 'DATABASE LINK', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 29, 'PUBLIC DATABASE LINK', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 30, 'CREATE ROLLBACK SEGMENT', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 31, 'ALTER ROLLBACK SEGMENT', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 32, 'DROP ROLLBACK SEGMENT', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 33, 'ROLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 34, 'DIMENSION', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 35, 'PROCEDURE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 36, 'TRIGGER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 37, 'PROFILE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 38, 'DIRECTORY', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 39, 'MATERIALIZED VIEW', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 40, 'CREATE TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 41, 'CREATE ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 42, 'ALTER ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 43, 'BACKUP ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 44, 'DROP ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 45, 'LOCK ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 46, 'COMMENT ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 47, 'SELECT ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 48, 'INSERT ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 49, 'UPDATE ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 50, 'DELETE ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 60, 'CREATE CLUSTER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 61, 'CREATE ANY CLUSTER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 62, 'ALTER ANY CLUSTER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 63, 'DROP ANY CLUSTER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 71, 'CREATE ANY INDEX', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 72, 'ALTER ANY INDEX', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 73, 'DROP ANY INDEX', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 80, 'CREATE SYNONYM', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 81, 'CREATE ANY SYNONYM', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 82, 'DROP ANY SYNONYM', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 83, 'SYSDBA', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 84, 'SYSOPER', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 85, 'CREATE PUBLIC SYNONYM', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 86, 'DROP PUBLIC SYNONYM', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 90, 'CREATE VIEW', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 91, 'CREATE ANY VIEW', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 92, 'DROP ANY VIEW', 0);
insert into STMT_AUDIT_OPTION_MAP values (105, 'CREATE SEQUENCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (106, 'CREATE ANY SEQUENCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (107, 'ALTER ANY SEQUENCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (108, 'DROP ANY SEQUENCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (109, 'SELECT ANY SEQUENCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (111, 'GRANT SEQUENCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (115, 'CREATE DATABASE LINK', 0);
insert into STMT_AUDIT_OPTION_MAP values (120, 'CREATE PUBLIC DATABASE LINK', 0);
insert into STMT_AUDIT_OPTION_MAP values (121, 'DROP PUBLIC DATABASE LINK', 0);
insert into STMT_AUDIT_OPTION_MAP values (125, 'CREATE ROLE', 0);
insert into STMT_AUDIT_OPTION_MAP values (126, 'DROP ANY ROLE', 0);
insert into STMT_AUDIT_OPTION_MAP values (127, 'GRANT ANY ROLE', 0);
insert into STMT_AUDIT_OPTION_MAP values (128, 'ALTER ANY ROLE', 0);
insert into STMT_AUDIT_OPTION_MAP values (130, 'AUDIT ANY', 0);
insert into STMT_AUDIT_OPTION_MAP values (131, 'SYSTEM GRANT', 0);
insert into STMT_AUDIT_OPTION_MAP values (135, 'ALTER DATABASE', 0);
insert into STMT_AUDIT_OPTION_MAP values (138, 'FORCE TRANSACTION', 0);
insert into STMT_AUDIT_OPTION_MAP values (139, 'FORCE ANY TRANSACTION', 0);
insert into STMT_AUDIT_OPTION_MAP values (140, 'CREATE PROCEDURE', 0);
insert into STMT_AUDIT_OPTION_MAP values (141, 'CREATE ANY PROCEDURE', 0);
insert into STMT_AUDIT_OPTION_MAP values (142, 'ALTER ANY PROCEDURE', 0);
insert into STMT_AUDIT_OPTION_MAP values (143, 'DROP ANY PROCEDURE', 0);
insert into STMT_AUDIT_OPTION_MAP values (144, 'EXECUTE ANY PROCEDURE', 0);
insert into STMT_AUDIT_OPTION_MAP values (146, 'EXECUTE PROCEDURE', 0);
insert into STMT_AUDIT_OPTION_MAP values (147, 'GRANT PROCEDURE', 0);
insert into STMT_AUDIT_OPTION_MAP values (151, 'CREATE TRIGGER', 0);
insert into STMT_AUDIT_OPTION_MAP values (152, 'CREATE ANY TRIGGER', 0);
insert into STMT_AUDIT_OPTION_MAP values (153, 'ALTER ANY TRIGGER', 0);
insert into STMT_AUDIT_OPTION_MAP values (154, 'DROP ANY TRIGGER', 0);
insert into STMT_AUDIT_OPTION_MAP values (157, 'CREATE DIRECTORY', 0);
insert into STMT_AUDIT_OPTION_MAP values (158, 'DROP DIRECTORY', 0);
insert into STMT_AUDIT_OPTION_MAP values (160, 'CREATE PROFILE', 0);
insert into STMT_AUDIT_OPTION_MAP values (161, 'ALTER PROFILE', 0);
insert into STMT_AUDIT_OPTION_MAP values (162, 'DROP PROFILE', 0);
insert into STMT_AUDIT_OPTION_MAP values (163, 'ALTER RESOURCE COST', 0);
insert into STMT_AUDIT_OPTION_MAP values (165, 'ANALYZE ANY', 0);
insert into STMT_AUDIT_OPTION_MAP values (167, 'GRANT ANY PRIVILEGE', 0);
insert into STMT_AUDIT_OPTION_MAP values (172, 'CREATE MATERIALIZED VIEW', 0);
insert into STMT_AUDIT_OPTION_MAP values (173, 'CREATE ANY MATERIALIZED VIEW', 0);
insert into STMT_AUDIT_OPTION_MAP values (174, 'ALTER ANY MATERIALIZED VIEW', 0);
insert into STMT_AUDIT_OPTION_MAP values (175, 'DROP ANY MATERIALIZED VIEW', 0);
insert into STMT_AUDIT_OPTION_MAP values (176, 'NETWORK', 0);
insert into STMT_AUDIT_OPTION_MAP values (177, 'CREATE ANY DIRECTORY', 0);
insert into STMT_AUDIT_OPTION_MAP values (178, 'DROP ANY DIRECTORY', 0);
insert into STMT_AUDIT_OPTION_MAP values (179, 'GRANT DIRECTORY', 0);
insert into STMT_AUDIT_OPTION_MAP values (180, 'CREATE TYPE', 0);
insert into STMT_AUDIT_OPTION_MAP values (181, 'CREATE ANY TYPE', 0);
insert into STMT_AUDIT_OPTION_MAP values (182, 'ALTER ANY TYPE', 0);
insert into STMT_AUDIT_OPTION_MAP values (183, 'DROP ANY TYPE', 0);
insert into STMT_AUDIT_OPTION_MAP values (184, 'EXECUTE ANY TYPE', 0);
insert into STMT_AUDIT_OPTION_MAP values (185, 'GRANT LIBRARY', 0);
insert into STMT_AUDIT_OPTION_MAP values (187, 'GRANT TYPE', 0);
insert into STMT_AUDIT_OPTION_MAP values (188, 'CREATE LIBRARY', 0);
insert into STMT_AUDIT_OPTION_MAP values (189, 'CREATE ANY LIBRARY', 0);
insert into STMT_AUDIT_OPTION_MAP values (190, 'ALTER ANY LIBRARY', 0);
insert into STMT_AUDIT_OPTION_MAP values (191, 'DROP ANY LIBRARY', 0);
insert into STMT_AUDIT_OPTION_MAP values (192, 'EXECUTE ANY LIBRARY', 0);
insert into STMT_AUDIT_OPTION_MAP values (193, 'EXECUTE LIBRARY', 0);
insert into STMT_AUDIT_OPTION_MAP values (210, 'QUERY REWRITE', 0);
insert into STMT_AUDIT_OPTION_MAP values (211, 'GLOBAL QUERY REWRITE', 0);
insert into STMT_AUDIT_OPTION_MAP values (214, 'CREATE DIMENSION', 0);
insert into STMT_AUDIT_OPTION_MAP values (215, 'CREATE ANY DIMENSION', 0);
insert into STMT_AUDIT_OPTION_MAP values (216, 'ALTER ANY DIMENSION', 0);
insert into STMT_AUDIT_OPTION_MAP values (217, 'DROP ANY DIMENSION', 0);
insert into STMT_AUDIT_OPTION_MAP values (218, 'MANAGE ANY QUEUE', 0);
insert into STMT_AUDIT_OPTION_MAP values (219, 'ENQUEUE ANY QUEUE', 0);
insert into STMT_AUDIT_OPTION_MAP values (220, 'DEQUEUE ANY QUEUE', 0);
insert into STMT_AUDIT_OPTION_MAP values (222, 'CREATE ANY CONTEXT', 0);
insert into STMT_AUDIT_OPTION_MAP values (223, 'DROP ANY CONTEXT', 0);
insert into STMT_AUDIT_OPTION_MAP values (224, 'CREATE ANY OUTLINE', 0);
insert into STMT_AUDIT_OPTION_MAP values (225, 'ALTER ANY OUTLINE', 0);
insert into STMT_AUDIT_OPTION_MAP values (226, 'DROP ANY OUTLINE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 77, 'NOT EXISTS', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 87, 'EXISTS', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 54, 'ALTER TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 57, 'LOCK TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 58, 'COMMENT TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 65, 'SELECT TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 66, 'INSERT TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 67, 'UPDATE TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 68, 'DELETE TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values ( 69, 'GRANT TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values (103, 'ALTER SEQUENCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (104, 'SELECT SEQUENCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (221, 'CONTEXT', 0);
insert into STMT_AUDIT_OPTION_MAP values (233, 'MERGE ANY VIEW', 0);
insert into STMT_AUDIT_OPTION_MAP values (234, 'ON COMMIT REFRESH', 0);
insert into STMT_AUDIT_OPTION_MAP values (235, 'EXEMPT ACCESS POLICY', 0);
insert into STMT_AUDIT_OPTION_MAP values (236, 'RESUMABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values (237, 'SELECT ANY DICTIONARY', 0);
insert into STMT_AUDIT_OPTION_MAP values (238, 'DEBUG CONNECT SESSION', 0);
rem insert into STMT_AUDIT_OPTION_MAP values (239, 'DEBUG CONNECT USER', 0);
rem insert into STMT_AUDIT_OPTION_MAP values (240, 'DEBUG CONNECT ANY', 0);
insert into STMT_AUDIT_OPTION_MAP values (241, 'DEBUG ANY PROCEDURE', 0);
insert into STMT_AUDIT_OPTION_MAP values (242, 'DEBUG PROCEDURE', 0);
insert into STMT_AUDIT_OPTION_MAP values (243, 'FLASHBACK ANY TABLE', 0);
insert into STMT_AUDIT_OPTION_MAP values (244, 'GRANT ANY OBJECT PRIVILEGE',0);
insert into STMT_AUDIT_OPTION_MAP values (245, 'CREATE EVALUATION CONTEXT', 0);
insert into STMT_AUDIT_OPTION_MAP
   values (246, 'CREATE ANY EVALUATION CONTEXT', 0);
insert into STMT_AUDIT_OPTION_MAP
   values (247, 'ALTER ANY EVALUATION CONTEXT', 0);
insert into STMT_AUDIT_OPTION_MAP
   values (248, 'DROP ANY EVALUATION CONTEXT', 0);
insert into STMT_AUDIT_OPTION_MAP
   values (249, 'EXECUTE ANY EVALUATION CONTEXT', 0);
insert into STMT_AUDIT_OPTION_MAP values (250, 'CREATE RULE SET', 0);
insert into STMT_AUDIT_OPTION_MAP values (251, 'CREATE ANY RULE SET', 0);
insert into STMT_AUDIT_OPTION_MAP values (252, 'ALTER ANY RULE SET', 0);
insert into STMT_AUDIT_OPTION_MAP values (253, 'DROP ANY RULE SET', 0);
insert into STMT_AUDIT_OPTION_MAP values (254, 'EXECUTE ANY RULE SET', 0);
insert into STMT_AUDIT_OPTION_MAP values (255, 'EXPORT FULL DATABASE',0);
insert into STMT_AUDIT_OPTION_MAP values (256, 'IMPORT FULL DATABASE',0);
insert into STMT_AUDIT_OPTION_MAP values (257, 'CREATE RULE', 0);
insert into STMT_AUDIT_OPTION_MAP values (258, 'CREATE ANY RULE', 0);
insert into STMT_AUDIT_OPTION_MAP values (259, 'ALTER ANY RULE', 0);
insert into STMT_AUDIT_OPTION_MAP values (260, 'DROP ANY RULE', 0);
insert into STMT_AUDIT_OPTION_MAP values (261, 'EXECUTE ANY RULE', 0);
insert into STMT_AUDIT_OPTION_MAP values (262, 'ANALYZE ANY DICTIONARY', 0);
insert into STMT_AUDIT_OPTION_MAP values (263, 'ADVISOR',0);
insert into STMT_AUDIT_OPTION_MAP values (264, 'CREATE JOB', 0);
insert into STMT_AUDIT_OPTION_MAP values (265, 'CREATE ANY JOB', 0);
insert into STMT_AUDIT_OPTION_MAP values (266, 'EXECUTE ANY PROGRAM', 0);
insert into STMT_AUDIT_OPTION_MAP values (267, 'EXECUTE ANY CLASS', 0);
insert into STMT_AUDIT_OPTION_MAP values (268, 'MANAGE SCHEDULER', 0);
insert into STMT_AUDIT_OPTION_MAP values (269, 'SELECT ANY TRANSACTION', 0);
insert into STMT_AUDIT_OPTION_MAP values (270, 'DROP ANY SQL PROFILE',0);
insert into STMT_AUDIT_OPTION_MAP values (271, 'ALTER ANY SQL PROFILE',0);
insert into STMT_AUDIT_OPTION_MAP values (272, 'ADMINISTER SQL TUNING SET', 0);
insert into STMT_AUDIT_OPTION_MAP values (273,
                                          'ADMINISTER ANY SQL TUNING SET', 0);
insert into STMT_AUDIT_OPTION_MAP values (274, 'CREATE ANY SQL PROFILE',0);
insert into STMT_AUDIT_OPTION_MAP values (275, 'EXEMPT IDENTITY POLICY', 0);
insert into STMT_AUDIT_OPTION_MAP values (276, 'MANAGE FILE GROUP', 0);
insert into STMT_AUDIT_OPTION_MAP values (277, 'MANAGE ANY FILE GROUP', 0);
insert into STMT_AUDIT_OPTION_MAP values (278, 'READ ANY FILE GROUP', 0);
insert into STMT_AUDIT_OPTION_MAP values (279, 'CHANGE NOTIFICATION', 0);
insert into STMT_AUDIT_OPTION_MAP values (280, 'CREATE EXTERNAL JOB', 0);
insert into STMT_AUDIT_OPTION_MAP values (93, 'CREATE JAVA SOURCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (94, 'CREATE JAVA CLASS', 0);
insert into STMT_AUDIT_OPTION_MAP values (95, 'CREATE JAVA RESOURCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (96, 'ALTER JAVA SOURCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (97, 'ALTER JAVA CLASS', 0);
insert into STMT_AUDIT_OPTION_MAP values (98, 'ALTER JAVA RESOURCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (99, 'DROP JAVA SOURCE', 0);
insert into STMT_AUDIT_OPTION_MAP values (100, 'DROP JAVA CLASS', 0);
insert into STMT_AUDIT_OPTION_MAP values (101, 'DROP JAVA RESOURCE', 0);

create unique index I_STMT_AUDIT_OPTION_MAP
        on STMT_AUDIT_OPTION_MAP (OPTION#, NAME)
/
create public synonym  STMT_AUDIT_OPTION_MAP for STMT_AUDIT_OPTION_MAP
/
grant select on STMT_AUDIT_OPTION_MAP to public
/
remark
remark FAMILY "RESOURCE PROFILES"
remark
create table RESOURCE_MAP (
        RESOURCE#       number not null,
        TYPE#           number not null,
        NAME            varchar2(32) not null)
/
comment on table RESOURCE_MAP is
'Description table for resources.  Maps resource name to number'
/
comment on column RESOURCE_MAP.RESOURCE# is
'Numeric resource code'
/
comment on column RESOURCE_MAP.NAME is
'Name of resource'
/
insert into resource_map values ( 0, 0, 'COMPOSITE_LIMIT' );
insert into resource_map values ( 1, 0, 'SESSIONS_PER_USER' );
insert into resource_map values ( 2, 0, 'CPU_PER_SESSION' );
insert into resource_map values ( 3, 0, 'CPU_PER_CALL' );
insert into resource_map values ( 4, 0, 'LOGICAL_READS_PER_SESSION' );
insert into resource_map values ( 5, 0, 'LOGICAL_READS_PER_CALL' );
insert into resource_map values ( 6, 0, 'IDLE_TIME' );
insert into resource_map values ( 7, 0, 'CONNECT_TIME' );
insert into resource_map values ( 8, 0, 'PRIVATE_SGA' );
insert into resource_map values ( 0, 1, 'FAILED_LOGIN_ATTEMPTS' );
insert into resource_map values ( 1, 1, 'PASSWORD_LIFE_TIME' );
insert into resource_map values ( 2, 1, 'PASSWORD_REUSE_TIME' );
insert into resource_map values ( 3, 1, 'PASSWORD_REUSE_MAX' );
insert into resource_map values ( 4, 1, 'PASSWORD_VERIFY_FUNCTION' );
insert into resource_map values ( 5, 1, 'PASSWORD_LOCK_TIME' );
insert into resource_map values ( 6, 1, 'PASSWORD_GRACE_TIME' )
/
create table user_astatus_map
( status#  number not null, 
  status  varchar2(32) not null)
/
insert into user_astatus_map values (0, 'OPEN');
insert into user_astatus_map values (1, 'EXPIRED');
insert into user_astatus_map values (2, 'EXPIRED(GRACE)');
insert into user_astatus_map values (4, 'LOCKED(TIMED)');
insert into user_astatus_map values (8, 'LOCKED');
insert into user_astatus_map values (5, 'EXPIRED & LOCKED(TIMED)');
insert into user_astatus_map values (6, 'EXPIRED(GRACE) & LOCKED(TIMED)');
insert into user_astatus_map values (9, 'EXPIRED & LOCKED');
insert into user_astatus_map values (10, 'EXPIRED(GRACE) & LOCKED')
/
create role select_catalog_role
/
create role execute_catalog_role
/
create role delete_catalog_role
/
grant select_catalog_role to dba with admin option
/
grant execute_catalog_role to dba with admin option
/
grant delete_catalog_role to dba with admin option
/
create role exp_full_database
/
create role imp_full_database
/
grant select_catalog_role to exp_full_database
/
grant select_catalog_role to imp_full_database
/
grant execute_catalog_role to imp_full_database
/
grant execute_catalog_role to exp_full_database
/
create table expact$
( owner         varchar2("M_IDEN") not null,              /* owner of object */
  name          varchar2("M_IDEN") not null,               /* name of object */
  func_schema   varchar2("M_IDEN") not null,     /* schema func is run under */
  func_package  varchar2("M_IDEN") not null,                 /* package name */
  func_proc     varchar2("M_IDEN") not null,               /* procedure name */
  code          number not null,                    /* PRETABLE OR POSTTABLE */
  callorder     number,
  callarg       varchar2(1),        /* whether this function takes arguments */
                              /* or not.  Null - no arguments; Y - pass arg. */
  obj_type number not null,                 /* type of object to be exported */
  user_arg varchar2(2000)              /* user arguments for pkg, proc, func */
)                               
/
create table noexp$
( owner varchar2("M_IDEN") not null,                       /* owner of table */
  name  varchar2("M_IDEN") not null,                        /* name of table */
  obj_type number not null              /* type of object NOT to be exported */
)
/
create unique index i_parameter1 on
  parameter$(toid, version#, method#, name)
/
create unique index i_parameter2 on
  parameter$(toid, version#, method#, parameter#)
/
create table procedurejava$
( obj#          number not null,                 /* spec/body object number */
  procedure#    number not null,                  /* procedure# or position */
  ownername     varchar2("M_IDEN") not null,            /* class owner name */
  ownerlength   number not null,              /* length of class owner name */
  usersignature varchar2("M_VCSZ"),              /* User signature for java */
  usersiglen    number,                /* Length of user signature for java */
  classname     varchar2("M_VCSZ") not null,           /* method class name */
  classlength   number not null,             /* length of method class name */
  methodname    varchar2("M_VCSZ") not null,            /* java method name */
  methodlength  number not null,              /* length of java method name */
  signature     long not null,                        /* internal signature */
  siglength     number not null,            /* length of internal signature */
  flags         varchar2("M_VCSZ") not null,              /* internal flags */
              /* WE MIGHT BE ABLE TO USE M_CSIZ here, check max# parameters */
  flagslength   number not null,                /* length of internal flags */
  cookiesize    number)                                      /* cookie size */
/
create unique index i_procedurejava$ on procedurejava$ (obj#, procedure#)
/
create table procedurec$
( obj#          number not null,                 /* spec/body object number */
  procedure#    number not null,                  /* procedure# or position */
  entrypoint#   number not null)                 /* entrypoint table entry# */
/
create unique index i_procedurec$ on procedurec$ (obj#, procedure#)
/
create table procedureplsql$
( obj#          number not null,                 /* spec/body object number */
  procedure#    number not null,                  /* procedure# or position */
  entrypoint#   number not null)                 /* entrypoint table entry# */
/
create unique index i_procedureplsql$ on procedureplsql$ (obj#, procedure#)
/
create table result$                                  /* method result table */
( toid          raw(16) not null,                                    /* TOID */
  version#      number not null,             /* internal type version number */
  method#       number not null,                /* method number or position */
  result#       number not null,                /* result number or position */
  result_toid   raw(16) not null,                           /* result's TOID */
  result_version# number not null,
                                  /* result's type's internal version number */
  synobj#       number,                              /* obj# of type synonym */
  properties    number not null,                     /* result's properties: */
  /* 0x4000 =   16384 = is a PONTER result */ 
  /* 0x8000 =   32768 = is a REF result */
  /* Following length, precision, scale, upper_bound, char_set_id are NOT USED
     in V8.0, but maybe supported in the future. */
  charsetid     number,                                  /* character set id */
  charsetform   number,                                /* character set form */
  /* 1 = implicit: for CHAR, VARCHAR2, CLOB w/o a specified set */
  /* 2 = nchar: for NCHAR, NCHAR VARYING, NCLOB */
  /* 3 = explicit: for CHAR, etc. with "CHARACTER SET ..." clause */
  /* 4 = flexible: for PL/SQL "flexible" parameters */
  spare1        number,
  spare2        number,
  spare3        number)
cluster c_toid_version#(toid, version#)
                                 /* keys: (toid, version#, method#, result#) */
/
create unique index i_result1 on
  result$(toid, version#, method#, result#)
/
create table kottd$ of kottd                           /* primary type table */
  oid '00000000000000000000000000010001'
/
create table kottb$ of kottb                         /* secondary type table */
  oid '00000000000000000000000000010002'
/
create table kotad$ of kotad                    /* attribute/parameter table */
  oid '00000000000000000000000000010003'
/
create table kotmd$ of kotmd                       /* method signature table */
  oid '00000000000000000000000000010004'
/
create table kottbx$ of kottbx                      /* additional type table */
  oid '00000000000000000000000000010042'
/
create table kotadx$ of kotadx                 /* additional attr info table */
  oid '00000000000000000000000000010043'
/
create table kopm$                                         /* metadata table */
( 
  name          varchar2("M_IDEN") not null,                /* metadata name */
  length        number not null,                          /* metadata length */
  metadata      raw(255))                                        /* metadata */
/
create unique index i_kopm1 on kopm$ (name)
/
create table vtable$                                               /* vtable */
(
  obj#          number not null,               /* object number of type spec */
  vindex        number not null,                             /* vtable index */
  itypetoid     raw(16),                         /* implementation type toid */
  itypeowner    varchar2("M_IDEN"),   /* owner name component of implem type */
  itypename     varchar2("M_IDEN"),                      /* implem type name */
  imethod#      number not null,           /* method# in implementation type */
  iflags        number)                              /* implementation flags */
/
rem create unique index i_vtable1 on vtable$(obj#, vindex)
/

create global temporary table atemptab$                     /* see atempind$ */
(
  id    number
)
/
comment on table ATEMPTAB$ is
'Temporary table whose definition is used internally.  Never contains data'
/
create index atempind$ on atemptab$(id) 
/             /* indexes backing up workspaces on disk claim to be atempind$ */

create table library$
( obj#          number not null,             /* object number of the library */
  filespec      varchar2(2000),
                        /* the actual file spec - NULL if property is STATIC */
  property      number,                     /* 0x01 = STATIC, 0x02 = TRUSTED */
  audit$        varchar2("S_OPFL") not null              /* auditing options */
)
cluster c_obj#(obj#)
/
create table user_history$ 
( user# number not null,   /* user number; this mapping is for (user$.user#) */
  password  varchar2("M_IDEN"),                      /* password of the user */
  password_date date                        /* date the password was entered */
);
/
create table migrate$
( version#   varchar2("M_IDEN"),                    /* version migrated from */
  migdate    date,              /* date the migration from v7->v8 took place */
  migrated   number not null     /* 0=not migrated, 1=migrated from v7 to v8 */
)
/
insert into migrate$ values (NULL, NULL, 0)
/
/* if icoldep$ is empty for an index, the index depends on the cols in icol$ */
create table icoldep$                   /* which columns an index depends on */
( obj#          number not null,                                 /* index id */
  bo#           number not null,                                 /* table id */
  intcol#       number not null    /* intcol# in table that index depends on */
)
cluster c_obj#(bo#)
/
create index i_icoldep$_obj on icoldep$ (obj#)
/
create table operator$
( obj#          number not null,                            /* object number */
  numbind       number not null,                       /* number of bindings */
  nextbindnum   number not null,             /* Next bind no. to be assigned */
  property      number not null                             /* property flag */
)
/
create unique index oper1 on operator$(obj#)
/
create table opbinding$
( obj#          number not null,                     /* obj# of the operator */
  bind#         number not null,                                 /* binding# */
  functionname  varchar2(92),                 /* function name in form A.B.C */
  returnschema  varchar2("M_IDEN"),      /* schema of return type (for ADTs) */
  returntype    varchar2("M_IDEN"),              /* return type of binding   */
  impschema     varchar2("M_IDEN"),       /* indextype implementation schema */
  imptype       varchar2("M_IDEN"),         /* indextype implementation type */
  property      number not null,                            /* property flag */
                                                /* 0x01 = WITH INDEX CONTEXT */
                                             /* 0x02 = RETURN ANCILLARY DATA */
                                                      /* 0x04 = ANCILLARY TO */
                                               /* 0x08 = WITHOUT COLUMN DATA */
                                               /* 0x10 = WITH COLUMN CONTEXT */
  spare1        varchar2("M_IDEN"),
  spare2        varchar2("M_IDEN"),
  spare3        number
)
/
create unique index opbind1 on opbinding$(obj#,bind#)
/
create table opancillary$
( obj#      number not null,          /* object number of ancillary operator */
  bind#     number not null,            /* bind number of ancillary operator */
  primop#   number not null,            /* object number of primary operator */
  primbind# number not null               /* bind number of primary operator */
)
/
create index opanc1 on opancillary$(obj#,bind#)
/
create table oparg$
( obj#          number not null,                     /* obj# of the operator */
  bind#         number not null,                                 /* binding# */
  position      number not null,                    /* position of arguments */
  type          varchar2(61)                     /* datatype of the argument */
)
/
create index oparg1 on oparg$(obj#)
/
create table indtypes$
( obj#                  number not null,                  /* indextype obj# */
  implobj#              number not null,  /* implementation type object num */
  property              number not null,                        /* property */
                                              /* 0x0001 WITHOUT_COLUMN_DATA */
                                                   /* 0x0002 WITH_ARRAY_DML */ 
                                              /* 0x0004 WITH_REBUILD_ONLINE */
                                                     /* 0x0008 HAS_ORDER_BY */
                                       /* 0x0010 WITH LOCAL_RANGE_PARTITION */
                                        /* 0x0020 WITH LOCAL_HASH_PARTITION */ 
                                                      /* 0x0040 WITHOUT_DML */ 
                                              /* 0x0080 AUTHID_CURRENT_USER */ 
  interface_version#    number           /* versi# of interface implemented */
)
/
create table indop$
( obj#          number not null,                         /* indextype object */
  oper#         number not null,          /* obj# for operator schema object */
  bind#         number not null,                         /* operator binding */
  property      number not null,                           /* property flags */
                                 /* 0x01 = INEXACT match ... look for filter */
  filt_nam      varchar2("M_IDEN"),           /* name of the filter function */
  filt_sch      varchar2("M_IDEN"),         /* schema of the filter function */
  filt_typ      varchar2("M_IDEN") /* type or package of the filter function */ 
)
/
create table indarraytype$
( obj#                  number not null,                   /* indextype obj# */
  type                  number not null,      /* data type of indexed column */
                                           /* for ADT column, type# = DTYADT */
  basetypeobj#          number,        /* object number of user-defined type */
  arraytypeobj#         number not null,      /* object number of array type */
  spare1                number,
  spare2                number
)
/
create table secobj$ 
(
 obj#     number  not null,                       /* object number of index */
 secobj#  number  not null,           /* object number for secondary object */
 spare1   number, 
 spare2   number
)
/
create table association$
(
  obj#            number not null,    /* obj# of table, type, pkg or func */
  property        number not null,     /* 1-column, 2-type, 3-pkg, 4-func */
                                                      /* 5-idx, 6-idxtype */
  intcol#         number,            /* intcol# if association for column */
  statstype#      number,        /* object number for the statistics type */
  default_selectivity  number,                     /* default selectivity */
  default_cpu_cost     number,                       /* defaault CPU cost */
  default_io_cost      number,                        /* default i/o cost */
  default_net_cost     number,                    /* default network cost */
  interface_version#   number,     /* version# of the statstype interface */
  spare2               number
)
/
create unique index assoc1 on association$(obj#, intcol#)
/
create index assoc2 on association$(statstype#)
/
create table ustats$
(
  obj#            number  not null,    /* obj# for table(column) or index */
  intcol#         number,                  /* intcol# if stats for column */
  statstype#      number,                  /* obj# of the statistics type */
  property        number,      /* 1-index, 2-column, 3-implicit, 4-direct */
  statistics      raw("M_CSIZ"),              /* uninterpreted statistics */
  spare1          number,
  spare2          number
)
/
create unique index ustats1 on ustats$(obj#, intcol#)
/
create table javasnm$
( short         varchar2("M_IDEN") not null,       /* shortened form of name */
  longname      long raw not null,                      /* long form of name */
  longdbcs      varchar2(4000)
)
/
create unique index i_javasnm1 on javasnm$ (short)
/
create table sum$                                           /* summary table */
( obj#             number not null,                         /* object number */
  containerobj#    number not null,    /* object number of the container tab */
  containertype    number not null,       /* type of container - snap, table */
  containernam     varchar2("M_IDEN"),                  /* name of container */
  fullrefreshtim   number,             /* number in seconds for full refresh */
  Increfreshtim    number,             /* number in seconds for full refresh */
  lastrefreshscn   number,             /* scn of last transaction to refresh */
  lastrefreshdate  date,              /* date of last transaction to refresh */
  refreshmode      number,                   /* 0=none, 1=any, 2=inc, 3=full */
  pflags           number,                /* summary properties (bit flags): */
                                                /* refer to  QSMKSANA* flags */
  xpflags          number,                            /* extension to pflags */
  mflags           number,                          /* summary mutable flags */
                                              /* 0x01 summary is known stale */
                                                 /* 0x02 summary is unusable */
                                                 /* 0x04 summary is disabled */
  numdetailtab     integer,                       /* number of detail tables */
  numaggregates    integer,                            /* number of measures */
  numkeycolumns    integer,                      /* keys are group by fields */
  numjoins         integer,                    /* number of joins in summary */
  numinlines       integer,             /* number of inline views in summary */
  numwhrnodes      integer,   /* number of nodes in the where predicate tree */
  numhavnodes      integer,  /* number of nodes in the having predicate tree */
  numqbnodes       integer,       /* number of nodes in the query block tree */
  qbcmarker        integer,        /* qbc marker idx postion in the sel list */
  sumtextlen       number,                            /* length of text body */
  sumtext          long,                        /* text from 'select' onward */
  fromoffset       number not null,        /* offset in bytes to FROM clause */
  fromlen          number not null,   /* length from the F to the last table */
  metaversion      number not null,   /* version of this the canonical forms */
  objcount         number not null,           /* number of dependant objects */
  markerdty        integer,     /* data type of the qbc marker (for setop MV)*/
                                         /* 1 for character string */
                                         /* 2 for number */
                                         /* 3 for integer ... */
  rw_name          varchar2("M_IDEN"),    /* name of the rewrite equivalence */
  src_stmt         clob,              /* source statement for rw equivalence */
  dest_stmt        clob,         /* destination statement for rw equivalence */
  rw_mode          integer,               /* rewrite mode for rw equivalence */
                                                              /* disable = 0 */
                                                           /* text_match = 1 */
                                                              /* general = 2 */
                                                            /* recursive = 3 */
  spare1           number,   /* commitrefresh_scn, scn when refresh commited */
  spare2           number,
  spare3           varchar2(1000),
  spare4           date
)
/
create unique index i_sum$_1 on sum$(obj#)
/
create table sumdetail$            /* summary detail table */
( sumobj#       number not null,   /* object number */
  detailobj#    number not null,   /* obj number of detail table */
  qbcid         number not null,   /* query block id */
  detailobjtype number,            /* 1=table,2=view,3=snap,4=cont. table */
  detailalias   varchar2("M_IDEN"),/* alias if used */
  refreshscn    number,            /* scn of last refresh */
  detaileut     number,            /* detail tablew EUT flag */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date,
  inline#       number,            /* inline view number */
  instance#     number,            /* instance # for duplicate table */
  dataless      number             /* is the table dataless ? */
)
/
create index i_sumdetail$_1 on sumdetail$(sumobj#)
/
create index i_sumdetail$_2 on sumdetail$(detailobj#)
/

create table suminline$            /* summary inline view table */
( sumobj#       number not null,   /* object number */
  inline#       number not null,   /* inline view unique identifier */
  textspos      number not null,   /* inline view offset starting position */
  textlen       number not null,   /* inline view text length */
  text          long   not null,   /* inline view text */
  hashval       number not null,   /* hash value generateed from the inline */
                                   /* view text */    
  qbcid         number not null,   /* query block id */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date,
  instance#     number             /* instance # for duplicate inline view */
)
/
create index i_suminline$_1 on suminline$(sumobj#)
/
create index i_suminline$_2 on suminline$(inline#)
/
create index i_suminline$_3 on suminline$(hashval)
/

create table sumkey$             /* summary key table */
( sumobj#       number not null, /* parent summary obj */
  sumcolpos#    number not null, /* position of column in select list */
  containercol# number not null, /* pos. in container where stored */
  detailobj#    number not null, /* detail table object from FROM */
  qbcid         number not null, /* query block id */
  detailobjtype number,          /* detail table type - see sumdetail$ */
  detailcol#    number,          /* col number within detail table */
  groupingpos#  number,          /* pos. in GB clause */
  exprlen       number,
  expression    varchar2(4000),
  textlen       number,
  text          long,
  detailcolfunction number,      /* 0 = regular, 1 = partition key */
                                 /* 2 = partition marker, 3 = rowid */
  spare1        number,
  spare2        number,          /* length of column datatype info text */
  spare3        varchar2(1000),  /* column datatype info text */
  spare4        date,
  nodetype      number,          /* node type - see qkegstyp */
  ordinalpos    number,          /* for GSets - ordinal position */
  parentpos     number,          /* for GSets - parent postion (ordinal) */
  inline#       number,          /* inline view number */
  instance#     number           /* instance # for duplicate table */
)
/
create unique index i_sumkey$_1 on sumkey$
  (sumobj#,sumcolpos#,groupingpos#,ordinalpos,qbcid)
/
create table sumagg$             /* summary aggregate table */
( sumobj#       number not null, /* parent summary obj */
  sumcolpos#    number not null, /* position of column in select list */
  containercol# number not null, /* pos. in container where stored */
  qbcid         number not null, /* query block id */ 
  aggfunction   integer,         /* type of aggregate function */
  flags         number,          /* sumagg properties (bit flags): */
                                 /* 0x01=distinct aggregate */
  exprlen       number,          /* len of the canonical form */
  expression    varchar2(2000),  /* expr in canonical form */
  textlen       number,          /* len of aggregate text */
  aggtext       long,            /* text of agg. expression */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date,
  agginfo       varchar2(2000),  /* info about aggs like start of args */
  agginfolen    number           /* length of agginfo */
)
/
create unique index i_sumagg$_1 on sumagg$(sumobj#,sumcolpos#,qbcid)
/
create table sumjoin$             /* summary join table */
( sumobj#       number not null,  /* Object number of the summary */
  tab1obj#      number not null,  /* Object number of the first table */
  tab1col#      number not null,  /* Column number in the first table */
  tab2obj#      number not null,  /* Object number of the second table */
  tab2col#      number not null,  /* Column number of second table */
  qbcid         number not null,  /* query block id */
  joinop        integer,          /* Op code as defined in opndef.h (OPTTEQ) */
  flags         number,           /* currently unused */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date,
  inline1#      number,           /* left inline view number */
  inline2#      number,           /* right inline view number */
  instance1#    number,           /* instance # for tabobj1 */
  instance2#    number            /* instance # for tabobj2 */
)
/

create index i_sumjoin$_1 on sumjoin$(sumobj#,tab1obj#)
/
create table sumdep$                             /* summary dependency table */
( sumobj#       number not null,                  /* dependent object number */
  order#        number not null,                             /* order number */
  p_obj#        number not null,                     /* parent object number */
  p_type        number not null,                       /* parent object type */
  qbcid         number not null,                           /* query block id */
  p_ref_time    date,                            /* parent refresh timestamp */
  p_ref_scn     number,                                /* parent refresh scn */
  flags         number,
  inline#       number,                                     /* inline view # */
  instance#     number,                            /* inline view instance # */
  syn_own       varchar2("M_IDEN"),   /* owner of the synonym for base table */
  syn_name      varchar2("M_IDEN"),    /* name of the synonym for base table */
  syn_master    number,           /* order number that the synonym points to */
  vw_query      long,                              /* text of the view query */
  vw_query_len  number                      /* length of the view query text */
)
/
create index i_sumdep$_1 on sumdep$(sumobj#,order#)
/
create index i_sumdep$_2 on sumdep$(p_obj#,p_type)
/
create table sumpred$                    /* summary where/having pred tree */
(sumobj#           number not null,      /* summary object number */
 nodeid            number not null,      /* id that identifies a tree node */
 pnodeid           number not null,      /* parent node id */
 clauseid          integer not null,     /* caluse type: WHERE, HAVING, EUT..*/
 nodetype          integer not null,     /* AND, OR, COL_REL_CONST ... */
 qbcid             number not null,      /* query block id */
 numchild          integer,            /* num. of children for AND, OR nodes */
 relop             integer,              /* <,>,...,RP, IN-LIST..*/
 loptype           integer,              /* left operand type: COL,AGG,...*/
 roptype           integer,              /* right operand type: COL,AGG,...*/
 ldobj#            number,               /* left detail table object number */
 rdobj#            number,               /* right detail table object number */
 lcolid            number,               /* left column id if loptype=COL */
 rcolid            number,               /* right column id if roptype=COL */
 laggtype          integer,              /* OPTTYPE for left operand if AGG. */
 raggtype          integer,             /* OPTTYPE for right operand if AGG. */
 lcanotxt          varchar2(4000),       /* left operand normalized string */
 rcanotxt          varchar2(4000),       /* right operand normalized string */
 lcanotxtlen       integer,              /* left operand string length */
 rcanotxtlen       integer,              /* right operand string length */ 
 ltxt              varchar2(4000),       /* string for left expr */
 rtxt              varchar2(4000),       /* string fot right expr */ 
 ltxtlen           integer,              /* left expr length */
 rtxtlen           integer,              /* right expr length */
 value             long,                 /* value of oper. if optype = CONST */
 valuelen          integer,              /* value length */
 numval            integer,              /* number of values in in-list */
 colpos            integer,              /* used for multi-column in-lists */
 lflags            number,               /* left operand miscellaneous info */
 rflags            number,               /* right operand miscellaneous info */
 linline#          number,               /* left inline view number */
 rinline#          number,               /* right inline view number */
 linstance#        number,               /* instance # for left detail tab */
 rinstance#        number                /* instance # for right detail tab */
)
/
create index i_sumpred$_1 on sumpred$(sumobj#,clauseid)
/
create table sumqb$                      /* summary query block tree */
(sumobj#           number not null,      /* summary object number */
 nodeid            number not null,      /* node id */
 pflags            number,               /* persistent flags for query block */
 xpflags           number,               /* extented persistent flags */ 
 sflags            number,               /* snapshot semantic flags */
 state             number,               /* state info */
 text              long,                 /* normalized text */
 textlen           number,               /* length of the text */
 marker            varchar2(4000),       /* qbc marker value */
 markerlen         number,               /* length of the marker */
 hashval           number,               /* hash value */
 hashval2          number,               /* 2nd hash value */
 rorder            number,               /* node order relative to root */
 sorder            number,         /* node order relative to root of subtree */
 leafcnt           number,               /* number of leaf nodes */
 orignode          number,               /* node id of subtree */
 parent            number,               /* parent node id */
 opttyp            number,               /* operator type */
 selcnt            number,               /* number of select list items */
 frompo            number,               /* FROM position in text */
 flags             number,               /* misc info flags */
 numdetailtab      integer,              /* number of detail tables */
 numaggregates     integer,              /* number of measures */
 numkeycolumns     integer,              /* keys are group by fields */
 numjoins          integer,              /* number of joins in summary */
 numinlines        integer,             /* number of inline views in summary */
 numwhrnodes       integer,   /* number of nodes in the where predicate tree */
 numhavnodes       integer   /* number of nodes in the having predicate tree */
)
/
create index i_sumqb$_1 on sumqb$(nodeid)
/
create index i_sumqb$_2 on sumqb$(hashval)
/
create index i_sumqb$_3 on sumqb$(hashval2)
/

create table dim$                     /* dimension table */
( obj#             number not null,   /* object number */
  dimtextlen       number,            /* length of the dimension text */
  dimtext          long,
  flags            number,            /* currently only maintains force */
  numlevels        number,            /* number or levels */
  numlevkeys       number,            /* number of level keys */
  numjoinkeys      number,            /* number of join keys */
  numhier          number,            /* number or hierarchies */
  numhierlv        number,            /* number of hierarchy levels */
  numattr          number,            /* number of attributes */
  spare1           number,
  spare2           number,
  spare3           varchar2(1000),
  spare4           date
)
/
create unique index i_dim$_1 on dim$(obj#)
/
create table dimlevel$              /* a dimension level */
( dimobj#       number not null,    /* object number */
  levelid#      number not null,    /* unique number within dimension */
  levelname     varchar2("M_IDEN"), /* text name associated with the level */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date,
  flags         number default 0    /* flags: 0x01 = SKIP WHEN NULL */
)
/
create unique index i_dimlevel$_1 on dimlevel$(dimobj#,levelid#)
/
create table dimlevelkey$          /* the columns of a level */
( dimobj#       number not null,   /* object number */
  levelid#      number not null,   /* unique number within dimension */
  keypos#       number not null,   /* postition of column in the key */
  detailobj#    number,            /* detail table object */
  col#          number,            /* col number within detail table */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create index i_dimlevelkey$_1 on dimlevelkey$(dimobj#,levelid#)
/
create index i_dimlevelkey$_2 on dimlevelkey$(detailobj#,col#)
/
create table dimjoinkey$           /* describes a join in a dimension */
( dimobj#       number not null,   /* object number */
  joinkeyid#    number not null,   /* unique number within dimension */
  keypos#       number not null,   /* postition of column in the key */
  hierid#       number,            /* number of hier which this key links */
  levelid#      number,            /* number of hier which this key links */
  detailobj#    number,            /* detail table object */
  col#          number,            /* col number within detail table */
  chdlevid#     number,            /* number of the child level */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create index i_dimjoinkey$_1 on dimjoinkey$(dimobj#,joinkeyid#)
/
create index i_dimjoinkey$_2 on dimjoinkey$(detailobj#,col#)
/ 
create table dimattr$               /* describes attributes of a dimension */
( dimobj#       number not null,    /* object number */
  levelid#      number not null,    /* id of the level */
  detailobj#    number not null,    /* detail table object */
  col#          number,             /* col number within detail table */
  attname       varchar2("M_IDEN"), /* name of the attribute */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create index i_dimattr$_1 on dimattr$(dimobj#,levelid#)
/
create index i_dimattr$_2 on dimattr$(detailobj#,col#)
/
create table hier$                  /* a hierarchy */
( dimobj#       number not null,    /* object number */
  hierid#       number not null,    /* unique number within dimension */
  hiername      varchar2("M_IDEN"), /* text name or hierarchy */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create unique index i_hier$_1 on hier$(dimobj#,hierid#)
/
create table hierlevel$            /* identifies a level in a hierarchy */
( dimobj#       number not null,   /* object number */
  hierid#       number not null,   /* unique number of the hierarchy */
  pos#          number not null,   /* postition of level in hierarchy */
  levelid#      number not null,   /* id of the level */
  joinkeyid#    number,            /* join key - if levels are from 2 tables */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create index i_hierlevel$_1 on hierlevel$(dimobj#,hierid#)
/
create table rls$                                      /* Row Level Security */
(
  obj#            NUMBER NOT NULL,       /* synonym/table/view object number */
  gname           VARCHAR2("M_IDEN") NOT NULL,       /* name of policy group */
  pname           VARCHAR2("M_IDEN") NOT NULL,             /* name of policy */
  stmt_type       NUMBER NOT NULL,             /* statement and policy types */
                                   /* 0x0001 SELECT statement policy */
                                   /* 0x0002 INSERT statement policy */
                                   /* 0x0004 UPDATE statement policy */
                                   /* 0x0008 DELETE statement policy */
                                   /* 0x0010 static policy */
                                   /* 0x0020 policy associated with synonym */
                                   /* 0x0040 shared static policy */
                                   /* 0x0080 context sensitive policy */
                                   /* 0x0100 shared context sensitive policy */
                                   /* 0x0200 4000 bytes max predicate length */
                                   /* 0x0400 security relevant column policy */
  check_opt       NUMBER NOT NULL,                      /* with check option */
                                            /* 0 = no checking, 1 = checking */
  enable_flag     NUMBER NOT NULL,              /* 0 = disabled, 1 = enabled */
  pfschma         VARCHAR2("M_IDEN") NOT NULL,  /* schema of policy function */
  ppname          VARCHAR2("M_IDEN"),                 /* policy package name */
  pfname          VARCHAR2("M_IDEN") NOT NULL,       /* policy function name */
  ptype           NUMBER                                         /* obsolete */
)
/
create index i_rls on rls$(obj#, gname, pname)
/
create index i_rls2 on rls$(obj#)
/
create table rls_sc$                       /* RLS secrurity relevant columns */
(
  obj#            NUMBER NOT NULL,        /* parent table/view object number */
  gname           VARCHAR2("M_IDEN") NOT NULL,       /* name of policy group */
  pname           VARCHAR2("M_IDEN") NOT NULL,             /* name of policy */
  intcol#         NUMBER                      /* security relevant column ID */
)
/
create index i_rls_sc on rls_sc$(obj#, gname, pname)
/

create table rls_grp$
(
  obj#            NUMBER NOT NULL,                   /* parent object number */
  gname           VARCHAR2("M_IDEN") NOT NULL,       /* name of policy group */
  synid           NUMBER                                         /* obsolete */
)
/
create index i_rls_grp on rls_grp$(obj#)
/
create table rls_ctx$
(
  obj#            NUMBER NOT NULL,                   /* parent object number */
  ns              VARCHAR2("M_IDEN") NOT NULL,                  /* namespace */
  attr            VARCHAR2("M_IDEN") NOT NULL,                  /* attribute */
  synid           NUMBER                                         /* obsolete */
)
/
create index i_rls_ctx on rls_ctx$(obj#)
/

create table context$
(
  obj#          number  not null,                       /* object number */
  schema        varchar2("M_IDEN") not null,              /* schema name */
  package       varchar2("M_IDEN") not null,             /* package name */
  flags         number not null             /* for ctx accessed globally */
)
/

create unique index i_context on context$(obj#)
/

create table ruleset$ (
        obj#            number not null,                    /* object number */
        baseobj         number not null,               /* base object number */
        rules_table     number not null         /* table in which rules live */
)
/

rem  indpart_param$ table
rem  This table has one row per domain index partition
rem  obj# is a key, and so is (bo#, part#)
rem  There is a non-unique index on bo#, obj#
rem
create table indpart_param$ (
  obj#         number not null,                /* object number of partition */
  parameters   varchar2(1000))       /* parameter string per index partition */
/
create unique index i_indpart_param on indpart_param$(obj#)
/

create user outln identified by outln
/
grant create session to outln
/
grant resource to outln
/
grant execute any procedure to outln
/
create table outln.ol$
(
  ol_name           varchar2("M_IDEN"),   /* named is potentially generated */
  sql_text          long,                    /* the SQL stmt being outlined */
  textlen           number,                           /* length of SQL stmt */
  signature         raw(16),                       /* signature of sql_text */
  hash_value        number,                  /* KGL's calculated hash value */
  hash_value2       number,/* hash value on sql_text stripped of whitespace */
  category          varchar2("M_IDEN"),                    /* category name */
  version           varchar2(64),          /* db version @ outline creation */
  creator           varchar2("M_IDEN"),   /* user from whom outline created */
  timestamp         date,                               /* time of creation */
  flags             number,              /* e.g. everUsed, bindVars, dynSql */
  hintcount         number,               /* number of hints on the outline */
  spare1            number,                                 /* spare column */
  spare2            varchar2(1000)                          /* spare column */
)
/
create table outln.ol$hints
(
  ol_name           varchar2("M_IDEN"),                     /* outline name */
  hint#             number,               /* which hint for a given outline */
  category          varchar2("M_IDEN"),         /* collection/grouping name */
  hint_type         number,                                 /* type of hint */
  hint_text         varchar2(512),             /* hint specific information */
  stage#            number,            /* stage of hint generation/applic'n */
  node#             number,                                  /* QBC node id */
  table_name        varchar2("M_IDEN"),                 /* for ORDERED hint */
  table_tin         number,                        /* table instance number */
  table_pos         number,                             /* for ORDERED hint */
  ref_id            number,        /* node id that this hint is referencing */
  user_table_name   varchar2(64),  /* table name to which this hint applies */
  cost              double precision,    /* optimizer estimated cost of the */
                                                        /* hinted operation */
  cardinality       double precision,    /* optimizer estimated cardinality */
                                                 /* of the hinted operation */
  bytes             double precision,     /* optimizer estimated byte count */
                                                 /* of the hinted operation */
  hint_textoff      number,             /* offset into the SQL statement to */
                                                 /* which this hint applies */
  hint_textlen      number,     /* length of SQL to which this hint applies */
  join_pred         varchar2("M_CSIZ"), /* join predicate (applies only for */
                                                      /* join method hints) */
  spare1            number,         /* spare number for future enhancements */
  spare2            number,         /* spare number for future enhancements */
  hint_string       clob           /* hint text (replaces hint_text column) */
)
/
create table outln.ol$nodes
(
  ol_name       varchar2("M_IDEN"),                         /* outline name */
  category      varchar2("M_IDEN"),                     /* outline category */
  node_id       number,                              /* qbc node identifier */
  parent_id     number,      /* node id of the parent node for current node */ 
  node_type     number,                                    /* qbc node type */
  node_textlen  number,         /* length of SQL to which this node applies */ 
  node_textoff  number,      /* offset into the SQL statement to which this */
                                                            /* node applies */
  node_name     varchar2(64)                               /* qbc node name */
)
/
create unique index outln.ol$name on outln.ol$(ol_name)
/
create unique index outln.ol$signature on outln.ol$(signature,category)
/
create unique index outln.ol$hnt_num on outln.ol$hints(ol_name, hint#)
/
create table sql$                          /* base table for SQL Tuning Base */
(
  signature    number  not null,         /* signature of normalized SQL text */
  nhash number         not null,           /* hash value for normalized text */
  sqlarea_hash number  not null,                     /* sql cache hash value */
  last_used    date    not null,                         /* week of last use */
  inuse_features number not null, /* bit map of features used by this object */
                               /* 0x01 - SQLProfiles, 0x02 - stored outlines */
  flags        number  not null,                       /* not used currently */
  modified     date    not null,              /* last modification timestamp */
  incarnation  number  not null,          /* modification incarnation number */
  spare1       number,                                       /* spare column */
  spare2       varchar2(1000)                                /* spare column */
)
/
create unique index i_sql$signature on sql$(signature)
/
create table sql$text  /* holds SQL text for sql$ entries */
(
  signature    number  not null,         /* signature of normalized SQL text */
  sql_text     CLOB    not null,                   /* un-normalized SQL text */
  sql_len      number  not null                        /* length of SQL text */
)
/
create index i_sql$text on sql$text(signature)
/
create table sqlprof$          /* base table for storing SQL profile objects */
(
  sp_name     varchar2("M_IDEN") not null,   /* name (potentially generated) */
  signature   number             not null,/* signature of normalized SQL txt */
  category    varchar2("M_IDEN") not null,                  /* category name */
  nhash       number             not null, /* hash value for normalized text */
  created     date               not null,                  /* creation date */
  last_modified date             not null,             /* last modified date */
  type        number             not null,                /* '1' for manual, */
                                                        /* '2' for auto-tune */
  status      number             not null,               /* '1' for enabled, */
                                           /* '2' for disabled, '3' for void */
  flags       number             not null,                       /* not used */
  spare1      number,                                        /* spare column */
  spare2      varchar2(1000)                                 /* spare column */
)
/
create unique index i_sqlprof$ on sqlprof$(signature, category)
/
create unique index i_sqlprof$name on sqlprof$(sp_name)
/
create table sqlprof$desc                   /* descriptions for SQL profiles */
(
  signature   number             not null,/* signature of normalized SQL txt */
  category    varchar2("M_IDEN") not null,        /* join key: category name */
  description varchar2(500)   /* profile description (potentially generated) */
)
/
create unique index i_sqlprof$desc on sqlprof$desc(signature, category)
/
create table sqlprof$attr    /* table containing attributes for SQL profiles */
(
  signature   number             not null,/* signature of normalized SQL txt */
  category    varchar2("M_IDEN") not null,        /* join key: category name */
  attr#       number             not null,     /* attr number within profile */
  attr_val    varchar2(500)      not null                 /* attribute value */
)
/
create unique index i_sqlprof$attr on sqlprof$attr
 (signature, category, attr#)
/
create table exppkgobj$    /* Register procedural object sup pkgs for export */
(
  package     varchar2("M_IDEN") not null,                   /* package name */
  schema      varchar2("M_IDEN") not null,                 /* package schema */
  class       number not null,      /* 1=system, 2=schema, 3=object instance */
  type#       number not null,      /* type of objects this package supports */
  prepost     number,     /* 0=export prior to parent schema, 1=after parent */
  level#      number default 1000 not null
        /* Determines ordering in dump file of objects exported at same time */
)
/
create unique index i_objtype on exppkgobj$(type#, class)
/
create table exppkgact$    /* Register procedural action sup pkgs for export */
(
  package     varchar2("M_IDEN") not null,                   /* package name */
  schema      varchar2("M_IDEN") not null,                 /* package schema */
  class       number not null,      /* 1=system, 2=schema, 3=object instance */
  level#      number default 1000 not null
        /* Determines ordering in dump file of actions exported at same time */
)
/
create unique index i_actpackage on exppkgact$(package, schema, class)
/
create table expdepobj$  /* Register procedural object dependents for export */
(
  d_obj#      number not null,              /* dependent procedural object # */
  p_obj#      number not null                             /* parent object # */
)
/
create unique index i_dependobj on expdepobj$(d_obj#)
/
create index i_parentobj on expdepobj$(p_obj#)
/
create table expdepact$     /* Register objects that have associated actions */
(
  obj#        number not null,                                   /* object # */
  package     varchar2("M_IDEN"),    /* package containing instance_info_exp */
  schema      varchar2("M_IDEN")                           /* package schema */
)
/
create unique index i_actobj on expdepact$(obj#, package, schema)
/
create table mon_mods$
(
  obj#              number,                                 /* object number */
  inserts           number,  /* approx. number of inserts since last analyze */
  updates           number,  /* approx. number of updates since last analyze */
  deletes           number,  /* approx. number of deletes since last analyze */
  timestamp         date,     /* timestamp of last time this row was changed */
  flags             number,                                         /* flags */
                                           /* 0x01 object has been truncated */
  drop_segments     number   /* number of segemnt in part/subpartition table */
)
  storage (initial 200K next 100k maxextents unlimited pctincrease 0) 
/
create unique index i_mon_mods$_obj on mon_mods$(obj#)
  storage (maxextents unlimited)
/
create table mon_mods_all$
(
  obj#              number,                                 /* object number */
  inserts           number,  /* approx. number of inserts since last analyze */
  updates           number,  /* approx. number of updates since last analyze */
  deletes           number,  /* approx. number of deletes since last analyze */
  timestamp         date,     /* timestamp of last time this row was changed */
  flags             number,                                         /* flags */
                                           /* 0x01 object has been truncated */
  drop_segments     number   /* number of segemnt in part/subpartition table */
)
  storage (initial 200K next 100k maxextents unlimited pctincrease 0) 
/
create unique index i_mon_mods_all$_obj on mon_mods_all$(obj#)
  storage (maxextents unlimited)
/
rem
rem Metadata API infrastructure
rem
create table metaview$ /* Used by mdAPI to select which view per object type */
(
  type         varchar2("M_IDEN") not null,  /* dict. obj type: e.g, 'TABLE' */
  flags        number not null, /* Might have mult. views per obj class for  */
    /* performance: base rel. tables (fast), part. tbls, object tables, etc. */
  properties   number not null,            /* dict. object type's properties */
  /* 0x0001 =     1 = schema object */
  /* 0x0002 =     2 = heterogeneous object */
  /* 0x0004 =     4 = internal (not user-visible) object */
  model        varchar2("M_IDEN") not null,  /* 'ORACLE', 'ANSI', 'CWM', etc */
  version      number not null,     /* decimal RDBMS version: eg, 0802010000 */
              /*  indicates which view to use for client's requested version */
  xmltag       varchar2("M_IDEN"),         /*XML tag to use for each obj/row */
  udt          varchar2("M_IDEN"),               /* UDT name for object view */
                          /* UDT should be 'RELATIONAL' for relational views */
  schema       varchar2("M_IDEN"),                        /* schema for view */
  viewname     varchar2("M_IDEN")   /* view for this type, model and version */
)
/
create unique index i_metaview$ on metaview$(type, model, version, flags)
/
create table metafilter$  /* maps filters in mdAPI to UDT attributes */
(
  filter       varchar2("M_IDEN") not null,       /* documented filter. name */
  type         varchar2("M_IDEN") not null,  /* dict. obj type: e.g, 'TABLE' */
  model        varchar2("M_IDEN") not null,                    /* model name */
  properties   number not null,                         /* filter properties */
        /* 0x00000001 1         boolean filter                               */
        /* 0x00000002 2         expression filter                            */
        /* 0x00000004 4         custom filter                                */
        /* 0x00000008 8         has default                                  */
        /* 0x00000010 16        numeric filter                               */
        /* 0x00000020 32        filter leaf types (e.g., BEGIN_WITH)         */
        /* 0x00000040 64        filter branch (e.g., INCLUDE_PATH_EXPR)      */
        /* 0x00000080 128       ORDERED filter                               */
        /* 0x00000100 256       TOTAL_ORDER filter                           */
  view_attr    number not null,     /* view flag bits (boolean filters only) */
  attrname     varchar2(2000),                        /* filtering attribute */
  default_val  number
)
/
create unique index i_metafilter$ on metafilter$(filter, type, model)
/
create table metaxsl$                                  /* metadata xsl table */
( xmltag        varchar2("M_IDEN") not null,                      /* xml tag */
  transform     varchar2("M_IDEN") not null,               /* transform name */
  model         varchar2("M_IDEN") not null,                   /* model name */
  script        varchar2(2000) not null)                /* URI of xsl script */
/
create table metaxslparam$               /* mdAPI's XSL and parse parameters */
(
  model        varchar2("M_IDEN") not null,                    /* model name */
  transform    varchar2("M_IDEN") not null,                /* transform name */
  type         varchar2("M_IDEN") not null,  /* dict. obj type: e.g, 'TABLE' */
  param        varchar2("M_IDEN") not null,        /* documented param. name */
  default_val  varchar2(2000),
  properties   number default 0 not null,          /* parameter's properties */
  /* 0x0001 = additive  */
  /* 0x0002 = remap     */
  parse_attr   varchar2(2000)         /* attr path for UDT-based parse items */
)
/
create unique index i_metaxslparam$ on metaxslparam$(model, transform, 
type, param)
/
create table metastylesheet    /* Storage for the XSL stylesheets themselves */
( name          varchar2("M_IDEN") not null,              /* stylesheet name */
  model         varchar2("M_IDEN") not null,      /* model that uses this ss */
  stylesheet    clob)                                     /* stylesheet body */
/
Rem
Rem  Dictionary tables for heterogeneous object types in Metadata API
Rem
create table metascript$                  /* scripts for heterogeneous types */
( htype         varchar2("M_IDEN") not null,   /* root heterogeneous objtype */
  ptype         varchar2("M_IDEN") not null, /* parent heterogeneous objtype */
  seq#          number not null,                          /* sequence number */
  rseq#         number not null,        /* sequence number of reference type */
  ltype         varchar2("M_IDEN") not null,             /* leaf object name */
  properties    number not null,                    /*leaf type's properties */
                            /* 0x0001 =     1 = leaf is heterogeneous object */
  model         varchar2("M_IDEN") not null,             /* model properties */
  version       number not null     /* decimal RDBMS version: eg, 0802010000 */
)
/
create unique index i_metascript1$ on metascript$(ptype,seq#,model,version)
/
create unique index i_metascript2$ on metascript$(model,htype,seq#,version)
/
create table metascriptfilter$              /* filters for steps in a script */
( htype         varchar2("M_IDEN") not null,   /* root heterogeneous objtype */
  ptype         varchar2("M_IDEN") not null, /* parent heterogeneous objtype */
  seq#          number not null,                          /* sequence number */
  ltype         varchar2("M_IDEN") not null,             /* leaf object name */
  filter        varchar2("M_IDEN") not null,                 /*  filter name */
  pfilter       varchar2("M_IDEN"),                    /* parent filter name */
  vcval         varchar2(2000),                         /* filter text value */
  bval          number,                              /* filter boolean value */
  nval          number,                              /* filter numeric value */
  properties    number default 0 not null,              /* filter properties */
  model         varchar2("M_IDEN") not null              /* model properties */
)
/
rem
rem (these indexes intentionally not unique)
rem
create index i_metascriptfilter1$ on metascriptfilter$(model,htype,seq#)
/
create index i_metascriptfilter2$ on metascriptfilter$(model,ptype,seq#)
/
create table metanametrans$    /* path names for heterogeneous objtype nodes */
( name          varchar2(200) not null,                        /* path name  */
  htype         varchar2("M_IDEN") not null,   /* root heterogeneous objtype */
  ptype         varchar2("M_IDEN") not null,     /* immediate parent objtype */
  seq#          number not null,                 /* sequence number in ptype */
  properties    number not null,                   /* path name's properties */
  /* 0x0001 =     1 = this is the fully qualified path name */
  model         varchar2("M_IDEN") not null,            /* model properties  */
  descrip       varchar2(2000)             /* description of the object type */
)
/
create index i_metanametrans1$ on metanametrans$(model,htype,name)
/
create index i_metanametrans2$ on metanametrans$(model,ptype,seq#)
/
create table metapathmap$  /* het objtypes containing objs named by pathname */
( name         varchar2(200) not null,                          /* path name */
  htype        varchar2("M_IDEN") not null,         /* heterogeneous objtype */
  model        varchar2("M_IDEN") not null,                    /* model name */
  version      number not null      /* decimal RDBMS version: eg, 0802010000 */
)
/
create index i_metapathmap$ on metapathmap$(name,htype,model)
/
Rem
Rem  External tables meta data: external_tab$, external_location$
Rem
create table external_tab$
( obj#          number not null,                 /* base table object number */
  default_dir   varchar2("M_IDEN") not null,            /* default directory */
  type$         varchar2("M_IDEN") not null,           /* access driver type */
  nr_locations  number             not null,          /* number of locations */
  reject_limit  number             not null,                 /* reject limit */

  par_type      number not null,    /* access parameter type: blob=1, clob=2 */
  param_clob    clob,                      /* access parameters in clob form */
  param_blob    blob,                      /* access parameters in blob form */
  property      number not null)   /* 0x01 referenced cols, 0x02 all columns */
/
create unique index i_external_tab1$ on external_tab$(obj#)
/

create table external_location$ 
( 
  obj#          number not null,                 /* base table object number */
  position      number not null,                      /* this location index */
  dir           varchar2("M_IDEN"),             /* location directory object */
  name          varchar2("M_VCSZ"))                         /* location name */
/

create unique index i_external_location1$ on external_location$(obj#, position)
/

create table sql_version$
(
  version#          number not null,                           /* see kpul.h */
  sql_version       varchar2("M_IDEN")     /* sql version string identifier */
)
/
create unique index i_sql_version$_version# on sql_version$(version#)
/

insert into sql_version$ values (0, '8.1.5');    
insert into sql_version$ values (2, '8.1.5');    
insert into sql_version$ values (5, '8.1.5');
insert into sql_version$ values (6, '8.1.6')
/

rem Create default undo tablespace
"D_DUTSCR"
/
create tablespace SYSAUX datafile "D_SXFN" 
  "D_SDSG" online
/
create table col_usage$
(
  obj#              number,                                 /* object number */
  intcol#           number,                        /* internal column number */
  equality_preds    number,                           /* equality predicates */
  equijoin_preds    number,                           /* equijoin predicates */
  nonequijoin_preds number,                        /* nonequijoin predicates */
  range_preds       number,                              /* range predicates */
  like_preds        number,                         /* (not) like predicates */
  null_preds        number,                         /* (not) null predicates */
  timestamp         date      /* timestamp of last time this row was changed */
)
  storage (initial 200K next 100k maxextents unlimited pctincrease 0) 
/
create unique index i_col_usage$ on col_usage$(obj#,intcol#)
  storage (maxextents unlimited) 
/
rem
rem  Change Data Capture -- 3/2/2000 William D. Norcott
rem  
rem  Oracle CDC is a new feature in Oracle 8.2 RDBMS
rem
rem  4/11/2000 William D. Norcott changes to CDC system tables:
rem
rem  1. drop cdc_control_columns$ table, which is no longer needed
rem  2. add new columns to other CDC tables for use by MV log integration
rem  3. use "M_IDEN" for size of all identifiers in varchar2 fields
rem
create table cdc_system$          /* things that apply to all change sources */
(
  major_version      number         not null,       /* i.e. release 1 of CDC */
  minor_version      number         not null     /* maintenance level i.e. 0 */
)
/
insert into cdc_system$ (major_version, minor_version) values(1,0)
/
create table cdc_change_sources$                  /* origin of change stream */
(                                             /* a collection of change sets */
  source_name        varchar2("M_IDEN") not null,          /* user specified */
  dbid               number,                        /* Oracle DBID of origin */
  logfile_location   varchar2(2000),                   /* redo log directory */
  logfile_suffix     varchar2("M_IDEN"),                      /* "log", etc. */
  source_description varchar2(255),                          /* user comment */
  created            date not null,                     /* when row inserted */
  source_type        number not null,     /* change source type see qccpub.h */
                                         /* 0x01 = Manuallog, 0x02 = Autolog */
                                         /* 0x04 = Hotlog, 0x08 = Synchronous*/
                                        /* 0x10 = 9iR2 src 0x20 = distributed*/
                                        /* 0x40 = hot mine 0x80 = user def   */
  source_database    varchar2("M_XDBI"), /* source database full global name */
  source_dbid        varchar2("M_IDBI"),               /* source database ID */
  first_scn          number,               /* SCN before LogMiner dict. dump */
  first_logfile      varchar2("M_CSIZ"),    /* first ManualLog redo log file */
  logfile_format     varchar2("M_CSIZ"),   /* later log format for ManualLog */
  publisher          varchar2("M_IDEN"),    /* publisher that created source */
  capture_name       varchar2("M_IDEN"),      /* Streams capture engine name */
  capqueue_name      varchar2("M_IDEN"),       /* Streams capture queue name */
  capqueue_tabname   varchar2("M_IDEN"), /* Streams capture queue table name */
  source_enabled     char(1)                  /* Y or N - is capture started */
)
/
create unique index i_cdc_change_sources$ on cdc_change_sources$(source_name)
/
insert into cdc_change_sources$
  (source_name,dbid,logfile_location,logfile_suffix,source_description,created,
   source_type, source_database, source_dbid, first_scn, first_logfile, 
   logfile_format, publisher, capture_name, capqueue_name, capqueue_tabname,
   source_enabled)
  values('HOTLOG_SOURCE',NULL,NULL,NULL,'HOTLOG CHANGE SOURCE',SYSDATE,
         4, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
/
insert into cdc_change_sources$
  (source_name,dbid,logfile_location,logfile_suffix,source_description,created,
   source_type, source_database, source_dbid, first_scn, first_logfile, 
   logfile_format, publisher, capture_name, capqueue_name, capqueue_tabname,
   source_enabled)
  values('SYNC_SOURCE',NULL,NULL,NULL,'SYNCHRONOUS CHANGE SOURCE',SYSDATE,
         8, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
/
create table cdc_change_sets$               /* a collection of change tables */
(
  set_name           varchar2("M_IDEN") not null,          /* user specified */
  change_source_name varchar2("M_IDEN") not null,                  /* parent */
  begin_date         date,       /* starting point for capturing change data */
  end_date           date,        /* stoping point for capturing change data */
  begin_scn          number,     /* starting point for capturing change data */
  end_scn            number,      /* stoping point for capturing change data */
  freshness_date     date,     /* stopping point for last successful advance */
  freshness_scn      number,   /* stopping point for last successful advance */
  advance_enabled    char(1),               /* Y or N - eligible for advance */
  ignore_ddl         char(1),                  /* Y or N - continue vs. stop */
  created            date not null,                     /* when row inserted */
  rollback_segment_name varchar2("M_IDEN"), /* for use in advance - optional */
  advancing          char(1) not null,       /* Y or N - being advanced now? */
  purging            char(1) not null,         /* Y or N - being purged now? */
  lowest_scn         number,                           /* LWM of change data */
  tablespace         varchar2("M_IDEN"),          /* for advance LCR staging */
  lm_session_id      number,          /* for LogMiner session during advance */
  partial_tx_detected char(1),    /* advance detected partial transaction(s) */
  last_advance       date,                     /* when set was last advanced */
  last_purge         date,                       /* when set was last purged */
  stop_on_ddl        char(1) not null,      /* Y or N - stop if DDL detected */
  capture_enabled    char(1) not null,       /* Y or N - can perform capture */
  capture_error      char(1) not null,    /* Y or N - Streams error detected */
  capture_name       varchar2("M_IDEN"),      /* Streams capture engine name */
  queue_name         varchar2("M_IDEN"),            /* AQ/Streams queue name */
  queue_table_name   varchar2("M_IDEN"), /* AQ/Streams spillover queue table */
  apply_name         varchar2("M_IDEN"),        /* Streams apply engine name */
  supplemental_procs number,        /* number of supp. processes CDC can use */
  set_description    varchar2(255),             /* description of change set */
  publisher          varchar2("M_IDEN"),       /* publisher that created set */
  set_sequence       varchar2("M_IDEN")     /* sequence object name for rsid */
)
/
create unique index i_cdc_change_sets$ on cdc_change_sets$(set_name)
/
insert into cdc_change_sets$
  (set_name, change_source_name, created, advancing, purging, stop_on_ddl,
   capture_enabled, capture_error, set_description, lowest_scn, publisher)
  values('SYNC_SET', 'SYNC_SOURCE', SYSDATE, 'N', 'N', 'N', 'Y', 'N',
         'SYNCHRONOUS CHANGE SET', 0, NULL)
/
create table cdc_change_tables$           /* information about change tables */
(
  obj#                number not null,           /* object # of change table */
  change_set_name     varchar2("M_IDEN") not null,                 /* parent */
  source_schema_name  varchar2("M_IDEN") not null,     /* source table owner */
  source_table_name   varchar2("M_IDEN") not null,  /* corresp. source table */
  change_table_schema varchar2("M_IDEN") not null,  /* for DROP_CHANGE_TABLE */
  change_table_name   varchar2("M_IDEN") not null,  /* for DROP_CHANGE_TABLE */
  created             date not null,                    /* when row inserted */
  created_scn         number,  /* system commit scn of this table's creation */
  mvl_flag            number,                    /* for MV Log compatability */
  captured_values     char(1) not null,           /* Old values, New or Both */
  mvl_temp_log        varchar2("M_IDEN"),   /* MV Log temp. update. log name */
  mvl_v7trigger       varchar2("M_IDEN"),               /* MV Log V7 trigger */
  last_altered        date,       /* last successful ALTER_CHANGE_TABLE date */
  lowest_scn          number not null,         /* LWM for this table (PURGE) */
  mvl_oldest_rid      number,                     /* MV Log oldest rowid scn */
  mvl_oldest_pk       number,               /* MV Log oldest primary key scn */
  mvl_oldest_seq      number,                  /* MV Log oldest sequence scn */
  mvl_oldest_oid      number,                 /* MV Log oldest object id scn */
  mvl_oldest_new      number,                 /* MV Log oldest new value scn */
  mvl_oldest_rid_time date,                      /* MV Log oldest rowid time */
  mvl_oldest_pk_time  date,                /* MV Log oldest primary key time */
  mvl_oldest_seq_time date,                   /* MV Log oldest sequence time */
  mvl_oldest_oid_time date,                  /* MV Log oldest object id time */
  mvl_oldest_new_time date,                  /* MV Log oldest new value time */
  mvl_backcompat_view varchar2("M_IDEN"),  /* MV Log back. compat. view name */
  mvl_physmvl         varchar2("M_IDEN"),             /* physical mv log     */
  highest_scn         number,                 /*  high water mark scn for ct */
  highest_timestamp   date,             /* time of last extend_window[_list] */
  change_table_type  number         not null, /* type of change table:       */
                                              /* 1 MV log style synchronous  */
                                              /* 2 asynchronous              */
                                              /* 3 improved synchronous      */
  major_version      number         not null,       /* i.e. release 1 of CDC */
  minor_version      number         not null,    /* maintenance level i.e. 0 */
  source_table_obj#  number,                     /* object # of source table */
  source_table_ver   number                /* version number of source table */
)
/
create unique index i_cdc_change_tables$ on cdc_change_tables$(obj#)
/
create table cdc_subscribers$                /* subscriptions to change data */
(
  subscription_name varchar2("M_IDEN") not null,      /* subscription name   */
  handle             number not null,                 /* subscription handle */
  set_name           varchar2("M_IDEN") not null,   /* change set identifier */
  username           varchar2("M_IDEN") not null,           /* of subscriber */
  created            date not null,                     /* when row inserted */
  status             char(1) not null,         /* Not active (yet) or Active */
  earliest_scn       number not null,           /* starting point for window */
  latest_scn         number not null,             /* ending point for window */
  description        varchar2(255),                      /* for user comment */
  last_purged        date,             /* last time user called PURGE_WINDOW */
  last_extended      date,              /* time of last extend_window[_list] */
  mvl_invalid        char(1),     /* MV Log subscription invalid, 'Y' or 'N' */
  reserved1          number                     /* reserved numerical column */
)    
/
create unique index i_cdc_subscribers$ on cdc_subscribers$(subscription_name)
/
create table cdc_subscribed_tables$               /* tables of subscriptions */
(
  handle             number not null,                 /* subscription handle */
  change_table_obj#  number not null,    /* subscribed change table object # */
  view_name          varchar2("M_IDEN"),              /* generated view name */
  view_status        char(1) not null,                 /* Created or Dropped */
  mv_flag            number,                  /* MV Log info. required by MV */
  mv_colvec          raw(128)  /* MV Log columns required by MV (bit vector) */
)
/
create unique index i_cdc_subscribed_tables$ on cdc_subscribed_tables$
  (handle, change_table_obj#)
/
create table cdc_subscribed_columns$         /* columns of subscribed tables */
(
  handle            number not null,                  /* subscription handle */
  change_table_obj# number not null,     /* subscribed change table object # */
  column_name       varchar2("M_IDEN") not null  /* src table col identifier */
)
/
create unique index i_cdc_subscribed_columns$ on cdc_subscribed_columns$
  (handle, change_table_obj#, column_name)
/
create sequence cdc_subscribe_seq$     /* CDC subscription handle allocation */
  start with 1
  increment by 1
  nomaxvalue
  minvalue 1
  nocycle
  cache 20
  noorder
/
create table cdc_change_columns$       /* track when columns added to tables */
(
  change_table_obj#  number not null,    /* subscribed change table object # */
  column_name        varchar2("M_IDEN") not null,       /* column identifier */
  created            date not null,                     /* when row inserted */
  created_scn        number not null         /* scn of this columns creation */
)
/
create unique index i_cdc_change_columns$ on cdc_change_columns$
  (change_table_obj#, column_name)
/
create sequence cdc_rsid_seq$       /* CDC row sequence ids for sync capture */
  start with 1
  increment by 1
  nomaxvalue
  minvalue 1
  nocycle
  cache 10000
  order
/
create table cdc_propagations$                       /* cdc propagation info */
(                                          /* describes a given propagation  */
  propagation_name   varchar2("M_IDEN") not null, /*Streams propagation name */
  destqueue_publisher varchar2("M_IDEN") not null,    /* owner of dest queue */
  destqueue_name     varchar2("M_IDEN") not null,  /* destination queue name */
  staging_database   varchar2("M_XDBI") not null,    /* stage db global name */
  sourceid_name      varchar2("M_IDEN") not null, 
                                        /* source identifier name for propag */
  source_class       number not null    /* class of source                   */
                                        /* 1=propag starts at change source  */
                                        /* 2=propag starts at change set     */
)
/
create index i_cdc_propagations$ on cdc_propagations$(propagation_name)
/
create table cdc_propagated_sets$                /* cdc set propagation info */
(                                    /* correlates progations to change sets */
  propagation_name    varchar2("M_IDEN") not null, /*Streams propagation name*/
  change_set_publisher varchar2("M_IDEN") not null, /* change set publisher  */
  change_set_name     varchar2("M_IDEN") not null /* change set name-stage db*/
)
/
create index i_cdc_propagated_sets$ on cdc_propagated_sets$(propagation_name)
/
rem end of change data capture metadata

rem join index join conditions
create table jijoin$
(
  obj#      number not null,                              /* join index obj# */
  tab1obj#  number not null,                           /* table 1 obj number */
  tab1col#  number not null,           /* internal column number for table 1 */
  tab2obj#  number not null,                           /* table 2 obj number */
  tab2col#  number not null,           /* internal column number for table 2 */
  joinop    number not null,           /* Op code as defined in opndef.h (=) */
  flags     number,                                            /* misc flags */
  tab1inst# number default 0,     /* instance of table 1 (for multiple refs) */
  tab2inst# number default 0      /* instance of table 2 (for multiple refs) */
)
/
create index i_jijoin$ on jijoin$(obj#)
/
create index i2_jijoin$ on jijoin$(tab1obj#,tab1col#)
/
create index i3_jijoin$ on jijoin$(tab2obj#,tab2col#)
/
rem join index refresh sql statements
create table jirefreshsql$
(
  iobj#     number not null,                              /* join index obj# */
  tobj#     number not null,                              /* base table obj# */
  sqltext   clob       /* sql to refresh iobj# when tobj# is modified by DML */
)
/
create unique index i1_jirefreshsql$ on jirefreshsql$(iobj#, tobj#)
/
create index i2_jirefreshsql$ on jirefreshsql$(tobj#)
/
create table log$
(
  btable#    number not null,                        /* base table object id */
  colname    varchar2(30) not null,                   /* logging column name */
  refcount   number not null,                        /* number of references */
  ltable#    number not null                      /* logging table object id */
)
/
create sequence log$sequence   /* sequence for logging table name generation */
  increment by 1
  start with 1
  minvalue 0
  nomaxvalue
  cache 10
  order
  nocycle
/

create table approle$                                    /* Application Role */
(
  role#           NUMBER NOT NULL,                                  /* role# */
  schema          VARCHAR2("M_IDEN") NOT NULL,  /* schema of policy function */
  package         VARCHAR2("M_IDEN") NOT NULL         /* policy package name */
)
/
create unique index i_approle on approle$(role#)
/

create table fga$
(
  obj#            NUMBER NOT NULL,                   /* parent object number */
  pname           VARCHAR2("M_IDEN") NOT NULL,             /* name of policy */
  ptxt            VARCHAR2("M_VCSZ"),                    /* policy predicate */
  pfschma         VARCHAR2("M_IDEN"),             /* schema of event handler */
  ppname          VARCHAR2("M_IDEN"),                  /* event package name */
  pfname          VARCHAR2("M_IDEN"),                 /* event function name */
  pcol            VARCHAR2("M_IDEN"),                     /* relevant column */
  enable_flag     NUMBER NOT NULL,              /* 0 = disabled, 1 = enabled */
  stmt_type       NUMBER default 1 NOT NULL                /* statement type */
)
/
create index i_fga on fga$(obj#)
/

create unique index i_fgap on fga$(obj#, pname)
/

create table fgacol$
(
  obj#            NUMBER NOT NULL,                   /* parent object number */
  pname           VARCHAR2("M_IDEN") NOT NULL,             /* name of policy */
  intcol#         NUMBER NOT NULL                           /* column number */
)
/
create unique index i_fgacol on fgacol$(obj#, pname, intcol#)
/

Rem  Creation of AUD$ is moved here because of new CLOB type columns.
Rem    We can define CLOB columns only after LOB$ table is defined.
Rem 
create table aud$                                       /* audit trail table */
( sessionid     number not null,                        /* server session id */
  entryid       number not null,           /* serial number to audit records */
  statement     number not null,                     /* sql statement number */
  timestamp#    date,            /* OBSOLETE: 10iR1 and above: time of query */
  userid        varchar2("M_IDEN"),                     /* database username */
  userhost      varchar2("M_HOST"),              /* client host machine name */
  terminal      varchar2("M_TERM"),                    /* client terminal id */
  action#       number not null,          /* action responsible for auditing */
  returncode    number not null,               /* return code for the action */
  obj$creator   varchar2("M_IDEN"),           /* schema where object resides */
  obj$name      varchar2("M_XDBI"),                    /* name of the object */
  auth$privileges varchar2("S_PRFL"),                  /* granted privileges */
  auth$grantee  varchar2("M_IDEN"),                      /* grantee username */
  new$owner     varchar2("M_IDEN"),        /* schema of the dependent object */
  new$name      varchar2("M_XDBI"),          /* name of the dependent object */
  ses$actions   varchar2("S_ACFL"),        /* success/failure of each action */
  ses$tid       number,                                         /* object id */
  logoff$lread  number,            /* number of logical reads in the session */
  logoff$pread  number,           /* number of physical reads in the session */
  logoff$lwrite number,           /* number of logical writes in the session */
  logoff$dead   number,                /* number of deadlocks in the session */
  logoff$time   date,                                    /* session duration */
  comment$text  varchar2("M_VCSZ"),  /* type authentication/trigger/protocol */
  clientid      varchar2(64),              /* user defined client identifier */
  spare1        varchar2(255),                               /* OS user name */
  spare2        number,             /* whether this table (aud$) is modified */
  obj$label     raw(255),                         /* OBSOLETE: 8.0 and above */
  ses$label     raw(255),                         /* OBSOLETE: 8.0 and above */
  priv$used     number,                              /* system privlege used */
  sessioncpu    number,                    /* total cpu time for the session */
  ntimestamp#   timestamp,                /* new timestamp (in UTC) of query */
  proxy$sid     number,                       /* proxy session serial number */
  user$guid     varchar2(32),                      /* global user identifier */
  instance#     number,                                   /* instance number */
  process#      varchar2("M_PIDL"),                         /* OS process id */
  xid           raw(8),                            /* transaction identifier */
  auditid       varchar2(64),                          /* audit operation id */
  scn           number,                                  /* SCN of the query */
  dbid          number,          /* null or remote dbid. for Logical Standby */
  sqlbind       clob,                        /* bind variables for the query */
  sqltext       clob                                /* sql text of the query */
)
/
create index i_aud1 on aud$(sessionid, ses$tid)
/
grant delete on aud$ to delete_catalog_role
/

create table fga_log$
(
  sessionid     number not null,                               /* session id */
  timestamp#    date,            /* OBSOLETE: 10iR1 and above: time of query */
  dbuid         varchar2("M_IDEN"),                     /* database username */
  osuid         varchar2(255),                                  /* OS userid */
  oshst         varchar2("M_HOST"),                           /* client host */
  clientid      varchar2(64),                           /* client identifier */
  extid         varchar2("M_VCSZ"),                    /* external user name */
  obj$schema    varchar2("M_IDEN"),                         /* object schema */
  obj$name      varchar2("M_XDBI"),                           /* object name */
  policyname    varchar2("M_IDEN"),             /* fine grained audit policy */
  scn           number,                                  /* SCN of the query */
  sqltext       varchar2("M_VCSZ"),                       /* only used in 9i */
  lsqltext      clob,                               /* sql text of the query */
  sqlbind       varchar2("M_VCSZ"),                  /* only used until 9iR2 */
  comment$text  varchar2("M_VCSZ"),
  plhol         long,                        /* place holder for int. values */
  stmt_type     number,                                    /* statement type */
  ntimestamp#   timestamp,                /* new timestamp (in UTC) of query */
  proxy$sid     number,                       /* proxy session serial number */
  user$guid     varchar2(32),                      /* global user identifier */
  instance#     number,                                /* db instance number */
  process#      varchar2("M_PIDL"),                         /* OS process id */
  xid           raw(8),                  /* modifying transaction identifier */
  auditid       varchar2(64),                     /* user defined audit info */
  statement     number,                              /* sql statement number */
  entryid       number,                    /* serial number to audit records */
  dbid          number,          /* null or remote dbid. for Logical Standby */
  lsqlbind      clob                         /* bind variables for the query */
)
/
grant delete on fga_log$ to delete_catalog_role
/

create table object_usage                         /* object usage statistics */
( obj#               number not null,   /* object number of monitored object */
  flags              number not null,                       /* various flags */
                           /* index accessed during monitoring period : 0x01 */
  start_monitoring   char(19),                      /* start monitoring time */
  end_monitoring     char(19)                         /* end monitoring time */
) initrans 30  pctused 50           /* itls and space so each row has an itl */
  storage (maxextents unlimited) 
/
create index i_stats_obj# on object_usage(obj#)
  storage (maxextents unlimited) 
/

rem
rem create default temporary tablespace
rem
"D_DTTSCR"
/

rem
rem initialize default temporary tablespace
rem
"D_DTTSAT"
/

rem
rem create the default permanent tablespace for the database
rem
"D_CRTDPTS"
/

rem
rem set the default permanent tablespace for the database
rem
"D_ALTDPTS"
/
rem The aux_stats$ table contains auxiliary statistics used by optimizer.
rem sname and pname maintain primary key where sname stores name of set
rem of parameters and pname is name of parameter. pval1 or pval2 store 
rem parameter value in character or number format. 
create table aux_stats$ (
  sname varchar2("M_IDEN") not null, /* Name of set */
  pname varchar2("M_IDEN") not null, /* Name of parameters*/
  pval1 number,                      /* NUMBER parameter value */
  pval2 varchar2(255)                /* VARCHAR2 parameter value */ 
) 
/
create unique index i_aux_stats$ on aux_stats$(sname, pname)
/
rem
rem create the scn<->time tracking table that smon will maintain
rem as a circular queue - notice that we populate the entire
rem table with at least 144000 entries (enough for 5 days).
rem
rem -"thread" is for backward compatibility and is always 0
rem -"orig_thread" is for upgrade/downgrade
rem - scn_wrp, scn_bas, and time_dp are for backward compatibility
rem   and not queried by the ktf layer.
rem

create cluster smon_scn_to_time (
  thread number                         /* thread, compatibility */
)
/
create index smon_scn_to_time_idx on cluster smon_scn_to_time
/
create table smon_scn_time (
  thread number,                         /* thread, compatibility */
  time_mp number,                        /* time this recent scn represents */
  time_dp date,                          /* time as date, compatibility */
  scn_wrp number,                        /* scn.wrp, compatibility */
  scn_bas number,                        /* scn.bas, compatibility */
  num_mappings number,
  tim_scn_map raw(1200),
  scn number default 0,                  /* scn */
  orig_thread number default 0           /* for downgrade */
) cluster smon_scn_to_time (thread)
/

create unique index smon_scn_time_tim_idx on smon_scn_time(time_mp)
/

create unique index smon_scn_time_scn_idx on smon_scn_time(scn)
/

create table aw$
(awname varchar2("M_IDEN"),              /* name of AW */
 owner#  number not null,                /* owner of AW */
 awseq#  number not null,                /* aw sequence number */
 version number default null,            /* aw storage version */
 oids    number(10) default null,        /* object id page space */
 objs    number(10) default null,        /* object storage page space */
 dict    raw(8) default null)            /* aw dictionary object */
/
create unique index aw_ind$ on aw$(awname, owner#)
/
create table ps$
( awseq# number not null,                 /* aw sequence number */
 psnumber number(10),                    /* pagespace number */
 psgen number(10),                        /* pagespace generation */
 mapoffset number,                       /* offset of map */
 maxpages number,                        /* max pages in ps */
 almap raw(8),                           /* pointer to almap */
 header raw(200),                        /* internal header */
 gelob blob,                             /* erase list */
 gelrec number default null,             /* generation erase list */
 maprec number default null)             /* map record */
 lob (gelob) store as (disable storage in row)
/
create unique index i_ps$ on ps$ (awseq#, psnumber, psgen) 
/
create sequence psindex_seq$ /* sequence for pagespace index */
 start with 100
 increment by 1
 cache 1000  /* allow caching for rac */
 nocycle
 maxvalue 18446744073709551615
/
create sequence awseq$ /* sequence for aw index */
  start with 1000
  increment by 1
  nocache 
  nocycle
  maxvalue 4294967295

/

create table aw_obj$  /* Analytical Workspace Object table */
(awseq# number,                     /* aw sequence number */
oid number(20),                     /* object number, up to UB8MAXVAL */
objname varchar2(256),              /* object name, ref NAMESIZE in xsobj.c */
gen# number(10),                    /* generation number */
objtype number(4),                  /* object type */
partname varchar2(256),             /* partition name */
objdef blob,                        /* object definition */
objvalue blob,                      /* object value */
compcode blob)                      /* compiled code body */
lob(objdef) store as (enable storage in row)
lob(objvalue) store as (enable storage in row) 
lob(compcode) store as (enable storage in row)
tablespace sysaux
/
create unique index i_aw_obj$ on aw_obj$ (awseq#, oid, gen#) tablespace sysaux
/

create table aw_prop$ /* Analytical Workspace Property table */
(awseq# number,                          /* aw sequence number */
oid number(20),                          /* object number, up to UB8MAXVAL */
objname varchar2(256),                   /* object name */
gen# number(10),                         /* generation number */ 
propname varchar2(256),                  /* property name */
proptype number,                         /* property type */ 
propval blob)                            /* property value */
lob(propval) store as (enable storage in row)
tablespace sysaux
/
create index i_aw_prop$ on aw_prop$ (awseq#, oid, propname, gen#)
  tablespace sysaux
/
 
create table map_file$ (
  file_idx      number,                       /* file index */
  file_cfgid    varchar2("M_CSIZ"),           /* file configuration id */
  file_status   number,                       /* file status */
  file_name     varchar2("M_CSIZ"),           /* file name */
  file_struct   number,                       /* file structure */
  file_type     number,                       /* file type */
  file_size     number,                       /* file size */
  file_nexts    number                        /* file number of extents */
)
/
create table map_file_extent$(
  file_idx     number,                     /* file index */      
  ext_num      number,                     /* file extent number */
  ext_dev_off  number,                     /* element offset */
  ext_size     number,                     /* file extent size */
  ext_file_off number,                     /* file offset */
  ext_type     number,                     /* file extent type */
  elem_name    varchar2("M_CSIZ"),         /* element name */
  elem_idx     number                      /* element index */
)
/
create table map_subelement$(
  sub_num      number,                     /* subelement number */      
  sub_size     number,                     /* subelement size */
  elem_offset  number,                     /* element offset */
  sub_flags    number,                     /* subelement flags */
  parent_idx   number,                     /* parent element index */
  child_idx    number,                     /* child element index */
  elem_name    varchar2("M_CSIZ")          /* element name */
)
/
create table map_element$ (
  elem_name     varchar2("M_CSIZ"),        /* element name */
  elem_cfgid    varchar2("M_CSIZ"),        /* element configuration id */
  elem_type     number,                    /* element type */
  elem_idx      number,                    /* element index */
  elem_size     number,                    /* element size */
  elem_nsubelem number,                    /* number of subelements */
  elem_descr    varchar2("M_CSIZ"),        /* description */
  stripe_size   number,                    /* element stripe size */
  elem_flags    number                     /* flags */
)
/
create table map_extelement$ (
  elem_idx      number,                    /* element index */
  num_attrb     number,                    /* number of attributes */
  attrb1_name   varchar2("M_IDEN"),        /* attribute 1 name */
  attrb1_val    varchar2("M_IDEN"),        /* attribute 1 value */
  attrb2_name   varchar2("M_IDEN"),        /* attribute 2 name */
  attrb2_val    varchar2("M_IDEN"),        /* attribute 2 value */
  attrb3_name   varchar2("M_IDEN"),        /* attribute 3 name */
  attrb3_val    varchar2("M_IDEN"),        /* attribute 3 value */
  attrb4_name   varchar2("M_IDEN"),        /* attribute 4 name */
  attrb4_val    varchar2("M_IDEN"),        /* attribute 4 value */
  attrb5_name   varchar2("M_IDEN"),        /* attribute 5 name */
  attrb5_val    varchar2("M_IDEN")         /* attribute 5 value */
)
/
create table map_complist$ (
  elem_idx      number,                    /* element index */
  num_comp      number,                    /* number of components */
  comp1_name    varchar2("M_IDEN"),        /* component 1 name */
  comp1_val     varchar2("M_CSIZ"),        /* component 1 value */
  comp2_name    varchar2("M_IDEN"),        /* component 2 name */
  comp2_val     varchar2("M_CSIZ"),        /* component 2 value */
  comp3_name    varchar2("M_IDEN"),        /* component 3 name */
  comp3_val     varchar2("M_CSIZ"),        /* component 3 value */
  comp4_name    varchar2("M_IDEN"),        /* component 4 name */
  comp4_val     varchar2("M_CSIZ"),        /* component 4 value */
  comp5_name    varchar2("M_IDEN"),        /* component 5 name */
  comp5_val     varchar2("M_CSIZ")         /* component 5 value */
)
/
create global temporary table map_object (
  object_name   varchar2("M_CSIZ"),        /* object name */
  object_owner  varchar2("M_CSIZ"),        /* object owner */
  object_type   varchar2("M_CSIZ"),        /* object type */
  file_map_idx  number,                    /* file index */
  depth         number,                    /* element depth */
  elem_idx      number,                    /* element index */
  cu_size       number,                    /* contiguous unit size */
  stride        number,                    /* stride size */
  num_cu        number,                    /* number of contiguous units */
  elem_offset   number,                    /* element offset */
  file_offset   number,                    /* file offset */
  data_type     varchar2("M_CSIZ"),        /* data type */
  parity_pos    number,                    /* parity position */
  parity_period number                     /* parity period */
) on commit preserve rows
/
create public synonym map_object for sys.map_object
/
grant select on map_object to select_catalog_role
/
grant all on map_object to dba
/
rem
rem Streams tables
rem
rem NOTE: Not all columns are populated during cloning. 
rem If you start using a spare column or add a new column then 
rem please change the cloning logic if you want to copy over the 
rem old value of that column to the cloned capture process. 

create table streams$_capture_process
(
  queue_oid       raw(16)             not null,       /* AQ queue identifier */
  queue_owner     varchar2("M_IDEN")  not null,            /* AQ queue owner */
  queue_name      varchar2("M_IDEN")  not null,             /* AQ queue name */
  capture#        number              not null,                   /* 1 to 99 */
  capture_name    varchar2("M_IDEN")  not null,
  status          number,      /* capture process status: START, STOP, ABORT */
  ruleset_owner   varchar2("M_IDEN"),                      /* rule set owner */
  ruleset_name    varchar2("M_IDEN"),                       /* rule set name */
  logmnr_sid      number,           /* id of the persistent logminer session */
                                 /* needed for creating a persistent session */
  predumpscn      number,                                        /* OBSOLETE */
  dumpseqbeg      number,                                        /* OBSOLETE */
  dumpseqend      number,                                        /* OBSOLETE */
  postdumpscn     number,                                        /* OBSOLETE */
  flags           number,                    /* 0x01 = KNLCAPF_DICT_LOADED   */
                                             /* 0x02 = KNLCAPF_SESS_CDC      */
                                             /* 0x04 = KNLCAPF_SESS_IMPLICIT */
                                             /* 0x08 = KNLCAPF_SESS_EXPLICIT */
                                             /* 0x10 = KNLCAPF_NEED_DECOUPLE */
                                             /* 0x20 = KNLCAPF_DONE_DECOUPLE */
                                             /* 0x40 = KNLCAPF_DOWN_CAPTURE  */
  start_scn       number,     /* scn from which capture process should start */
  capture_userid  number,                        /* capture security context */
  spare1          number,                           /* used for captured scn */
  spare2          number,                                     /* applied scn */
  spare3          number,                       /* checkpoint retention time */
  use_dblink      number,            /* use dblink from downstream to src db */
  first_scn       number, /* initially predump scn, eventually the earliest  */
                          /* scn from which capture process can restart from */
  source_dbname   varchar2("M_XDBI"),            /* global name of source db */
  negative_ruleset_owner varchar2("M_IDEN"),      /* negative rule set owner */
  negative_ruleset_name  varchar2("M_IDEN"),       /* negative rule set name */
  start_date             date,                   /* captures from start date */
  end_date               date,                    /* captures up to end_date */
  error_number           number,             /* error number reported if any */
  error_message          varchar2("M_VCSZ"),         /* explanation of error */
  status_change_time     date,    /* the date that the status column changed */
  version                varchar2(64),             /* capture version number */
  spare4                 number,                                   /* unused */
  spare5                 number,                                   /* unused */
  spare6                 number,                                   /* unused */
  spare7                 varchar2(1000)                            /* unused */
)
/
create unique index i_streams_capture_process1 on streams$_capture_process
 (capture#)
/
create unique index i_streams_capture_process2 on streams$_capture_process
 (capture_name)
/

create sequence streams$_capture_inst        /* capture instantiation number */
  increment by 1
  start with 1
  minvalue 1
  maxvalue 4294967295                           /* max portable value of UB4 */
  cycle
  nocache
/

create table streams$_apply_process
(
  apply#            number         not null, /* apply#0 is reserved for HaDB */
  apply_name        varchar2("M_IDEN") not null,       /* apply process name */
  queue_oid         raw(16)            not null,      /* AQ queue identifier */
  queue_owner       varchar2("M_IDEN") not null,           /* AQ queue owner */
  queue_name        varchar2("M_IDEN") not null,            /* AQ queue name */
  status            number,      /* apply process status: START, STOP, ABORT */
  flags             number,                           /* apply process flags */
  ruleset_owner     varchar2("M_IDEN"),                    /* rule set owner */
  ruleset_name      varchar2("M_IDEN"),                     /* rule set name */
  message_handler   varchar2(98),                         /* message handler */
  ddl_handler       varchar2(98),                             /* DDL handler */
  precommit_handler varchar2(98),                       /* precommit handler */
  apply_userid      number,                        /* apply security context */
  apply_dblink      varchar2("M_XDBI"),               /* apply database link */
  apply_tag         raw("M_CSIZ"),                              /* apply tag */
  spare1            number,
  spare2            number,
  spare3            number,
  negative_ruleset_owner varchar2("M_IDEN"),      /* negative rule set owner */
  negative_ruleset_name  varchar2("M_IDEN"),       /* negative rule set name */
  start_date             date,                      /* apply txn start limit */
  end_date               date,                        /* apply txn end limit */
  error_number           number,             /* error number reported if any */
  error_message          varchar2("M_VCSZ"),         /* explanation of error */
  status_change_time     date,    /* the date that the status column changed */
  ua_notification_handler varchar2(98),   /* user agent notification handler */
  ua_ruleset_owner        varchar2("M_IDEN"),    /* user agent ruleset owner */
  ua_ruleset_name         VARCHAR2("M_IDEN")           /* user agent ruleset */
)
/
create unique index i_streams_apply_process1 on
  streams$_apply_process (apply#)
/
create unique index i_streams_apply_process2 on
  streams$_apply_process (apply_name)
/
create index i_streams_apply_process3 on
  streams$_apply_process (queue_oid)
/

create table streams$_propagation_process
(
  propagation_name           varchar2("M_IDEN") not null,
  source_queue_schema        varchar2("M_IDEN"),
  source_queue               varchar2("M_IDEN"),
  destination_queue_schema   varchar2("M_IDEN"),
  destination_queue          varchar2("M_IDEN"),
  destination_dblink         varchar2("M_XDBI"),
  ruleset_schema             varchar2("M_IDEN"),
  ruleset                    varchar2("M_IDEN"),
  spare1                     number,    /* 0x01 = queue to queue propagation */
  spare2                     varchar2("M_XDBI"),
  negative_ruleset_schema    varchar2("M_IDEN"),  /* negative rule set owner */
  negative_ruleset           varchar2("M_IDEN")    /* negative rule set name */
)
/
create unique index streams$_prop_p_i1 on streams$_propagation_process
(propagation_name)
/
create unique index streams$_prop_p_i2 on streams$_propagation_process
(source_queue_schema,source_queue, destination_queue_schema,
 destination_queue, destination_dblink)
/

rem Table to store parameters for capture and apply processes.
create table streams$_process_params
(
  process_type       number not null,                /* 1 -> apply   process */
                                                     /* 2 -> capture process */
  process#           number not null,                         /* X_process # */
  name               varchar2("M_XDBI") not null,          /* parameter name */
  value              varchar2("M_VCSZ"),                  /* parameter value */
  user_changed_flag  number,            /* 1 if changed by user, 0 otherwise */
  internal_flag      number,    /* 1 if internal param, 0 if exposed to user */
  spare1             number
)
/
create unique index i_streams_process_params1 on
  streams$_process_params (process_type, process#, name)
/

rem Table to store extra attributes for capture
create table streams$_extra_attrs
(
  process#           number not null,                   /* capture_process # */
  name               varchar2("M_IDEN") not null,          /* attribute name */
  include            varchar2("M_IDEN"),       /* the attribute is included? */
  flag               number,   /* 0x01 = row_attribute, 0x02 = ddl_attribute */
  spare1             number,
  spare2             varchar2(1000)
)
/
create unique index i_streams_extra_attrs1 on
  streams$_extra_attrs (process#, name)
/

create table streams$_prepare_object
(
  obj#            number  not null,
  ignore_scn      number  not null,
  timestamp       date,
  flags           number,       /* flags for supplemental logging: see knl.h */
  spare1          number,
  spare2          varchar2(1000)
)
/
create unique index i_streams_prepare1 on streams$_prepare_object (obj#)
/

rem streams$_prepare_ddl is for DDL support.
rem DDL looks up this table to see if a schema or database
rem is prepared for instantiation
create table streams$_prepare_ddl
(
  global_flag number not null,            /* 1 if usrid is null, 0 otherwise */
  usrid       number,             /* user id (NULL for database instantiate) */
  scn         number,                       /* ignore scn (currently unused) */
  timestamp   date,                   /* time at which schema was registered */
  flags       number,           /* flags for supplemental logging: see knl.h */
  spare1      number,
  spare2      varchar2(1000)
)
/
create unique index i_streams_prepare_ddl on
  streams$_prepare_ddl(global_flag, usrid)
/

create table streams$_apply_milestone
(
  apply#          number             not null,
  source_db_name  varchar2("M_XDBI") not null,
  oldest_scn      number             not null,
  commit_scn      number             not null,
  synch_scn       number             not null,           /* Synch-point SCN. */
  epoch           number             not null,         /* Incarnation number */
  processed_scn   number             not null,
                            /* all complete txns < processed_scn are applied */
  apply_time      date,
  applied_message_create_time date,
  spare1          number,
  start_scn       number,
  oldest_transaction_id varchar2("M_LTID")          /* oldest transaction id */
)
/
create unique index i_streams_apply_milestone1 on streams$_apply_milestone
(apply#, source_db_name)
/

rem No constraints on this table it has to be really high performance 
rem since it is inserted on every txn
create table streams$_apply_progress
(
  apply#          number,
  source_db_name  varchar2("M_XDBI"),
  xidusn          number,
  xidslt          number,
  xidsqn          number,
  commit_scn      number,
  spare1          number
)
tablespace SYSAUX
/

create table streams$_key_columns
(
  sname       varchar2("M_IDEN") not null,
  oname       varchar2("M_IDEN") not null,
  type        number             not null,
  cname       varchar2("M_IDEN") not null,
  dblink      varchar2("M_XDBI"),
  long_cname  varchar2("M_VCSZ"),
  spare1      number
)
/
create unique index i_streams_key_columns on 
  streams$_key_columns(sname, oname, type, cname, dblink)
/

rem table used for deferred prcedure calls
create table streams$_def_proc
(
  base_obj_num     number,
  flags            number,
  owner            varchar2("M_IDEN"),
  package_name     varchar2("M_IDEN"),
  procedure_name   varchar2("M_IDEN"),
  param_name       varchar2("M_IDEN"),
  param_type       number,
  raw_value        raw("M_CSIZ"),
  number_value     number,
  date_value       date,
  varchar2_value   varchar2("M_VCSZ"),
  nvarchar2_value  nvarchar2(1000),
  clob_value       clob,
  blob_value       blob,
  nclob_value      nclob
)
/

rem streams$_rules is populated by APIs in dbms_streams_adm
create table streams$_rules
(
  streams_name         varchar2("M_IDEN"),     /* capture/apply/prop process */
  streams_type         number,      /* capture (1), propagation(2), apply (3)*/
  rule_type            number,                           /* dml (1), ddl (2) */
  include_tagged_lcr   number,                                     /* 0 or 1 */
  source_database      varchar2("M_XDBI"),           /* source database name */
  rule_owner           varchar2("M_IDEN"),                     /* rule owner */
  rule_name            varchar2("M_IDEN"),     /* system generated rule name */
  rule_condition       varchar2("M_VCSZ"),  /* system generated rule context */
  dml_condition        varchar2("M_VCSZ"), /* NULL except for row subsetting */
  subsetting_operation number,    /* null, insert (1), update(2), delete (3) */
  schema_name          varchar2("M_IDEN"),  /* schema name, null for db type */
  object_name          varchar2("M_IDEN"),  
                                      /* table name, null for schema/db type */
  object_type          number,       /*  table(1), schema(2),  database (3)  */
  and_condition        varchar2("M_VCSZ"), /* and condition appended to rule */
  spare1               number,
  spare2               number,
  spare3               number
)
/
create unique index i_streams_rules1 on
  streams$_rules(rule_owner, rule_name)
/
create index  i_streams_rules2 on
  streams$_rules(schema_name, object_name)
/

rem subscriptions of source objects
create table apply$_source_obj
(
  id             number              not null,                 /* sequence # */
  owner          varchar2("M_IDEN")  not null,        /* source object owner */
  name           varchar2("M_IDEN")  not null,         /* source object name */
  type           number              not null,         /* source object type */
  source_db_name varchar2("M_XDBI")  not null,       /* source database name */
  dblink         varchar2("M_XDBI"),   /* database link for HS instantiation */
  inst_scn       number,                                /* instantiation scn */
  ignore_scn     number,     /* scn used to determine LCR selection by apply */
  spare1         number
)
/
create unique index i_apply_source_obj1 on
  apply$_source_obj (id)
/
create unique index i_apply_source_obj2 on
  apply$_source_obj (owner, name, type, source_db_name, dblink)
/
rem sequence for apply$_source_obj.id
create sequence apply$_source_obj_id nocache
/

rem source schema instantiation scns
rem a NULL name means a global inst_scn
create table apply$_source_schema
(
  source_db_name varchar2("M_XDBI") not null,        /* source database name */
  /* 1024 if value for RMAN TRANSPORT TABLESPACE otherwise
   * 1 if name is null and 0 if name is non-null.
   */
  global_flag    number             not null,
  name           varchar2("M_IDEN"),                   /* source schema name */
  dblink         varchar2("M_XDBI"),   /* database link for HS instantiation */
  inst_scn       number,                                /* instantiation scn */
  spare1         number
)
/
create unique index i_apply_source_schema1 on
  apply$_source_schema (source_db_name, global_flag, name, dblink)
/

rem source object level (virtual) constraints
create table apply$_virtual_obj_cons
(
  owner          varchar2("M_IDEN")  not null,        /* source object owner */
  name           varchar2("M_IDEN")  not null,         /* source object name */
  powner         varchar2("M_IDEN")  not null,    /* source parent obj owner */
  pname          varchar2("M_IDEN")  not null,     /* source parent obj name */
  spare1         number,
  spare2         number,
  spare3         varchar2("M_IDEN"),
  spare4         varchar2("M_VCSZ")
)
/
create unique index i_apply_virtual_obj_cons on
  apply$_virtual_obj_cons (owner, name, powner, pname)
/

create table sys.apply$_constraint_columns
(
  owner                varchar2("M_IDEN") not null,          /* object owner */
  name                 varchar2("M_IDEN") not null,           /* object name */
  constraint_name      varchar2("M_IDEN") not null,
  cname                varchar2("M_IDEN") not null,           /* column name */
  cpos                 number,                            /* column position */
  long_cname           varchar2("M_VCSZ"),  /* long col name for adt support */
  spare1               number,
  spare2               number,
  spare3               varchar2("M_IDEN"),
  spare4               varchar2("M_VCSZ")
)
/

create unique index sys.apply$_constraint_columns_uix1 on
  sys.apply$_constraint_columns(owner, name, constraint_name, cname)
/
-- to facilitate the query: given a constraint name, find out
-- all related objects
create index sys.apply$_constraint_columns_idx1 on
  sys.apply$_constraint_columns(constraint_name)
/

rem This table allows multiple objects in the destination subscribed to the 
rem same source object.
create table apply$_dest_obj
(
  id              number             not null,                      /* seq # */
  source_owner    varchar2("M_IDEN") not null,           /* source obj owner */
  source_name     varchar2("M_IDEN") not null,            /* source obj name */
  type            number       not null,  /* type of source obj and dest obj */
  owner           varchar2("M_IDEN") not null,             /* dest obj owner */
  name            varchar2("M_IDEN") not null,              /* dest obj name */
  apply#          number,             /* apply process assigned to this dest */
  status          number,                   /* such as pending, ready, error */
  error_notifier  varchar2(92),             /* function to invoke for errors */
  spare1          number
)
/
create unique index i_apply_dest_obj1 on
  apply$_dest_obj (id)
/
rem source and apply# uniquely identify a destination
create unique index i_apply_dest_obj2 on
  apply$_dest_obj (source_owner, source_name, type, apply#)
/
rem destination and apply# uniquely identify a source
create unique index i_apply_dest_obj3 on
  apply$_dest_obj (owner, name, type, apply#)
/
rem sequence for apply$_dest_obj.id
create sequence apply$_dest_obj_id nocache
/

rem column mapping between source and destination tables
create table apply$_dest_obj_cmap
(
  dest_id          number             not null,       /* id of parent row in */
                                                          /* apply$_dest_obj */
  src_long_cname   varchar2("M_VCSZ") not null,        /* source column name */
  dest_long_cname  varchar2("M_VCSZ"),            /* destination column name */
                                          /* if null, same as src_long_cname */
  spare1           number
)
/
rem we need to add src_long_cname to this index but it is > max key len
create index i_apply_dest_obj_cmap1 on 
  apply$_dest_obj_cmap (dest_id)
/

rem apply operations associated with destination object
create table apply$_dest_obj_ops
(
  object_number        number not null,               /* id of parent row in */
                                    /* obj$, -1 if not exists                */
  sname                varchar2("M_IDEN") not null,
  oname                varchar2("M_IDEN") not null,
  apply_name           varchar2("M_IDEN"),
  apply_operation      number not null,              /* apply operation type */
                                                     /* 1 -> INSERT          */
                                                     /* 2 -> UPDATE          */
                                                     /* 3 -> DELETE          */
                                                     /* 4 -> LOB_UPDATE      */
                                                     /* 5 -> ASSEMBLE_LOBS   */
  error_handler        char(1),                      /* 'Y' if error handler */
                                                     /* 'N' if not           */
  user_apply_procedure varchar2(98),  /* if user_apply_procedure is null,    */
                                      /* default apply rules will be used    */
                                      /* or if there is no child row in      */
                                      /* apply$_dest_obj_ops                 */
                                      /* for apply$_dest_obj.id              */
  assemble_lobs        char(1) default 'N',          /* 'Y' if assemble lobs */
                                                     /* 'N' if not           */
  spare1               number,
  spare2               number,
  spare3               number
)
/
create unique index i_apply_dest_obj_ops1 on
  apply$_dest_obj_ops (sname, oname, apply_operation, apply_name)
/

rem table used to store error transaction information
create table apply$_error
( 
  local_transaction_id  varchar2("M_LTID"),     /* Tid of error creation txn */
  source_transaction_id varchar2("M_LTID"),  /* transaction id at the source */
  source_database       varchar2("M_XDBI"),/* node which originated this txn */
  queue_owner           varchar2("M_IDEN") not null,    /* local queue owner */
  queue_name            varchar2("M_IDEN") not null,     /* local queue name */
  apply#                number  not null, /* apply engine processing the txn */
  message_number        number,            /* message which caused the error */
  message_count         number,             /* Number of messages in the txn */
  min_step_no           number,            /* min step no in exception queue */
  recipient_id          number,          /* User ID of the original receiver */
  recipient_name        varchar2("M_IDEN"),  
                                       /* User name of the original receiver */
  source_commit_scn     number,           /* original commit SCN for the txn */
  error_number          number,                     /* error number reported */
  error_message         varchar2("M_VCSZ"),          /* explanation of error */
  aq_transaction_id     varchar2(30),                   /* AQ transaction id */
  spare1                number,
  spare2                number,
  spare3                number,
  error_creation_time   date                     /* time this error occurred */
)
tablespace SYSAUX
/
create unique index streams$_apply_error_unq 
 on apply$_error(local_transaction_id)
 tablespace SYSAUX
/

rem table used to store message ids of error transactions for Streams
create table apply$_error_txn
(
  msg_id               raw(16),        /* unique id of a msg, same as in the */
                                                              /* queue table */
  local_transaction_id varchar2("M_LTID"), /* id of txn that created the err */
  txn_message_number   number          /* unique number of a msg in the txn. */
)
/
create unique index streams$_apply_error_txn_unq
  on apply$_error_txn(local_transaction_id, txn_message_number)
  tablespace SYSAUX
/

rem tables required for conflict resolution
rem apply$_error_handler_sequence is used to generate a value 
rem for log_group_id in apply$_error_handler.

create sequence apply$_error_handler_sequence start with 1
/

rem stores all conflict resolution methods
create table apply$_error_handler
(
  object_number          number,  /* table obj# error handler is defined for */
  method_name            varchar2(92),                     /* name of method */
  resolution_column      varchar2("M_VCSZ"), /* column used to resolve error */
  resolution_id          number,          /* id number for the error handler */
  spare1                 number
)
/
create unique index apply$_error_handler_unq
 on apply$_error_handler(resolution_id)
/

rem stores the column list for update column resolution
create table apply$_conf_hdlr_columns
(
  object_number number,           /* table obj# error handler is defined for */
  resolution_id number,                   /* id number for the error handler */
  column_name   varchar2("M_IDEN"),   /* name of a column in the column list */
                                                /* for a update conf handler */
  spare1        number
)
/
create unique index apply$_conf_hdlr_columns_unq1
 on apply$_conf_hdlr_columns(object_number, column_name)
/
create unique index apply$_conf_hdlr_columns_unq2
 on apply$_conf_hdlr_columns(resolution_id, column_name)
/

rem stores object level information for destination objects
create table streams$_dest_objs
(
  object_number  number,                           /* destination table obj# */
  property       number,                        /* table property - bit flag */
                                       /* 0x01 -> do not compare for deletes */
                                       /* 0x02 -> do not compare for updates */
  dblink         varchar2("M_XDBI"),   /* database link for HS instantiation */
  spare1         number,
  spare2         number,
  spare3         varchar2(1000),
  spare4         varchar2(1000)
)
/

create unique index streams$_dest_objs_i
  on streams$_dest_objs(object_number, dblink)
/

rem stores the columns for which to turn conflict detection off
create table streams$_dest_obj_cols
(
  object_number number,                            /* destination table obj# */
  column_name   varchar2("M_IDEN"),       /* name of the column for which to */
                                              /* turn conflict detection off */
  flag          number,                        /* column property - bit flag */
                                       /* 0x01 -> do not compare for deletes */
                                       /* 0x02 -> do not compare for updates */
  dblink        varchar2("M_XDBI"),    /* database link for HS instantiation */
  spare1        number,
  spare2        varchar2(1000)
)
/

create unique index streams$_dest_obj_cols_i
  on streams$_dest_obj_cols(object_number, column_name, dblink)
/

rem keeps track of the streams privileges granted to a user
create table streams$_privileged_user
(
  user# number not null,     /* user number, this mapping is for user$.user# */
  privs number not null             /* the privileges granted (bit vector) : */
                                    /*   0x1 is streams administrator        */
)
/
create unique index i_streams_privileged_user1
 on streams$_privileged_user(user#)
/

rem populated by dbms_streams_adm.add_message_rule
create table streams$_message_rules
(
  streams_name    varchar2("M_IDEN") not null,      /* name of apply/dequeue */
  streams_type    number not null, /* propagation(2), apply (3), dequeue (4) */
  msg_type_owner  varchar2("M_IDEN"),                  /* message type owner */
  msg_type_name   varchar2("M_IDEN"),                   /* message type name */
  msg_rule_var    varchar2("M_IDEN"),               /* message rule variable */
  rule_owner      varchar2("M_IDEN") not null,                 /* rule owner */
  rule_name       varchar2("M_IDEN") not null,                  /* rule name */
  rule_condition  varchar2("M_VCSZ"),          /* text of the rule condition */
  spare1          number,
  spare2          number,
  spare3          number,
  spare4          varchar2("M_IDEN"),
  spare5          varchar2("M_XDBI")
)
/
create table warning_settings$ (
  obj#          number not null,                           /* object number */
  warning_num   number not null,                          /* warning number */
  global_mod     number,                                 /* global modifier */
  property      number)                                         /* property */
/
create unique index i_streams_message_rules
 on streams$_message_rules(streams_name, streams_type, rule_owner, rule_name)
/

rem consumers of user-enqueued messages
create table streams$_message_consumers
(
  streams_name    varchar2("M_IDEN") not null,            /* name of dequeue */
  queue_oid       raw(16)            not null,        /* AQ queue identifier */
  queue_owner     varchar2("M_IDEN") not null,                /* queue owner */
  queue_name      varchar2("M_IDEN") not null,                 /* queue name */
  rset_owner      varchar2("M_IDEN"),                      /* rule set owner */
  rset_name       varchar2("M_IDEN"),                       /* rule set name */
  neg_rset_owner  varchar2("M_IDEN"),             /* negative rule set owner */
  neg_rset_name   varchar2("M_IDEN"),              /* negative rule set name */
  spare1          number,
  spare2          number,
  spare3          number,
  spare4          varchar2("M_IDEN"),
  spare5          varchar2("M_XDBI")
)
/
create unique index i_streams_message_consumers
 on streams$_message_consumers(streams_name)
/

rem apply spilling transaction information
create table streams$_apply_spill_txn
(
  applyname                 varchar2("M_IDEN") NOT NULL,/* name of the apply */
  xidusn                    number NOT NULL,    /* source transaction ID usn */
  xidslt                    number NOT NULL,    /* source transaction ID slt */
  xidsqn                    number NOT NULL,    /* source transaction ID sqn */
  first_scn                 number NOT NULL,         /* first SCN in the txn */
  last_scn                  number,                   /* last SCN in the txn */
  last_scn_seq              number,              /* last sequence in the txn */
  last_cap_instno           number,          /* capture instantiation number */
  commit_scn                number,                /* commit SCN for the txn */
  spillcount                number,        /* the number of messages spilled */
  err_num                   number,                          /* raised error */
  err_idx                   number,       /* index of lcr which raised error */
  sender                    varchar2("M_IDEN"), /* user who enqueued the txn */
  flags                     number,                       /* txn level flags */
  priv_state                number,                             /* txn state */
  distrib_cscn              number,                /* distributed commit SCN */
  src_commit_time           number,  /* time when txn commited on the source */
  dep_flag                  number,                      /* dependency state */
  spill_flags               number,                  /* spill specific flags */
  first_message_create_time date,          /* time first message was created */
  spill_creation_time       date DEFAULT SYSDATE,  /* time of spill creation */
  txnkey                    number,       /* the id key for this transaction */
  spare1                    number,
  spare2                    number,
  spare3                    number,
  spare4                    number,
  spare5                    varchar2("M_VCSZ"),
  spare6                    varchar2("M_VCSZ"),
  spare7                    varchar2("M_VCSZ")
)
tablespace SYSAUX
/
create unique index i_streams_apply_spill_txn
 on streams$_apply_spill_txn(applyname, xidusn, xidslt, xidsqn)
tablespace SYSAUX
/

rem apply spill tracking table
create table streams$_apply_spill_txn_list
(
  txnkey                    number,/* the id key in streams$_apply_spill_txn */
  status                    varchar2(1),
  spare1                    number,
  spare2                    number,
  spare3                    varchar2("M_VCSZ"),
  spare4                    varchar2("M_VCSZ")
)
tablespace SYSAUX
/


rem
rem File Group Repository tables
rem

rem file groups
create table fgr$_file_groups
(
  file_group_id     number             not null,      /* obj# for file group */
  keep_files        varchar2(1)        not null,        /* keep files setting*/
  min_versions      number             not null,       /* min number to keep */
  max_versions      number             not null,       /* max number to keep */
  retention_days    number             not null,         /* max days to keep */
  creator           varchar2("M_IDEN") not null,       /* file group creator */
  creation_time     timestamp with time zone not null,      /* creation time */
  sequence_name     varchar2("M_IDEN") not null,  /* sequence for version id */
  audit$            varchar2("S_OPFL") not null,         /* auditing options */
  user_comment      varchar2("M_VCSZ"),                      /* user comment */
  default_dir_obj   varchar2("M_IDEN"),          /* default directory object */
  spare1            number,
  spare2            number,
  spare3            varchar2("M_IDEN"),
  spare4            varchar2("M_XDBI")
)
/

create unique index i_fgr$_file_groups1
 on fgr$_file_groups(file_group_id)
/

rem file group versions
create table fgr$_file_group_versions
(
  version_id        number             not null,      /* internal version id */
  file_group_id     number             not null,     /* version's file group */
  creator           varchar2("M_IDEN") not null,        /* version's creator */
  creation_time     timestamp with time zone not null,      /* creation time */
  version_guid      raw(16)            not null,           /* version's GUID */
  version_name      varchar2("M_IDEN") not null,          /* name of version */
  user_comment      varchar2("M_VCSZ"),                      /* user comment */
  default_dir_obj   varchar2("M_IDEN"),          /* default directory object */
  spare1            number,
  spare2            number,
  spare3            varchar2("M_IDEN"),
  spare4            varchar2("M_XDBI")
)
/
create unique index i_fgr$_file_group_versions1
 on fgr$_file_group_versions(version_name, file_group_id)
/
create unique index i_fgr$_file_group_versions2
 on fgr$_file_group_versions(file_group_id, version_id)
/
create unique index i_fgr$_file_group_versions3
 on fgr$_file_group_versions(version_guid)
/

rem file group versions export info
create table fgr$_file_group_export_info
(
  version_guid      raw(16)            not null,           /* version's GUID */
  export_version    varchar2("M_IDEN") not null,     /* export compatibility */
  export_platform   varchar2(101)      not null,          /* export platform */
  export_time       date               not null,              /* export time */
  export_scn        number,                                    /* export scn */
  source_db_name    varchar2("M_XDBI"),         /* global name of the source */
  spare1            number,
  spare2            number,
  spare3            varchar2("M_IDEN"),
  spare4            varchar2("M_XDBI")
)
/
create unique index i_fgr$_file_group_export_info1
 on fgr$_file_group_export_info(version_guid)
/

rem file group files
create table fgr$_file_group_files
(
  file_name         varchar2(512)      not null,                /* file name */
  creator           varchar2("M_IDEN") not null,             /* file creator */
  /* file's creation time */
  creation_time     timestamp with time zone not null,
  file_dir_obj      varchar2("M_IDEN") not null,/* directory object for file */
  version_guid      raw(16)            not null,           /* version's GUID */
  file_size         number,                                     /* file size */
  file_blocksize    number,                               /* file block size */
  file_type         varchar2(32),                               /* file type */
  user_comment      varchar2("M_VCSZ"),                      /* user comment */
  spare1            number,
  spare2            number,
  spare3            varchar2("M_IDEN"),
  spare4            varchar2("M_XDBI")
)
/
create unique index i_fgr$_file_group_files1
 on fgr$_file_group_files(file_name, version_guid)
/
create index i_fgr$_file_group_files2
 on fgr$_file_group_files(version_guid)
/

create table fgr$_tablespace_info
(
  version_guid      raw(16)            not null,           /* version's GUID */
  tablespace_name   varchar2("M_IDEN") not null,          /* tablespace name */
  spare1            number,
  spare2            number,
  spare3            varchar2("M_IDEN"),
  spare4            varchar2("M_XDBI")
)
/
create unique index i_fgr$_tablespace_info1
 on fgr$_tablespace_info(version_guid, tablespace_name)
/
create index i_fgr$_tablespace_info2
 on fgr$_tablespace_info(tablespace_name)
/

create table fgr$_table_info
(
  version_guid      raw(16)            not null,           /* version's GUID */
  schema_name       varchar2("M_IDEN") not null,              /* schema name */
  table_name        varchar2("M_IDEN") not null,               /* table name */
  tablespace_name   varchar2("M_IDEN"),                   /* tablespace name */
  scn               number,                                    /* export scn */
  spare1            number,
  spare2            number,
  spare3            varchar2("M_IDEN"),
  spare4            varchar2("M_XDBI")
)
/
create unique index i_fgr$_table_info1
 on fgr$_table_info(version_guid, schema_name, table_name)
/
create index i_fgr$_table_info2
 on fgr$_table_info(schema_name, table_name, tablespace_name)
/
create index i_fgr$_table_info3
 on fgr$_table_info(table_name)
/

rem table used to store the dropped objects which are still not purged
create table recyclebin$
( 
  obj#                  number not null,           /* original object number */
  owner#                number not null,                /* owner user number */
  original_name         varchar2(32),                /* Original Object Name */
  operation             number not null,            /* Operation carried out */
                                                                /* 0 -> DROP */
                                            /* 1 -> TRUNCATE (not supported) */
  type#                 number not null,          /* object type (see KQD.H) */
  ts#                   number,                         /* tablespace number */
  file#                 number,                /* segment header file number */
  block#                number,               /* segment header block number */
  droptime              date,                /* time when object was dropped */
  dropscn               number,           /* SCN of Tx which caused the drop */
  partition_name        varchar2(32),       /* Name of the partition dropped */
                                                           /* NULL otherwise */
  flags                 number,               /* flags for undrop processing */
  related               number not null,    /* obj one level up in heirarchy */
  bo                    number not null,                      /* base object */
  purgeobj              number not null,   /* obj to purge when purging this */
  base_ts#              number,            /* Base objects Tablespace number */
  base_owner#           number,                 /* Base objects owner number */
  space                 number,       /* number of blocks used by the object */
  con#                  number,       /* con#, if index is due to constraint */
  spare1                number,
  spare2                number,
  spare3                number
)
/
create index recyclebin$_obj on recyclebin$(obj#)
/
create index recyclebin$_ts on recyclebin$(ts#)
/
create index recyclebin$_owner on recyclebin$(owner#)
/

rem fixed object (X$...) information
create table fixed_obj$            
( obj#          number not null,                            /* object number */
  timestamp     date not null,             /* object specification timestamp */
  flags         number,                    /* 0x00000001 = analyzed
                                              0x00000002 = locked            */
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date          
)
  storage (maxextents unlimited)
/
create unique index i_fixed_obj$_obj# on fixed_obj$(obj#)
  storage (maxextents unlimited)
/

rem table to store optimizer statistics for table and table partition objects
create table tab_stats$
( obj#          number not null,                            /* object number */
  cachedblk     number,                            /* blocks in buffer cache */
  cachehit      number,                                   /* cache hit ratio */
  logicalread   number,                           /* number of logical reads */
  rowcnt        number,                                    /* number of rows */
  blkcnt        number,                                  /* number of blocks */
  empcnt        number,                            /* number of empty blocks */
  avgspc        number,       /* average available free space/iot ovfl stats */
  chncnt        number,                            /* number of chained rows */
  avgrln        number,                                /* average row length */
  avgspc_flb    number,       /* avg avail free space of blocks on free list */
  flbcnt        number,                             /* free list block count */
  analyzetime   date,                        /* timestamp when last analyzed */
  samplesize    number,                 /* number of rows sampled by Analyze */
  flags         number,                 /* 0x00000001 = user-specified stats */
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
  storage (initial 32k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_tab_stats$_obj# on tab_stats$(obj#)
  storage (maxextents unlimited)
/


rem table to store optimizer statistics for index and index partition objects
create table ind_stats$   
( obj#          number not null,                            /* object number */
  cachedblk     number,                            /* blocks in buffer cache */
  cachehit      number,                                   /* cache hit ratio */
  logicalread   number,                           /* number of logical reads */
  rowcnt        number,                       /* number of rows in the index */
  blevel        number,                                       /* btree level */
  leafcnt       number,                                  /* # of leaf blocks */
  distkey       number,                                   /* # distinct keys */
  lblkkey       number,                          /* avg # of leaf blocks/key */
  dblkkey       number,                          /* avg # of data blocks/key */
  clufac        number,                                 /* clustering factor */
  analyzetime   date,                        /* timestamp when last analyzed */
  samplesize    number,                 /* number of rows sampled by Analyze */
  flags         number,
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
  storage (initial 32k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_ind_stats$_obj# on ind_stats$(obj#)
  storage (maxextents unlimited)
/

create table proxy_info$
( client#            NUMBER NOT NULL,                      /* client user ID */
  proxy#             NUMBER NOT NULL,                       /* proxy user ID */
  credential_type#   NUMBER NOT NULL,  /* Type of credential passed by proxy */
                   /*
                    * Values
                    * 0 = No Authentication
                    * 5 = Authentication
                    */
  flags               NUMBER NOT NULL /* Mask flags of associated with entry */
             /* Flags values:
              * 1 = proxy can activate all client roles
              * 2 = proxy can activate no client roles
              * 4 = role can be activated by proxy,
              * 8 = role cannot be activated by proxy
              */
)
/
create unique index i_proxy_info$ on proxy_info$(client#, proxy#)
/
create table proxy_role_info$
( client#       NUMBER NOT NULL,                           /* client user ID */
  proxy#        NUMBER NOT NULL,                            /* proxy user ID */
  role#         NUMBER NOT NULL                                   /* role ID */
)
/
create index i_proxy_role_info$_1 on
  proxy_role_info$(client#, proxy#)
/
create unique index i_proxy_role_info$_2 on
  proxy_role_info$(client#, proxy#, role#)
/
grant create table to system
/
grant create snapshot to system
/
grant select any table to system
/
grant global query rewrite to system
/
rem sequence used to generate ids for online redefinitions and its steps
create sequence redef_seq$ increment by 1 start with 1 nocycle
/

rem table to store the redefinition metadata
create table redef$(
  id      integer            not null,                    /* redefinition id */
  name    varchar2("M_IDEN") not null,                /* transformation name */
  state   integer            not null,  /* current state of the redefinition */
  flag    integer                                /* flag (internal use only) */
)
/ 
create unique index ui_redef_id$ on redef$(id)
/
create unique index ui_redef_name$ on redef$(name)
/

rem table to store the information about the objects involved while executing
rem a redefinition
create table redef_object$(
  redef_id       integer            not null,             /* redefinition id */
  obj_type       integer            not null,                 /* object type */
  obj_owner      varchar2("M_IDEN") not null,       /* original object owner */
  obj_name       varchar2("M_IDEN") not null,        /* original object name */
  int_obj_owner  varchar2("M_IDEN"),          /* interim/cloned object owner */
  int_obj_name   varchar2("M_IDEN"),           /* interim/cloned object name */
  bt_owner       varchar2("M_IDEN"),                     /* base table owner */
  bt_name        varchar2("M_IDEN"),                      /* base table name */
  genflag        integer,                        /* flag (internal use only) */
  typflag        integer       /* obj type specific flag (internal use only) */
)   
/
create index i_redef_object$ on
 redef_object$(redef_id, obj_type, obj_owner, obj_name)
/
rem table to store the dependent objects that could not be cloned during the
rem online redefinition
create table redef_dep_error$(
  redef_id       integer            not null,             /* redefinition id */
  obj_type       integer            not null,                 /* object type */
  obj_owner      varchar2("M_IDEN") not null,       /* original object owner */
  obj_name       varchar2("M_IDEN") not null,        /* original object name */
  bt_owner       varchar2("M_IDEN"),                     /* base table owner */
  bt_name        varchar2("M_IDEN"),                      /* base table name */
  ddl_txt        clob                                          /* ddl string */
)  
/
create index i_redef_dep_error$ on
 redef_dep_error$(redef_id, obj_type, obj_owner, obj_name)
/

create table ncomp_dll$                              /* table for ncomp dlls */
( obj#          number not null,                            /* object number */
  version       number,                                    /* version number */
  dll           blob,                                          /* dll object */
  dllname       raw(1024))                      /* os base file name for dll */
  lob (dll) store as native_comp_shared_objects 
	(storage (initial 1m next 1m maxextents unlimited pctincrease 0))
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_ncomp_dll1 on
  ncomp_dll$(obj#, version)
/

rem index (re)build online state
create table ind_online$
( obj#          number not null,
  type#         number not null,              /* what kind of index is this? */
                                                               /* normal : 1 */
                                                               /* bitmap : 2 */
                                                              /* cluster : 3 */
                                                            /* iot - top : 4 */
                                                         /* iot - nested : 5 */
                                                            /* secondary : 6 */
                                                                 /* ansi : 7 */
                                                                  /* lob : 8 */
                                             /* cooperative index method : 9 */
  flags         number not null
                                      /* index is being online built : 0x100 */
                                    /* index is being online rebuilt : 0x200 */
)
/

rem Services persistent database table
create table service$
(
  service_id         number,                                    /* unique ID */
  name               varchar2(64),                             /* short name */
  name_hash          number,                            /* service name hash */
  network_name       varchar2(512),           /* SERVICE_NAME as used by net */
  creation_date      date,                                   /* date created */
  creation_date_hash number,                           /* creation date hash */
  deletion_date      date,                            /* date marked deleted */
  failover_method    varchar2(64),            /* TAF failover characterstics */
  failover_type      varchar2(64),
  failover_retries   number(10),
  failover_delay     number(10),
  min_cardinality    number,                                  /* cardinality */
  max_cardinality    number,
  goal               number,                                 /* service goal */
                                                                 /* none : 0 */
                                                         /* service time : 1 */
                                                             /* throughput : 2 */
  flags              number                       /* service attribute flags */
                                                       /* GRID enabled : 0x1 */
                                                        /* DTP service : 0x2 */
)
/
rem Create the internal system service
insert into service$
  (service_id, name, creation_date)
  values (1, 'SYS$BACKGROUND', sysdate)
/

insert into service$
  (service_id, name, creation_date)
  values (2, 'SYS$USERS', sysdate)
/

create index i_warning_settings on warning_settings$(obj#)
/
rem table used by import and export for storing xml format of export
rem metadata when doing transportable tablespaces.
create table expimp_tts_ct$(
  owner         varchar2("M_IDEN") not null,                  /* table owner */
  tablename     varchar2("M_IDEN") not null,                   /* table name */
  xmlinfo       clob               not null, /* table's metadata from export */
  when          timestamp          not null                    /* for safety */
)
/

rem
rem transparent session migration
rem
create table tsm_src$
(
  /* the following are set by start_migration */
  src_db_name               varchar2("M_VCSZ"),            /* source db name */
  src_inst_name             varchar2("M_VCSZ"),      /* source instance name */
  src_inst_id               varchar2("M_VCSZ"),        /* source instance id */
  src_inst_start_time       timestamp with time zone,
                                           /* start time for source instance */
  sequence#                 number,             /* migration sequence number */
  src_sid                   number,         /* session id on source instance */
  src_serial#               number,            /* serial# on source instance */
  src_state                 number,                       /* migration state */
  connect_string            varchar2("M_VCSZ"),/* destination connect string */
  src_start_time            timestamp with time zone,/* migration start time */
  /* the following are updated by source session */
  cost                      number,              /* estimated migration cost */
  failure_reason            number,       /* reason for failure of migration */
  src_end_time              timestamp with time zone,  /* migration end time */
  roundtrips                number, /* number of roundtrips during migration */
  src_userid                number,                               /* user id */
  src_schemaid              number,                             /* schema id */
  dst_db_name               varchar2("M_VCSZ")        /* destination db name */
)
tablespace SYSAUX
/
create index i_tsm_src1$ on tsm_src$(sequence#)
tablespace SYSAUX
/
create index i_tsm_src2$ on tsm_src$(src_sid, src_serial#, sequence#)
tablespace SYSAUX
/
create table tsm_dst$
(
  src_db_name               varchar2("M_VCSZ"),            /* source db name */
  dst_db_name               varchar2("M_VCSZ"),       /* destination db name */
  dst_inst_name             varchar2("M_VCSZ"), /* destination instance name */
  dst_inst_id               varchar2("M_VCSZ"),   /* destination instance id */
  dst_inst_start_time       timestamp with time zone,
                                      /* start time for destination instance */
  sequence#                 number,             /* migration sequence number */
  dst_sid                   number,    /* session id on destination instance */
  dst_serial#               number,       /* serial# on destination instance */
  dst_start_time            timestamp with time zone,/* migration start time */
  dst_end_time              timestamp with time zone,  /* migration end time */
  dst_userid                number,                               /* user id */
  dst_schemaid              number,                             /* schema id */
  dst_state                 number            /* destination migration state */
)
tablespace SYSAUX
/
create index i_tsm_dst1$ on tsm_dst$(sequence#)
tablespace SYSAUX
/
create index i_tsm_dst2$ on tsm_dst$(dst_sid, dst_serial#, sequence#)
tablespace SYSAUX
/
create sequence tsm_mig_seq$
  increment by 1
  start with 1
  minvalue 0
  nomaxvalue
  cache 10
  order
  nocycle
/

rem table used by director that contains all databases in cluster
create global temporary table cluster_databases(
    database_name varchar2(128),
    sparen1       number,
    sparen2       number,
    sparevc1      varchar2(4000),
    sparevc2      varchar2(4000))
  on commit preserve rows
/

rem table used by director that contains all nodes in cluster
create global temporary table cluster_nodes(
    node_name varchar2(4000),
    sparen1   number,
    sparen2   number,
    sparevc1  varchar2(4000),
    sparevc2  varchar2(4000))
  on commit preserve rows
/

rem table used by director that contains all running instances in cluster
create global temporary table cluster_instances(
    instance_number number,
    database_name   varchar2(128),
    inst_name       varchar2(4000),
    node_name       varchar2(4000),
    sparen1         number,
    sparen2         number,
    sparevc1        varchar2(4000),
    sparevc2        varchar2(4000))
  on commit preserve rows
/

rem table used by director for migrate operations
create table dir$migrate_operations(
   job_name         varchar2(100),
   alert_seq_id     number,
   incarnation_info varchar2(4000),
   service_name     varchar2(4000),
   source_instance  varchar2(4000),
   dest_instance    varchar2(4000),
   session_count    number,
   director_factor  number,
   submit_time      date,
   status           number,
   start_time       date,
   end_time         date,
   actual_count     number,
   error_message    varchar2(4000),
   sparen1          number,
   sparen2          number,
   sparen3          number,
   sparen4          number,
   sparen5          number,
   sparevc1         varchar2(4000),
   sparevc2         varchar2(4000),
   sparevc3         varchar2(4000),
   sparevc4         varchar2(4000),
   sparevc5         varchar2(4000))
tablespace sysaux
/
create unique index sys.i_dir$migrate_ui
  on sys.dir$migrate_operations(job_name, status)
  tablespace sysaux
/
create index sys.i_dir$migrate_end_time
  on sys.dir$migrate_operations(end_time)
  tablespace sysaux
/
create index sys.i_dir$migrate_alert_seq_id
  on sys.dir$migrate_operations(alert_seq_id)
  tablespace sysaux
/
create index sys.i_dir$migrate_status
  on sys.dir$migrate_operations(status)
  tablespace sysaux
/

rem table used by director for service operations
create table dir$service_operations(
   job_name         varchar2(100),
   alert_seq_id     number,
   job_type         number,
   incarnation_info varchar2(4000),
   service_name     varchar2(4000),
   instance_name    varchar2(4000),
   director_factor  number,
   submit_time      date,
   status           number,
   start_time       date,
   end_time         date,
   error_message    varchar2(4000),
   sparen1          number,
   sparen2          number,
   sparen3          number,
   sparen4          number,
   sparen5          number,
   sparevc1         varchar2(4000),
   sparevc2         varchar2(4000),
   sparevc3         varchar2(4000),
   sparevc4         varchar2(4000),
   sparevc5         varchar2(4000))
tablespace sysaux
/
create unique index sys.i_dir$service_ui
  on sys.dir$service_operations(job_name, status)
  tablespace sysaux
/
create index sys.i_dir$service_end_time
  on sys.dir$service_operations(end_time)
  tablespace sysaux
/
create index sys.i_dir$service_alert_seq_id
  on sys.dir$service_operations(alert_seq_id)
  tablespace sysaux
/
create index sys.i_dir$service_status
  on sys.dir$service_operations(status)
  tablespace sysaux
/

rem table used by director for escalate operations
rem this is used to keep track of escalations from
rem the database director to the cluster director
create table dir$escalate_operations(
   escalation_id    varchar2(200),
   alert_seq_id     number,
   escalation       VARCHAR2(20),
   incarnation_info varchar2(4000),
   instance_name    varchar2(4000),
   submit_time      date,
   status           number,
   start_time       date,
   end_time         date,
   retry_time       date,
   retry_count      number,
   error_message    varchar2(4000),
   sparen1          number,
   sparen2          number,
   sparen3          number,
   sparen4          number,
   sparen5          number,
   sparevc1         varchar2(4000),
   sparevc2         varchar2(4000),
   sparevc3         varchar2(4000),
   sparevc4         varchar2(4000),
   sparevc5         varchar2(4000))
tablespace sysaux
/
create unique index sys.i_dir$escalate_ui
  on sys.dir$escalate_operations(escalation_id, status)
  tablespace sysaux
/
create index sys.i_dir$escalate_end_time
  on sys.dir$escalate_operations(end_time)
  tablespace sysaux
/
create index sys.i_dir$escalate_alert_seq_id
  on sys.dir$escalate_operations(alert_seq_id)
  tablespace sysaux
/
create index sys.i_dir$escalate_status
  on sys.dir$escalate_operations(status)
  tablespace sysaux
/

rem table used by database director for 
rem recording quiesce operations
create table dir$quiesce_operations
( 
   job_name         varchar2(100),
   alert_seq_id     number,
   job_type         number,
   incarnation_info varchar2(4000),
   instance_name    varchar2(4000),
   submit_time      date,
   status           number,
   start_time       date,
   end_time         date,
   error_message    varchar2(4000),
   sparen1          number,
   sparen2          number,
   sparen3          number,
   sparen4          number,
   sparen5          number,
   sparevc1         varchar2(4000),
   sparevc2         varchar2(4000),
   sparevc3         varchar2(4000),
   sparevc4         varchar2(4000),
   sparevc5         varchar2(4000))
tablespace sysaux
/

create unique index sys.i_dir$quiesce_ui
  on sys.dir$quiesce_operations(job_name, status)
  tablespace sysaux
/
create index sys.i_dir$quiesce_status
  on sys.dir$quiesce_operations(status)
  tablespace sysaux
/
create index sys.i_dir$quiesce_end_time
  on sys.dir$quiesce_operations(end_time)
  tablespace sysaux
/
create index sys.i_dir$quiesce_alert_seq_id
  on sys.dir$quiesce_operations(alert_seq_id)
  tablespace sysaux
/

rem table used by database director for 
rem recording specific instance actions
rem done by a job
create table dir$instance_actions
( 
   job_name         varchar2(100),
   action_type      number,
   instance_name    varchar2(4000),
   submit_time      date,
   start_time       date,
   end_time         date,
   error_message    varchar2(4000),
   sparen1          number,
   sparen2          number,
   sparen3          number,
   sparen4          number,
   sparen5          number,
   sparevc1         varchar2(4000),
   sparevc2         varchar2(4000),
   sparevc3         varchar2(4000),
   sparevc4         varchar2(4000),
   sparevc5         varchar2(4000))
tablespace sysaux
/


create index sys.i_dir$instance_job_name
  on sys.dir$instance_actions(job_name)
  tablespace sysaux
/

create index sys.i_dir$instance_acttyp
  on sys.dir$instance_actions(action_type)
  tablespace sysaux
/

create index sys.i_dir$instance_end_time
  on sys.dir$instance_actions(end_time)
  tablespace sysaux
/

rem table used by director for resonate operations
create table dir$resonate_operations
( 
   job_name         varchar2(100),
   alert_name       varchar2(200),
   job_type         number,
   incarnation_info varchar2(4000),
   database_name    varchar2(128),
   instance_name    varchar2(4000),
   node_name        varchar2(4000),
   submit_time      date,
   status           number,
   start_time       date,
   end_time         date,
   error_message    varchar2(4000),
   priority         number,
   sparen1          number,
   sparen2          number,
   sparen3          number,
   sparen4          number,
   sparen5          number,
   sparevc1         varchar2(4000),
   sparevc2         varchar2(4000),
   sparevc3         varchar2(4000),
   sparevc4         varchar2(4000),
   sparevc5         varchar2(4000))
tablespace sysaux
/
create unique index sys.i_dir$resonate_ui
  on sys.dir$resonate_operations(job_name, status)
  tablespace sysaux
/
create index sys.i_dir$resonate_status
  on sys.dir$resonate_operations(status)
  tablespace sysaux
/
create index sys.i_dir$resonate_end_time
  on sys.dir$resonate_operations(end_time)
  tablespace sysaux
/
create index sys.i_dir$resonate_alert_name
  on sys.dir$resonate_operations(alert_name)
  tablespace sysaux
/

rem table used by director for keeping alert history
create table dir$alert_history
( 
   alert_name       varchar2(200),
   message_level    number,
   action_id        number,
   reason_id        number,
   last_time        date,
   next_time        date,
   action_time      date,
   incarnation_info varchar2(4000),
   job_name         varchar2(100),
   sparen1          number,
   sparen2          number,
   sparen3          number,
   sparen4          number,
   sparen5          number,
   sparevc1         varchar2(4000),
   sparevc2         varchar2(4000),
   sparevc3         varchar2(4000),
   sparevc4         varchar2(4000),
   sparevc5         varchar2(4000))
tablespace sysaux
/

create index sys.i_dir$alert_history_name
  on sys.dir$alert_history(alert_name)
  tablespace sysaux
/
create index sys.i_dir$alert_history_action_id
  on sys.dir$alert_history(action_id)
  tablespace sysaux
/
create index sys.i_dir$alert_history_reason_id
  on sys.dir$alert_history(reason_id)
  tablespace sysaux
/
create index sys.i_dir$alert_history_at
  on sys.dir$alert_history(action_time)
  tablespace sysaux
/

rem table used by director for keeping reasons
create table dir$reason_strings
( 
   reason_id        number,
   reason           varchar2(4000),
   sparen1          number,
   sparen2          number,
   sparevc1         varchar2(4000),
   sparevc2         varchar2(4000))
tablespace sysaux
/

create unique index sys.i_dir$reason_strings_ui
  on sys.dir$reason_strings(reason_id)
  tablespace sysaux
/

rem table used by director for database priorities
create table dir$database_attributes
(
  database_name        varchar2("M_XDBI"),
  attribute_name       varchar2("M_IDEN"),
  attribute_value      varchar2("M_VCSZ"),
  sparen1              number,
  sparen2              number,
  sparen3              number,
  sparen4              number,
  sparen5              number,
  sparevc1             varchar2("M_VCSZ"),
  sparevc2             varchar2("M_VCSZ"),
  sparevc3             varchar2("M_VCSZ"),
  sparevc4             varchar2("M_VCSZ"),
  sparevc5             varchar2("M_VCSZ"))
tablespace sysaux
/
create unique index sys.i_dir$db_attributes_ui
  on sys.dir$database_attributes(database_name, attribute_name)
  tablespace sysaux
/

rem table used by director for victim database policy function
create table dir$victim_policy
(
  user_name            varchar2("M_IDEN"),
  policy_function_name varchar2(98),  /* policy fun vers. for changing param */
  version              number,
  sparen1              number,
  sparen2              number,
  sparen3              number,
  sparen4              number,
  sparen5              number,
  sparen6              number,
  sparen7              number,
  sparevc1             varchar2("M_VCSZ"),
  sparevc2             varchar2("M_VCSZ"),
  sparevc3             varchar2("M_VCSZ"),
  sparevc4             varchar2("M_VCSZ"),
  sparevc5             varchar2("M_VCSZ"))
tablespace sysaux
/

Rem Table for keeping node attributes
create table dir$node_attributes
( node_name            varchar2(4000),
  attribute_name       varchar2(30),
  attribute_value      varchar2(4000),
  sparen1              number,
  sparen2              number,
  sparen3              number,
  sparen4              number,
  sparen5              number,
  sparevc1             varchar2(4000),
  sparevc2             varchar2(4000),
  sparevc3             varchar2(4000),
  sparevc4             varchar2(4000),
  sparevc5             varchar2(4000))
tablespace sysaux
/

create index sys.i_dir$node_attributes_attr
  on sys.dir$node_attributes(attribute_name)
  tablespace sysaux
/

Rem Table for keeping service attributes
create table dir$service_attributes
( service_id           number,
  attribute_name       varchar2(30),
  attribute_value      varchar2(4000),
  sparen1              number,
  sparen2              number,
  sparen3              number,
  sparen4              number,
  sparen5              number,
  sparevc1             varchar2(4000),
  sparevc2             varchar2(4000),
  sparevc3             varchar2(4000),
  sparevc4             varchar2(4000),
  sparevc5             varchar2(4000))
tablespace sysaux
/
create unique index sys.i_dir$service_attributes_ui
  on sys.dir$service_attributes(service_id, attribute_name)
  tablespace sysaux
/
create index sys.i_dir$service_attributes_attr
  on sys.dir$service_attributes(attribute_name)
  tablespace sysaux
/

create table cache_stats_1$ (
dataobj# number not null,
inst_id number not null,
cached_avg number,
cached_sqr_avg number,
cached_no integer,
cached_seq_no integer,
chr_avg number,
chr_sqr_avg number,
chr_no integer,
chr_seq_no integer,
lgr_sum number,
lgr_last number,
phr_last number,
spare1 number,
spare2 number,
spare3 number,
spare4 number,
spare5 number
)
  storage (maxextents unlimited)
/

create index i_cache_stats_1 on cache_stats_1$(dataobj#, inst_id)
  storage (maxextents unlimited)
/

create sequence cache_stats_seq_1 start with 1 increment by 1
/

create table cache_stats_0$ (
dataobj# number not null,
inst_id number not null,
cached_avg number,
cached_sqr_avg number,
cached_no integer,
cached_seq_no integer,
chr_avg number,
chr_sqr_avg number,
chr_no integer,
chr_seq_no integer,
lgr_sum number,
lgr_last number,
phr_last number,
spare1 number,
spare2 number,
spare3 number,
spare4 number,
spare5 number
)
  storage (maxextents unlimited)
/

create index i_cache_stats_0 on cache_stats_0$(dataobj#, inst_id)
  storage (maxextents unlimited)
/

create sequence cache_stats_seq_0 start with 1 increment by 1
/

/* target list for automated stats collection */
create table stats_target$ (
  staleness number not null,
         /* -100 = no stats, -1.0 ... +1.0 = staleness factor on a log scale */
  osize number not null,                   /* roughly calculated object size */
  obj#  number not null,                               /* target object obj# */
  type# number not null,                   /* target object type# as in obj$ */
  flags number not null, /* 0x0001 = failed with timeout last time           */
                         /* 0x0002 = non-segment level of partitioned object */
  status number not null,
        /* 0 = pending, 1 = gathering in progress, 2 = completed, 3 = failed */
  sid     number, /* session id of the session working/worked on this object */
  serial# number,    /* serial# of the session working/worked on this object */
  part#  number,                  /* [sub]partition# if applicable else null */
  bo# number                                          /* base or parent obj# */
   /* table partition: obj# of the parent table                              */
   /* table subpartition: obj# of the parent table partition                 */
   /* non-partitioned or global index: obj# of the base table                */
   /* local index partition: obj# of the corresponding table partition       */
   /* local index subpartition: obj# of the corresponding table subpartition */
   /* else: null                                                             */
)
  storage (maxextents unlimited)
  tablespace sysaux;
create index i_stats_target1 on stats_target$ (staleness, osize, obj#, status)
  storage (maxextents unlimited)
  tablespace sysaux;
create unique index i_stats_target2 on stats_target$ (obj#)
  storage (maxextents unlimited)
  tablespace sysaux;

create table resource_plan$
( obj#                number not null,                       /* obj# of plan */
  name                varchar2("M_IDEN"),                    /* name of plan */
  mandatory           number,                   /* whether plan is mandatory */
  cpu_method          varchar2("M_IDEN"),  /* cpu resource allocation method */
  mast_method         varchar2("M_IDEN"),        /* active sess. pool method */
  pdl_method          varchar2("M_IDEN"),    /* parallel degree limit method */
  num_plan_directives number,           /* number of directives for the plan */
  description         varchar2("M_CSIZ"),                         /* comment */
  status              varchar2("M_IDEN"),       /* whether active or pending */
  que_method          varchar2("M_IDEN")                  /* queueing method */
)
/
create table resource_consumer_group$
( obj#              number not null,                        /* obj# of group */
  name              varchar2("M_IDEN"),                     /* name of group */
  mandatory         number,                    /* whether group is mandatory */
  cpu_method        varchar2("M_IDEN"),    /* cpu resource allocation method */
  description       varchar2("M_CSIZ"),                           /* comment */
  status            varchar2("M_IDEN")          /* whether active or pending */
)
/
create table resource_plan_directive$
( obj#                      number not null,          /* obj# of parent plan */
  plan                      varchar2("M_IDEN"),       /* name of parent plan */
  group_or_subplan          varchar2("M_IDEN"),  /* name of group or subplan */
  is_subplan                number not null,  /* whether the above is a plan */
  description               varchar2("M_CSIZ"),                   /* comment */
  mandatory                 number,    /* whether the directive is mandatory */
  cpu_p1                    number, /* first parameter for cpu alloc. method */
  cpu_p2                    number,   /* second param. for cpu alloc. method */
  cpu_p3                    number, /* third parameter for cpu alloc. method */
  cpu_p4                    number,   /* fourth param. for cpu alloc. method */
  cpu_p5                    number, /* fifth parameter for cpu alloc. method */
  cpu_p6                    number, /* sixth parameter for cpu alloc. method */
  cpu_p7                    number,  /* seventh param. for cpu alloc. method */
  cpu_p8                    number,   /* eighth param. for cpu alloc. method */
  max_active_sess_target_p1 number,        /* old mast parameter--UNUSED NOW */
  parallel_degree_limit_p1  number,                         /* pdl parameter */
  status                    varchar2("M_IDEN"), /* whether active or pending */
  active_sess_pool_p1       number,                    /* NEW mast parameter */
  queueing_p1               number,                  /* queue timeout in sec */
  switch_group              varchar2("M_IDEN"),    /* new group to switch to */
  switch_time               number, /* max allowed execution time in a group */
  switch_estimate           number,          /* use execution time estimate? */
  max_est_exec_time         number,             /* max. estimate time in sec */
  undo_pool                 number,       /* max. cumulative undo allocation */
  max_idle_time             number,                 /* max. idle time in sec */
  max_idle_blocker_time     number,    /* max. idle time blocking other sess */
  switch_back               number        /* switch back at end of top call? */
)
/
create table resource_group_mapping$
( attribute           varchar2("M_IDEN"),          /* mapping attribute type */
  value               varchar2(128),             /* attribute value to match */
  consumer_group      varchar2("M_IDEN"),          /* name of consumer group */
  status              varchar2("M_IDEN")        /* whether active or pending */
)
/
create table resource_mapping_priority$
( attribute           varchar2("M_IDEN"),          /* mapping attribute type */
  priority            number,                 /* priority of mapping (1 - 8) */
  status              varchar2("M_IDEN")        /* whether active or pending */
)
/
insert into resource_group_mapping$ 
  (attribute, value, consumer_group, status)
  (select 'ORACLE_USER', name,  defschclass, 'ACTIVE' from user$
   where defschclass is not null and defschclass != 'DEFAULT_CONSUMER_GROUP')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('EXPLICIT', 1, 'ACTIVE')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('ORACLE_USER', 7, 'ACTIVE')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('SERVICE_NAME', 6, 'ACTIVE')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('CLIENT_OS_USER', 9, 'ACTIVE')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('CLIENT_PROGRAM', 8, 'ACTIVE')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('CLIENT_MACHINE', 10, 'ACTIVE')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('MODULE_NAME', 5, 'ACTIVE')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('MODULE_NAME_ACTION', 4, 'ACTIVE')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('SERVICE_MODULE', 3, 'ACTIVE')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('SERVICE_MODULE_ACTION', 2, 'ACTIVE')
/
insert into resource_mapping_priority$ (attribute, priority, status)
  values ('CLIENT_ID', 11, 'ACTIVE')
/

create table enc$ (
  obj#    number,                                     /* table object number */
  owner#  number,                         /* user id of the master key owner */
  mkeyid  varchar2(64),                           /* global id of master key */
  encalg  number,                                 /* encryption algorithm id */
  intalg  number,                                  /* integrity algorithm id */
  colklc  raw(2000),                                   /* column key locator */
  klclen  number,                                   /* length of key locator */
  flag    number                                                     /* flag */
)
/

create unique index enc_idx on enc$(obj#, owner#)
/

rem Recoverable script : table storing recoverable script details
create table reco_script$
( 
  oid                    raw(16),                        /* global unique id */
  invoking_package_owner varchar2("M_IDEN"),   /* pkg owner of invoking proc */
  invoking_package       varchar2("M_IDEN"),     /* name of the invoking pkg */
  invoking_procedure     varchar2("M_IDEN"),    /* name of the invoking proc */
  invoking_user          varchar2("M_IDEN"),                /* invoking user */
  total_blocks           number,     /* total number of blocks in the script */
  context                clob,        /* any context the user wishes to pass */
                                /* between blocks, like some state variables */
  status                 number,   /* GENERATING, EXECUTING, EXECUTED, ERROR */
  done_block_num         number,
                            /* nth block that has been successfully executed */
  script_comment         varchar2("M_VCSZ"),   /* comments passed in by user */
  ctime                  date default SYSDATE,         /* script create time */
  spare1                 number,
  spare2                 number,
  spare3                 number,
  spare4                 varchar2(1000),
  spare5                 varchar2(1000),
  spare6                 date
)
tablespace SYSAUX
/ 

create unique index reco_script$_unq
  on reco_script$ (oid)
tablespace SYSAUX
/

rem Recoverable script : table storing operation parameters
create table reco_script_params$
(
  oid            raw(16),               /* global unique id of the operation */
  param_index    number,               /* to associate multivalue parameters */
  name           varchar2("M_IDEN"),                    /* name of parameter */
  value          varchar2(4000),                       /* value of parameter */
  spare1         number,
  spare2         number,
  spare3         varchar2(1000)
)
tablespace SYSAUX
/

create unique index reco_script_params$_unq
  on reco_script_params$ (oid, name, param_index)
tablespace SYSAUX
/

rem Recoverable script : table storing recoverable script blocks
create table reco_script_block$
(
  oid                  raw(16),                          /* global unique id */
  block_num            number,                    /* nth block in the script */
  forward_block        clob,                 /* forward block to be executed */
  forward_block_dblink varchar2("M_XDBI"),/* where forward block is executed */
  undo_block           clob,     /* block to be executed in case of rollback */
  undo_block_dblink    varchar2("M_XDBI"),   /* where undo block is executed */
  state_block          clob,        /* block to be executed to set the state */
  status               number,   /* EXECUTED, ERROR, NOT EXECUTED, EXECUTING */
  context              clob,              /* any ctx the user wishes to pass */
  block_comment        varchar2("M_VCSZ"),    /* user comments for the block */
  ctime                date default SYSDATE,   /* time the block was created */
  spare1               number,
  spare2               number,
  spare3               number,
  spare4               varchar2(1000),
  spare5               varchar2(1000),
  spare6               date
)
tablespace SYSAUX
/

create unique index reco_script_block$_unq
  on reco_script_block$ (oid, block_num)
tablespace SYSAUX
/

rem Recoverable script : table storing recoverable script errors
create table reco_script_error$
(
  oid                 raw(16),                           /* global unique id */
  block_num           number,                       /* nth block that failed */
  error_number        number,                                /* error number */
  error_message       varchar2("M_VCSZ"),                   /* error message */
  error_creation_time date default SYSDATE,            /* time error occured */
  spare1              number,
  spare2              varchar2(1000)
)
tablespace SYSAUX
/

